---
title: 五、栈与队列
math: true
categories:
  - leetcode
abbrlink: 700d279
date: 2025-07-24 09:56:39
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250907104942188-2025-9-910:52:09.png" style="zoom:80%;" />

思路：依次读取s中的字符，若是左括号，则入栈；若是右括号，则弹出栈顶括号判断是否匹配。

匹配失败的情况：

- 栈顶括号与当前括号不匹配
- 将s遍历完，栈不为空，则左括号单身。
- s遍历过程中，栈为空，则右括号单身

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        //遇到左括号，则入栈
        if (c == '(' || c == '{' || c == '[') { 
            stack.push(c);
            continue;
        }
        //遇到右括号，则弹出栈顶的左括号判断是否匹配
        if (stack.isEmpty()) //右括号单身
            return false;

        char r = stack.pop();    
        if (c == ')' && r != '(') return false;
        if (c == '}' && r != '{') return false;
        if (c == ']' && r != '[') return false;

    }
    //最终，若栈为空，则所有括号都匹配，否则有左括号单身
    return stack.isEmpty();
}
```

***

进阶🤣：

- [括号生成](https://leetcode.cn/problems/generate-parentheses/)
- [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
- [ 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

## [删除字符串中的所有相邻重复项（消消乐）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240811164748125-2024-8-1116:47:48.png" style="zoom:80%;" />

> 匹配问题都是栈的强项



思路一：使用栈来处理。遍历字符串S，当栈为空时，将当前字符入栈；当栈不为空时，判断栈顶元素与当前字符是否匹配：

- 若匹配，则栈顶元素出栈，继续遍历下一字符。
- 若不匹配，则将当前元素入栈。

最终，将栈中剩余字符组成的字符串**反转**后返回即可。

{% note info%}

其实使用双端队列更合适，每次从队尾进行入队和出队操作，最终直接返回队列中字符组成的字符串即可。

{% endnote%}

```java
public String removeDuplicates(String s) {
    if (s.length() == 1) return s;
    Deque<Character> stack = new ArrayDeque<>();

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (stack.isEmpty() || stack.peek() != c)
            stack.push(c);
        else 
            stack.pop();
    }
    StringBuilder sb = new StringBuilder();
    while(!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.reverse().toString();
}
```

***

思路二：使用快慢指针。快指针遍历字符串中的每个字符，慢指针构造最终结果字符串。每次将fast位置字符放到slow所指位置，再判断当前加入的字符和前一个字符是否相同：

- 若相同则slow--，下次加入的字符覆盖掉当前相同的字符
- 否则slow++，指出下一个加入的位置。

> 由于java中的String是不可变的，不可避免的要将其转换为char数组进行处理；而对于c++中的string，修改操作直接在原对象上进行，空间复杂度为O(1).

```java
public String removeDuplicates(String s) {
    char[] chs = s.toCharArray();
    int slow = 0, fast = 0;
    while (fast < chs.length) {
        chs[slow] = chs[fast];
        if (slow > 0 && chs[slow] == chs[slow - 1])
            slow--;
        else
            slow++;
        fast++;
    }
    return new String(chs, 0, slow);
}
```

## [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250909121641854-2025-9-912_16_48-2025-9-912:35:11.png" style="zoom:80%;" />

逆波兰表达式即后缀表达式，表达式求值是栈的经典应用。

思路详见：[栈在表达式求值中的应用](https://catpaws.top/d403458d/#栈在表达式求值中的应用)

```java
public int evalRPN(String[] tokens) {
    Deque<Integer> stack = new ArrayDeque<>();
    String operators = "+-*/";
    for (String s : tokens) {
        //遇到数字，则入栈
        if (!operators.contains(s))
            stack.push(Integer.valueOf(s));
        //遇到运算符，则弹出栈顶两个元素执行相应运算
        else { 
            int right = stack.pop(); //先弹出的是右操作数
            int midRes = calculate(stack.pop(), right, s);
            stack.push(midRes);
        }
    }
    return stack.pop();
}

public int calculate(int left, int right, String operator) {
    if (operator.equals("+"))
        return left + right;
    else if (operator.equals("-"))
        return left - right;
    else if (operator.equals("*"))
        return left * right;
    else
        return left / right;
}
```

{% note warning %}

踩坑：由于自己的粗心，在 `calculate` 方法中，使用 `== ` 进行String字符串比较，而不是用 `equals` 方法。`==` 比较的是字符串对象的引用，而不是内容。由于输入中的运算符字符串对象与代码中的字符串字面量不是同一个对象，这些比较几乎总是返回 `false`，因此无论实际运算符是什么，都会执行除法操作，最终经过几次运算出现了除数为零的错误。

总结：== 和 equals的使用

`==` 是java中比较运算符，它有两种使用场景

- 对于**基本数据类型**，比较的是值是否相等
- 对于**引用类型**，比较的是对象的内存地址是否相同（即是否指向同一个对象）

`equals()` 是 Object 类的方法，用于比较两个对象的内容是否相等：

- 默认行为：与 `==` 相同，比较对象引用
- 许多类（如 String、Integer）重写了 equals() 方法，使其比较对象内容

因此：对应基本数据类型的比较，总是使用 `==`；字符串比较，总是使用 `equals()`；在对象的比较中，若需要比较引用，使用 `==`，若需要比较内容，使用 `equals()`。同时使用 `Objects.equals()`比较能避免 NullPointerException

{% endnote %}

***

进阶：

[基本计算器](https://leetcode.cn/problems/basic-calculator/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250909164228926-2025-9-916:42:31.png" style="zoom:80%;" />

如何处理一元运算符`-`：当判断出当前是一元运算后，先手动往操作数栈中入栈一个0

一元负号出现的正确条件：

1. 表达式开头，例如"-1"
2. 左括号后，例如"(-1+2)"
3. 运算符后，例如"1+ -2"

```java
public int calculate(String s) {
    Deque<Integer> nums = new ArrayDeque<>();//操作数栈
    Deque<Character> operators = new ArrayDeque<>();//运算符栈

    //预处理，删除所有空格
    s = s.replaceAll(" ", "");

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);

        //遇到数字
        if (Character.isDigit(c)) {
            // 读取完整数字
            int num = 0;
            while (i < s.length() && Character.isDigit(s.charAt(i))) {
                num = num * 10 + (s.charAt(i) - '0');
                i++;
            }
            nums.push(num);
            i--; // 因为for循环会i++，所以这里减一
        } else if (c == '(') { //遇到左括号
            operators.push(c);
        } else if (c == ')') { //遇到右括号
            //依次从运算符栈中弹出运算符，直至弹出左括号;同时从操作数栈中弹出两个操作数进行相应运算，运算结果压入操作数栈顶
            while (operators.peek() != '(') {
                char op = operators.pop();
                int right = nums.pop(); //先出栈的是右操作数
                int left = nums.pop();
                nums.push(applyOp(op, right, left));
            }
            operators.pop(); // 弹出左括号
        } else { //遇到运算符
            // 依次从运算符栈中弹运算符，直至栈顶为左括号或栈为空,同时从操作数栈中弹出两个操作数进行相应运算，运算结果压入操作数栈顶, 最后将当前运算符压入运算符栈

            // 处理一元负号
            if (c == '-' && isUnary(s, i)) {
                nums.push(0);
            }
            // 这里只有加减，优先级相同，所以可以弹出所有非'('的运算符
            while (!operators.isEmpty() && operators.peek() != '(') {
                nums.push(applyOp(operators.pop(), nums.pop(), nums.pop()));
            }
            operators.push(c);
        }
    }
	// 处理剩余的运算符
    while (!operators.isEmpty()) {
        nums.push(applyOp(operators.pop(), nums.pop(), nums.pop()));
    }
    return nums.pop();
}
// 判断是否为一元负号
boolean isUnary(String s, int i) {
    if (i == 0)
        return true;
    char prev = s.charAt(i - 1);
    return prev == '(' || prev == '+' || prev == '-' || prev == '*' || prev == '/';
}

//先传入的是右操作数
public int applyOp(char operator, int right, int left) {
    if (operator == '+')
        return left + right;
    else
        return left - right;
}
```

另一种解法：

{% spoiler "递归解法"%}

使用一个递归函数recursion来处理当前括号内的子表达式，天然地处理了括号的嵌套

- `res`：累计当前表达式的结果
- `tmp`：暂存当前正在解析的数字
- `sign`：记录当前数字的符号（1表示正，-1表示负）

遇到数字则计算当前数字（连续数字字符组成整数）。

遇到加号或减号，则将当前数字乘以sign加到结果中，然后重置tmp为0，并更新sign。

遇到左括号，递归处理括号内的表达式，并将递归结果乘以当前的sign加到结果中。

遇到右括号，返回当前结果加上当前数字乘以sign（因为右括号前可能还有数字没加）。

```java
class Solution {

    private int i;
    private int n;
    private String s;

    public int calculate(String s) {
        i = 0;
        n = s.length();
        this.s = s;

        return recursion();
    }
	
    private int recursion() {
        int res = 0;
        int tmp = 0;
        int sign = 1;

        while (i < n) {
            char c = s.charAt(i);

            switch (c) {
                case ' ':
                    i++;
                    break;
                case '+':
                    res += tmp * sign;
                    tmp = 0;
                    sign = 1;
                    i++;
                    break;
                case '-':
                    res += tmp * sign;
                    tmp = 0;
                    sign = -1;
                    i++;
                    break;
                case '(':
                    i++;
                    res += recursion() * sign;
                    break;
                case ')':
                    i++;
                    return res + tmp * sign;
                default:
                    tmp = tmp * 10 + (c - '0');
                    i++;
            }
        }

        return res + tmp * sign;
    }
}
```



{% endspoiler %}



[基本计算器III](https://leetcode.cn/problems/basic-calculator-iii/description/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/calculator3-2025-9-918:31:38.png" style="zoom:80%;" />

相比于[基本计算器](https://leetcode.cn/problems/basic-calculator/)，只是多了乘除运算，在其基础上加一个优先级判断即可。当遇到运算符时，依次从运算符栈中弹出优先级>=当前运算符的元素，直至栈顶为左括号或栈为空。

```java
public int calculate(String s) {
    Deque<Integer> nums = new ArrayDeque<>();//操作数栈
    Deque<Character> operators = new ArrayDeque<>();//运算符栈

    //预处理，删除所有空格
    s = s.replaceAll(" ", "");

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);

        //遇到数字
        if (Character.isDigit(c)) {
            // 读取完整数字
            int num = 0;
            while (i < s.length() && Character.isDigit(s.charAt(i))) {
                num = num * 10 + (s.charAt(i) - '0');
                i++;
            }
            nums.push(num);
            i--; // 因为for循环会i++，所以这里减一
        } else if (c == '(') { //遇到左括号
            operators.push(c);
        } else if (c == ')') { //遇到右括号
            //依次从运算符栈中弹出运算符，直至弹出左括号;同时从操作数栈中弹出两个操作数进行相应运算，运算结果压入操作数栈顶
            while (operators.peek() != '(') {
                char op = operators.pop();
                int right = nums.pop(); //先出栈的是右操作数
                int left = nums.pop();
                nums.push(applyOp(op, right, left));
            }
            operators.pop(); // 弹出左括号
        } else { //遇到运算符
            // 依次从运算符栈中弹出运算符，直至栈顶为左括号或栈为空,同时从操作数栈中弹出两个操作数进行相应运算，运算结果压入操作数栈顶, 最后将当前运算符压入运算符栈

            // 处理一元负号
            if (c == '-' && isUnary(s, i)) {
                nums.push(0);
            }
            
            while (!operators.isEmpty() && operators.peek() != '(' && level(operators.peek()) >= level(c)) {
                nums.push(applyOp(operators.pop(), nums.pop(), nums.pop()));
            }
            operators.push(c);
        }
    }

    while (!operators.isEmpty()) {
        nums.push(applyOp(operators.pop(), nums.pop(), nums.pop()));
    }
    return nums.pop();
}

boolean isUnary(String s, int i) {
    if (i == 0)
        return true;
    char prev = s.charAt(i - 1);
    return prev == '(' || prev == '+' || prev == '-' || prev == '*' || prev == '/';
}


public int applyOp(char operator, int right, int left) {
    if (operator == '+')
        return left + right;
    else if (operator == '-')
        return left - right;
    else if (operator == '*')
        return left * right;
    return left / right;
}

public int level(char c) {
    if (c == '+' || c == '-')
        return 1;
    else
        return 2;
}

```

## [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

题目描述：给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。（<span style="color:red">Top k问题</span>）

基本思路：

- 统计元素出现的次数。
- 对次数排序。
- 找出前 k个高频元素。

Top K问题是堆的经典应用。

首先可以使用HashMap统计各个元素出现的频率。之后遍历HashMap，根据出现的频率将对应的元素存入大小为k的优先级队列[PriorityQueue](https://catpaws.top/d5381517/#priorityqueue)（小根堆）中，最终优先级队列中存储的就是频率前k高的元素。

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map  = new HashMap<>();
    //统计频率
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
	
    // 创建优先队列（小根堆），比较器基于频率
    Queue<Integer> heap = new PriorityQueue<>(
        (a, b) -> map.get(a) - map.get(b)
    );
	
    //遍历HashMap的键，维护大小为k的堆
    for (int num : map.keySet()) {
        heap.offer(num);
        if (heap.size() > k) 
            heap.poll(); //移除频率最低的元素
    }

    //收集前k个高频元素
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = heap.poll();
    }
    return res;
}
```





## 单调队列

**单调队列**是一种特殊的队列，它保证队列中的元素（或元素的某个属性）是单调的（递增或递减）。与普通队列的 FIFO 原则不同，单调队列为了维护其单调性，会从**队尾**插入新元素，但可能会从**队尾**或**队首**删除元素。

- **单调递增队列**：从队首到队尾，元素是单调递增的。常用于维护**滑动窗口的最小值**。
- **单调递减队列**：从队首到队尾，元素是单调递减的。常用于维护**滑动窗口的最大值**。

核心思想：在遍历序列的过程中，维护一个“候选元素集合”。新元素加入时，会“淘汰”掉队列中所有不可能成为未来窗口极值的元素（从队尾开始淘汰），以保证队列的单调性。同时，需要检查队首元素是否已经滑出窗口，并及时移除。

***

单调队列几乎是为**滑动窗口** 问题量身定做的数据结构，以[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)问题为例，分析单调队列的工作流程。

由于要求最大值，因此使用一个**单调递减队列**（求最小值用递增队列）。队列中存储的是元素的**索引**，因为索引可以同时提供**值**和**位置**信息，后者对于判断元素是否滑出窗口至关重要。

遍历数组 `nums` 的每个索引 `i`，在其中做四件事：

- **维护队首**：检查队首索引对应的元素是否已经不在当前窗口`[i - k + 1, i]` 内。如果是，则将其从**队首**弹出。
- **维护单调性**：从**队尾**开始，弹出所有 小于等于  `nums[i]`的元素对应的索引。因为新来的 `nums[i]` 更大且更新，队列中所有比它小的元素都不可能再成为未来窗口的最大值，所以它们被“淘汰”了。
- **新元素入队**：将当前索引 `i` 加入队尾。
- **记录结果**：当 `i >= k - 1`（即窗口首次被填满后），每个窗口的最大值就是当前队首索引对应的元素 。

时间复杂度分析：由于每个元素最多被**入队一次**和**出队一次**，因此整体时间复杂度是$O(n)$

{% note info %}

单调队列的精髓在于**从队尾淘汰无用元素**，**从队首移除过期元素**。它是一个“知道得太多的”数据结构，它通过巧妙的淘汰机制，提前排除了那些永远不可能成为答案的候选者，从而实现了高效计算。

{% endnote %}



### [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/无标题-2025-9-922:55:25.png" style="zoom:80%;" />

基本思路：窗口每移动一次就求当前窗口中的最大值，将各个窗口中的最大值收集起来即可。关键是求每个窗口中的最大值。

思路一：使用容量为k的大根堆存储窗口中的值，窗口元素的最大值就是堆顶元素。但是随着窗口移动需要频繁调整堆结构。每次调整堆结构的时间复杂度是调$O(k)$，窗口共要移动 n-k+1次，因此总的时间复杂度是$O(nk)$，和暴力解法的时间复杂度相同。在 k 较大时会变得非常慢，可能接近 $O(n²)$，

> 窗口每移动一次需要删除从堆中删除一个元素，<u>由于不一定是堆顶元素，需要遍历查找堆数组找到下标</u>，再从堆中删除，时间复杂度是$O(k) + O(log_2K)$。最后将新元素插入堆中并调整堆结构，时间复杂度是$(O(log_2k))$。因此移动一次窗口，调整堆结构的时间复杂度是$O(k)$。

***

思路二：使用单调队列。单调队列几乎是为**滑动窗口** 问题量身定做的数据结构。

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    //使用双端队列Deque作为优先队列，用于记录索引
    Deque<Integer> queue = new ArrayDeque<>(); 
    int n = nums.length;
    int[] res = new int[n - k + 1];

    for (int i = 0; i < n; i++) {
        // 检查队首是否已超出窗口范围 (i - k + 1 是当前窗口的左边界)
        if (!queue.isEmpty() && queue.peek() < i - k + 1) {
            queue.poll();
        }

        //从队尾开始，淘汰所有小于当前值的元素（维护单调递减性）
        // 将 <= 改为 >=后，维护的是单调递增性，得到的就是单调增队列
        while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){
            queue.pollLast();
        }
        //新元素入队
        queue.offer(i);

        // 当窗口形成后，记录结果（队首元素即为当前窗口最大值的索引）
        if (i >= k - 1){
            res[i - k + 1] = nums[queue.peek()];
        }
    }
    return res;
}
```



## 单调栈

**单调栈**是一种特殊的栈结构，它要求栈内的元素（或元素的某种属性）始终保持**单调性**。

- **单调递增栈**：从栈顶到栈底，元素是单调递增的（或非递减的）。
- **单调递减栈**：从栈顶到栈底，元素是单调递减的（或非递增的）。

它的核心思想是：**在遍历一个序列（如数组）时，利用栈来维护一个“待定的候选元素集合”。当新元素到来时，通过与新元素比较，可以确定栈中哪些候选元素的答案就是这个新元素，从而将它们弹出并记录结果，最后再将新元素入栈，以保持栈的单调性。**

栈中存储的通常是**索引**，因为索引可以获取值，还可以计算宽度、距离等信息。

如何选择单调性：找“**更大”**用“**增**”栈，找“**更小**”用“**减**”栈。如果想要找更大的，堆顶就得是最小的（单调递增），这样才能一遇到大的就触发操作；找更小的同理。

栈的核心作用是以某种顺序（递增或递减）保存之前已经遍历过的元素，或者说**尚未找到答案的候选元素**，将当前元素与栈顶元素对比，快速找到栈顶元素之前或之后满足某种大小关系的第一个元素。

它擅长解决以下类型的问题：

- 下一个更大元素：找出数组中每个元素右边第一个比它大的元素。
- 下一个更小元素：找出数组中每个元素右边第一个比它小的元素。
- 上一个更大/更小元素：找出左边第一个比它大或小的元素。
- 衍生问题：如「柱状图中的最大矩形」、「接雨水」等，其核心都可转化为寻找每个元素两边的边界（第一个比它小或大的元素）。

***

以最经典的 **“下一个更大元素”** 问题为例，分析单调栈（此处使用**单调递减栈**）的工作原理。

目标：对于数组 `nums` 中的每个元素 `nums[i]`，找到其右边第一个比它大的元素`nums[j]`

创建一个空栈 `stack`，用于存储元素的索引。

遍历数组 `nums` 的每个索引 `i`：

- **维护单调性**：当栈不为空，且当前元素 `nums[i]` 大于栈顶索引对应的元素 ，这意味着当前元素 `nums[i]` 正是栈顶索引对应元素的下一个更大元素，此时弹出栈顶索引并记录结果。重复以上过程，直到“淘汰”掉所有比当前元素小且已找到答案的元素。
- **新元素入栈**：将当前索引 `i` 压入栈中。当前元素 `nums[i]` 现在成为了新的“候选者”，它需要等待后续的元素来为自己提供答案。

遍历结束后，栈中可能还剩余一些元素。这些元素意味着在整个数组中，它们的右边**不存在比它们更大的元素**。

时间复杂度分析：每个元素**最多只会被压入栈一次和弹出栈一次**，整个过程的弹出和压入操作总数与数组长度 `n` 成线性关系。因此使用单调栈解决问题的时间复杂度为$O(n)$

{% note info %}

栈内存储的是一系列**尚未找到“下一个更大元素”的候选者的索引**。这些候选者按照从顶到底、值逐渐变大的顺序排列（单调递增）。当一个**更大**的新元素 `nums[i]` 到来时，它就像一把“钥匙”，可以解锁（弹出）栈中所有比它小的元素，并成为它们的答案。

{% endnote %}

### [每日温度](https://leetcode.cn/problems/daily-temperatures/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911115015025-2025-9-1111:50:18.png" style="zoom:80%;" />

思路：使用 单调递增栈 存储每天温度对应的索引。创建与天数相同大小的数组res存储最终结果，初始化为0，表示没有比当天温度更高的了。

遍历temperatures数组：

- 若栈为空，当前元素的索引入栈。

- 若栈不为空，弹出栈顶所有比当前元素小 的元素对应 的索引，栈顶元素与右侧第一个比它的元素的距离，就是两者是索引的差值；最后将当前元素的索引入栈。

遍历完后可能栈中还有索引剩余，它们在结果数组 `res` 中对应的值保持为初始的默认值0，无需额外操作。

```java
public int[] dailyTemperatures(int[] temperatures) {
    Deque<Integer> stack = new ArrayDeque<>();
    int n = temperatures.length;
    int[] res = new int[n];

    for (int i = 0; i < n; i++) {
        // 维护单调性：当前元素大于栈顶元素时,弹出栈顶元素（索引），并记录答案
        while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]){
            int j = stack.pop();
            res[j] = i - j;
        }
        //当前索引入栈
        stack.push(i);
    }
    //遍历结束，栈中剩余元素的res值保持为-1，表示没有比那一天温度更高的
    return res;
}
```

### [下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911121006649-2025-9-1112:10:08.png" style="zoom:80%;" />

对比 [每日温度](https://leetcode.cn/problems/daily-temperatures/)，就是在外面多套了一层，需要拿着第一个数组中的元素，在第二个数组中找它的下一个更大元素。复杂的点是：当在第二个数组中找到了下一个更大元素，需要在第一个数组中找到其位置，再将更大元素保存在该位置。为了解决这个问题可以使用HashMap做元素和位置的映射，从而快速找到要存放的位置。

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Deque<Integer> stack = new ArrayDeque<>();
    Map<Integer, Integer> map = new HashMap<>();
    int[] res = new int[nums1.length];
    Arrays.fill(res, -1);
	
    // 建立映射
    for (int i = 0; i < nums1.length; i++) {
        map.put(nums1[i], i);
    }

    for (int i = 0; i < nums2.length; i++) {
        // 1、维护单调性：当前元素大于栈顶元素时,弹出栈顶元素（索引），并记录答案
        while(!stack.isEmpty() && nums2[i] > nums2[stack.peek()]) {
            //nums2[j]找到了第一个比它大的元素
            int j = stack.pop();
            //如果nums2[j]是 nums1中的元素，就记录结果
            if (map.containsKey(nums2[j])) { 
                res[map.get(nums2[j])] = nums2[i];
            }
        }
        //2、 当前索引入栈
        stack.push(i);
    }
    //遍历结束，栈中剩余元素的res值保持为-1
    return res;
}
```



### [下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911154443978-2025-9-1115:44:47.png" style="zoom:80%;" />

给定的nums是**循环数组**，要找到每个元素的下一个更大元素需要遍历nums数组两遍，因此可以通过模运算模拟成环，当遍历指针超出nums长度时，通过模上数组长度让它重新指回数组首部。

使用单调递增栈解决下一个更大元素的问题，栈中存放的是元素索引。为了避免重复计算，只有在第一次遍历中才将索引放入栈中，寻找下一个更大元素。

```java
public int[] nextGreaterElements(int[] nums) {
    Deque<Integer> stack = new ArrayDeque<>();
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, -1);
    int index;
    
    //遍历两遍以处理循环
    for (int i = 0; i < 2 * n; i++) {
        index = i % n; //取模
        
        //维护单调性：当前元素大于栈顶元素时,弹出栈顶元素（索引），并记录答案
        while (!stack.isEmpty() && nums[index] > nums[stack.peek()]) {
            res[stack.pop()] = nums[index]; 
        }

        if (index < n) { //只在第一次遍历时压入索引
            stack.push(index);
        }
    }
    return res;
}
```



### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911092401377-2025-9-1109:24:29.png" style="zoom:80%;" />

基本思路：雨水存在于凹槽处，将各个凹槽的水量加起来即可。

对于每个凹槽：

- 水面高度取决于两侧较低的柱子，h = min(left , right) - cur
- 水面宽度是两侧柱子中间的距离，w = right的下标 - left的下标 - 1

故一个凹槽的储水量为 h * w。



雨水量有两种计算方式：按行计算和按列计算。

- 按行计算：每次计算一个水平段的雨水量，凹槽的边界是左右**第一个**比当前高的柱子

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911214256191-2025-9-1121:42:58.png" style="zoom:80%;" />

- 按列计算：每一列柱子独立计算其能接住的雨水量，凹槽的边界是**左边最高**和**右边最高**的柱子

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911214322645-2025-9-1121:43:23.png" style="zoom:80%;" />



***

暴力解法

思路：计算以每个位置的柱子为底部的凹槽 所能贡献的雨水量，将各个位置所贡献的水量加起来即可。

遍历每个柱子，同时在当前循环中，从当前位置向左向右遍历，寻找两侧的最高柱，计算它们三个组成的凹槽所能贡献的雨水，最终将每一列的储水量累加起来即可。第一个和最后一个柱子无法构造凹槽，在遍历过程中可以跳过。

显而易见，暴力解法采用**按列**方式计算雨水量，每个凹槽的宽度都是1，每列的储水量 = min(left, right) - cur

> 由于是按列计算雨水量，需要寻找两侧比当前柱子高的最高柱，而非第一个比它高的柱子
>
> <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911212950738-2025-9-1121:29:54.png" style="zoom:80%;" />

复杂度分析：因为每次遍历列的时候，还要向两边寻找最高的列，所以时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。

```java
public int trap(int[] height) {
    int sum = 0;
    int n = height.length;
    for (int i = 0; i < n; i++) {
        // 第一个柱子和最后一个柱子不接雨水
        if (i == 0 || i == n - 1)
            continue;
        int lHeight = height[i]; //记录左侧比它高的最高柱
        int rHeight = height[i]; //记录右侧比它高的最高柱
        for (int j = i - 1; j >= 0; j--) {
            if (height[j] > lHeight)
                lHeight = height[j];
        }

        for (int j = i + 1; j < n; j++) {
            if (height[j] > rHeight)
                rHeight = height[j];
        }

        //累加当前列的储水量
        int h = Math.min(lHeight, rHeight) - height[i];
        if (h > 0) 
            sum += h;
    }

    return sum;
}
```

***

动态规划

在暴力解法中，只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积。而为了得到两边的最高高度，每到一个柱子都向两边遍历一遍，其中存在许多重复计算。

可以每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。

当前位置，左边的最高高度 = 前一个位置的左边最高高度 与 高度的最大值。右边的最高高度同理。

```java
public int trap(int[] height) {
    int length = height.length;
    if (length <= 2) return 0;
    int[] maxLeft = new int[length];
    int[] maxRight = new int[length];

    // 记录每个柱子左边柱子最大高度（从左往右）
    maxLeft[0] = height[0];
    for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);

    // 记录每个柱子右边柱子最大高度 （从右往左）
    maxRight[length - 1] = height[length - 1];
    for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);

    // 求和
    int sum = 0;
    for (int i = 0; i < length; i++) {
        int count = Math.min(maxLeft[i], maxRight[i]) - height[i];
        if (count > 0) sum += count;
    }
    return sum;
}
```

复杂度分析：需要三次遍历height数组，时间复杂度为$O(n)$。需要两个与height大小相同的数组，空间复杂度也为$O(n)$

***

双指针法（最优解）

**核心**：对于每个位置，它能接的雨水量取决于它左右两侧最大高度的较小值（水桶效应）。

双指针法使用两个指针 `left` 和 `right` 分别从数组的两端向中间移动，同时维护两个变量 `left_max` 和 `right_max`，分别记录<u>从左端到 `left` 指针的最大高度</u>和<u>从右端到 `right` 指针的最大高度</u>。

双指针法的核心策略是：**总是移动高度较小的指针**。因为这样可以确保在处理当前位置时，另一侧有一个更高的柱子作为“屏障”。

- 当处理左指针时，我们知道右边至少有一个柱子（当前右指针）不低于左边任何柱子
- 当处理右指针时，我们知道左边至少有一个柱子（当前左指针）不低于右边任何柱子

这样，我们就不需要知道另一侧的全局最大高度，只需要知道当前侧的最大高度即可。



具体执行过程如下，当 left 指针小于等于 right 指针时，执行循环：

若 `h[left] < h[right]`，比较当前柱子高度 与 左边最大高度：

- 如果 `h[left] >= left_max`，当前柱子比之前的左边最大值大，无法积水。更新左侧最大值为当前柱子高度
- 否则，计算当前位置能接的雨水量 `left_max - h[left]`并累加到总和中
- left++

否则，比较当前柱子高度 与 右边最大高度

- 如果 `h[right] >= right_max`，更新 `right_max = h[right]`
- 否则，计算当前位置能接的雨水量：`right_max - h[right]` 并累加到总和中
- right--

复杂度分析：两个指针移动的距离总和就是给定柱子的个数n，因此时间复杂度为$O(n)$，由于没有使用额外的辅助空间，空间复杂度为$O(1)$

```java
public int trap(int[] height) {
    int n = height.length;
    if (n <= 2) return 0;

    int left = 0, right = n - 1;
    int left_max = 0, right_max = 0; //记录左右两侧的最大值
    int sum = 0;

    while (left <= right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? left_max = height[left] : sum += (left_max - height[left]);
            left++;
        } else { 
            height[right] >= right_max ? right_max = height[right] :sum += (right_max - height[right]);
            right--;
        }
    }
    return sum;

}
```



***

使用单调栈

单调栈使用**按行方式**计算雨水量，关键是从当前位置向左寻找第一个比它高的柱子，向右寻找第一个比它高的柱子，计算它们三个所组成的凹槽的积水量。

思路：维护一个单调递增栈，栈中存储的是每个柱子的索引。在遍历数组时，每当遇到一个比栈顶柱子高的柱子，就说明形成了一个凹槽。

- 栈顶的柱子是凹槽底部
- 当前的遍历柱子是凹槽的右边界（右侧第一个比它高的）
- 将当前栈顶元素弹出后，新的栈顶元素是左边界（左侧第一个比它高的）
  - 注：此时不要错将栈顶弹出了，只要取到值即可


计算每个凹槽的储水量，累加起来即可。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912110107459-2025-9-1211:01:43.png" style="zoom:80%;" />

与上面方法不同的是第一个柱子和最后一个柱子不能跳过，因为它们可能是某个凹槽的左边界和右边界。

复杂度分析：每个柱子最多只会被压入栈一次和弹出栈一次，时间复杂度是$O(n)$；由于使用了栈存储所有可能构成凹槽的元素，空间复杂度也是$O(n)$

```java
public int trap(int[] height) {
    Deque<Integer> stack = new ArrayDeque();
    int n = height.length;
    if (n < 3) return 0; //至少要三个柱子才可能接住雨水

    int sum  = 0;
    for (int i = 0; i < n; i++) {
        while(!stack.isEmpty() && height[i] > height[stack.peek()]) {
            //找到了一个凹槽
            int bottom = stack.pop();
            if (stack.isEmpty()) break; //不存在左边界，无法组成凹槽
            int leftIndex = stack.peek(); //***注意，此时左边界不用弹出，只要取到它的值就行
            int w = i - leftIndex - 1; //凹槽的宽度
            int h = Math.min(height[i], height[leftIndex]) - height[bottom]; //凹槽的高度
            sum += w * h; //累加每个凹槽的储水量
        }
        stack.push(i);
    }
    return sum;
}
```

### [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250911224840034-2025-9-1122:48:41.png" style="zoom:80%;" />

思路：计算以每个柱子为基准所能勾勒出来的最大矩形的面积，取其中的最大值即可。

以某个柱子的高度为基准所能勾勒出来的最大矩形，取决于这个矩形的边界在哪，即这个矩形有多宽。

以示例中高度为1的柱子为例，左侧没有比它低的，右侧也没有比它低的，因此以高度为1的柱子为基准所能勾勒出的最大矩形的宽度为6，面积为1*6；再以高度为5的柱子为例，左侧第一个比它低的柱子（左边界）下标为1，右侧第一个比它低的柱子（有边界）下标为4，因此以该柱子为基准所能勾勒出的最大矩形的宽度为 4 -1 -1，即左右两侧第一个比它低的柱子之间的距离。

因此关键是求一个数左右两侧第一个比它小的数，这是单调栈应用的经典场景，与之前的接雨水问题很相似。

使用一个**单调递减栈**，栈中存放每个柱子的索引。在遍历数组时，每当遇到一个比栈顶低的柱子，栈顶柱子右侧第一个比它低的柱子就找到了，将栈顶元素出栈后，新的栈顶柱子就是它左侧第一个比它低的柱子，这样以栈顶元素为基准的最大矩形的面积就可以计算了。每个柱子都会入栈一次，计算以每个柱子为基准的最大矩形面积，取最大值即可。

这样看来，本题的思路与接雨水的思路完全相同，但本题在具体处理上也有它的独特之处：接雨水问题中一个柱子可以没有它的左边界和右边界，此时它的储水量为0；但矩形面积计算必须依赖左右边界，否则就无法计算宽度。因此为了避免这种情况的出现，**需要手动给数组首尾加0**.

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912120452068-2025-9-1212:04:58.png" alt="首部加0，保证每个元素都有左边界" style="zoom:80%;" />

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912121530252-2025-9-1212:15:31.png" alt="尾部加0，保证每个元素有右边界" style="zoom:80%;" />



```java
public int largestRectangleArea(int[] heights) {
    int n = heights.length;
    if (n == 1) return heights[0];
    //单调递减栈
    Deque<Integer> stack = new ArrayDeque<>();
    int maxArea = 0;

    //给原数组首尾加0
    int[] nh = new int[n+2];
    nh[0] = 0;
    for (int i = 0; i < n; i++) {
        nh[i+1] = heights[i];
    }
    nh[n+1] = 0;


    for (int i = 0; i < n+2; i++) {
        while (!stack.isEmpty() && nh[i] < nh[stack.peek()]) {
            int cur = stack.pop();
            int w = i - stack.peek() - 1; //矩形的宽
            int h = nh[cur];  // 矩形的高
            maxArea = Math.max(maxArea, h * w); //计算矩形面积，取最大值
        }
        stack.push(i);
    }
    return maxArea;
}
```

