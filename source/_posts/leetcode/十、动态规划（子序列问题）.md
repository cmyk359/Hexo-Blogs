---
title: 十、动态规划（子序列问题）
math: true
hide: true
categories:
  - leetcode
abbrlink: d1640fbc
date: 2025-04-10 19:11:35
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## 一、最长递增子序列

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250410195726169-2025-4-1019:59:31.png" style="zoom:80%;" />

[Leetcode题目链接](https://leetcode.cn/problems/longest-increasing-subsequence/)

{% note info%}

首先明确两个概念：

- 子序列：是指从给定序列中去除一些元素（也可能不去除）后，剩余元素组成的序列。重要的是，这个过程中剩余元素的**相对顺序保持不变**。
- 子串：串中任意个**连续的字符**组成的子序列称为该串的子串。

{% endnote%}

动归五部曲

1. 确定dp数组及下标的含义

   dp[i] 表示以nums[i]结尾的最长上升子序列的长度

2. 确定递推公式

   用`j`遍历从0到i-1各个位置的元素。

   若nums[i] > nums[j]，则可以在以nums[j]为结尾的上升子序列的基础上，再增加一个nums[i]，得到更长的上升子序列，其长度为dp[j]+1。取各个位置能与nums[i]构成的上升子序列中长度的最大值，即为`dp[i]`。所以递推公式为

   `if(nums[i] > num[j])  dp[i] = max(dp[i], dp[j] + 1)` 

3. 初始化dp数组

   任意单个数字都可以算作长度为1的上升子序列，故dp[i]的初始值都是1

4. 确定遍历顺序

   dp[i]是由0到i-1各个位置的最长上升子序列推导而来，故一定是从前向后遍历i（外层）。

    遍历[0, i-1]范围内的元素，从前向后或从后向前均可，只要都遍历到即可，故也采用从前向后遍历j（内层）

5. 举例推导dp数组



最终的结果并不一定是dp[nums.length - 1]，因为最长的上升子序列可能并不是以最后一个元素结尾的，应该取所有dp[i]的最大值。

```java
public int lengthOfLIS(int[] nums) {
    int len = nums.length;
    //dp[i] 表示以nums[i]结尾的最长上升子序列的长度
    int[] dp = new int[len];
    Arrays.fill(dp,1); //都初始化为1
    int result = dp[0];
    for (int i = 1; i < len; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j])
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
        result = Math.max(result, dp[i]); //取最长的子序列长度
    }
    return result;
}
```

复杂度分析

- 时间复杂度：$O(n^2)$，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 $O(n)$ 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 $O(n^2)$。

- 空间复杂度：$O(n)$，需要额外使用长度为 n 的 dp 数组。