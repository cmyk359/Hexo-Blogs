---
title: 六、二叉树
categories:
  - leetcode
abbrlink: f47c7c7b
date: 2025-08-04 09:20:56
math: true
tags:
---

<meta name = "referrer", content = "no-referrer"/>

[树和二叉树的相关知识点](https://catpaws.top/453281de/)

链式存储的二叉树的结构：

```java
public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归三要素：

- **确定递归函数的参数和返回值**：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- **确定终止条件**：写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- **确定单层递归的逻辑**：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## [先序遍历 NLR](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

递归遍历

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preOrder(root, res);
    return res;
}

public void preOrder(TreeNode root, List<Integer> res) {
    if (root == null) return;
    res.add(root.val); //根
    preOrder(root.left, res); //左
    preOrder(root.right, res); //右
}
```

***

迭代遍历

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。因此，可通过手动操作栈的方式代替递归。

思路：

- 首先根节点入栈。此后，若栈不为空，则弹出栈顶元素访问。
- 若栈顶元素右孩子不为空，则先入栈右孩子；
- 若栈顶元素左孩子不为空，则再入栈左孩子。

由于栈后进先出的特性，入栈时先右后左，出栈处理时先左后右

```java
public List<Integer> preorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    stack.push(root);
    while(!stack.isEmpty()) {
        TreeNode node = stack.pop(); //访问根结点
        res.add(node.val);
        if (node.right != null) stack.push(node.right);  //先入栈右孩子
        if (node.left != null) stack.push(node.left);  //再入栈左孩子
    }
    stack = null;
    return res;
}
```



## [中序遍历 LNR](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

递归遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inOrder(root, res);
        return res;
    }
    public void inOrder(TreeNode root, List<Integer> res) {
        if (root == null) return;
        inOrder(root.left, res); //左
        res.add(root.val);//根
        inOrder(root.right, res);//右
    }
}
```

***

迭代遍历

思路：

1. 沿着根的左孩子，依次入栈，直至左孩子为空。此时说明已经找到可以输出的结点

2. 栈顶元素出栈并访问，转向处理右孩子

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new LinkedList();
    Deque<TreeNode> stack = new LinkedList<TreeNode> ();
    if (root == null) return res;

    TreeNode p = root;
    while (p != null || !stack.empty()) {
        if (p != null) { //一路向左，不空就入栈
            stack.push(p);
            p = p.left;
        } else { //左孩子为空，可以访问当前结点，出栈
            TreeNode node = stack.pop();
            list.add(node.val);
            p = node.right; //转向右孩子
        }
    }
    return list;
}
```



## [后序遍历 LRN](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

递归遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer>res = new ArrayList<>();
        postOrder(root,res);
        return res;
    }
    public void postOrder(TreeNode root, List<Integer>res) {
        if (root == null) return;
        postOrder(root.left,res); //左
        postOrder(root.right,res);//右
        res.add(root.val); //根
    }
}
```

****

迭代遍历

方法一：参考先序遍历的做法：先根节点入栈，再右孩子入栈，再左孩子入栈，最后得到的遍历序列是  `根 左 右`。

若颠倒其中左右孩子入栈顺序可到最终的遍历顺序为 `根 右 左` ，再将其逆序（不直接输出，而是存入另一个栈中）可得到后序遍历序列 `左 右 根`

```java
public List<Integer> postorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    Deque<Integer> res = new LinkedList<>();

    if (root == null) return new ArrayList<>(res);

    stack.push(root);
    //入栈时顺序为：根左右，出栈时顺序为：根右左，出栈收集时存入另一个栈中，就能得到逆序的结果 左右根
    while(!stack.isEmpty()) {
        TreeNode node = stack.pop();
        res.push(node.val);
        if (node.left != null)  stack.push(node.left);
        if (node.right != null) stack.push(node.right);
    }
    return new ArrayList<>(res);
}
```

方法二：用一个栈实现。使用c指向栈顶结点，h跟踪刚出栈访问的结点。



**`h` 的作用**：通过记录最近访问的节点，判断当前节点 `c` 的子树是否已被处理：

- 若 `h == c.left`：说明左子树已处理完毕。
- 若 `h == c.right`：说明右子树已处理完毕。
- 若 `h` 既不是左也不是右孩子，说明左右子树均未处理。

对于栈顶节点c：

- 如果它的<u>左子树存在</u>且<u>尚未处理</u>（即h既不是左孩子也不是右孩子），则处理左子树
- 如果左子树已经处理或者左子树为空，而<u>右子树存</u>在且<u>尚未处理</u>（h不是右孩子），则处理右子树。
- 如果<u>左右子树都处理完了</u>，或<u>左右子树均为空</u>时，则处理当前节点。

```java
public List<Integer> postorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    List<Integer> res = new ArrayList<>();

    if (root == null) return res;

    TreeNode h = root; //h跟踪最近出栈的结点，只要最开始不指向根节点的左右孩子即可
    TreeNode c = null; //c指向栈顶结点

    stack.push(root);
    while(!stack.isEmpty()) {
        c = stack.peek();
        //左子树不为空，最近出栈访问的既不是c左孩子也不是c的右孩子，则c的左子树还没处理完
        if (c.left != null && h != c.left && h != c.right) {
            stack.push(c.left);
        //左子树已处理完毕，且右子树不为空，最近出栈访问的不是c的右孩子，则c的右子树还未处理完
        } else if ( c.right != null && h != c.right) {
            stack.push(c.right);
        } else { //左右子树均处理完，或左右子树都为空时，处理当前结点
            h = stack.pop();
            res.add(h.val);
        }
    }
    return res;
}
```



## [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240420174246041-2024-8-410:43:30.png"  style="zoom:67%;" />

层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树，需要借用一个辅助**队列**来实现。

队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

最终输出时，需要将每一层的结点放在一起。故需要知道当前层什么时候结束，可以使用一个变量`size`遍历记录当前层结点的个数。每次出队size个结点，此时当前层的结点均已出队，且当前队列中保存着下一层的所有结点。继续下去，直至队列为空。

{% note warning%}

关于队列的实现

`LinkedList` 允许加入 `null` 元素，而 `ArrayDeque` 不允许。在二叉树遍历中，经常需要将 `null` 节点加入队列来表示空子树，因此 `LinkedList` 是更合适的选择。

{% endnote%}

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    int size = 0;
    Queue<TreeNode> queue = new LinkedList<>(); //使用队列存储每层的节点
    queue.offer(root);

    while (!queue.isEmpty()) {
        size = queue.size(); //记录当前层的结点个数
        List<Integer> levelNodes = new ArrayList<>();
        while (size-- != 0) {
            TreeNode node = queue.poll();
            levelNodes.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(levelNodes);
    }
    return res;
}
```

## 层序遍历的扩展

### [二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914174423547-2025-9-1417:44:53.png" style="zoom:80%;" />

收集每层的结果时，将其放在list首部即可；或者将层序遍历得到的最终数组反转一下也行。

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null)
        return res;

    int size = 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        size = queue.size();
        List<Integer> level = new ArrayList<>();
        while (size-- != 0) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null)
                queue.offer(node.left);
            if (node.right != null)
                queue.offer(node.right);
        }
        res.add(0,level); //每次都放入list首部，即可实现最终自底向上的遍历结果
    }
    return res;
}
```



### [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914175431295-2025-9-1417:54:31.png" style="zoom:80%;" />

只需在层序遍历的基础上，知道当前层是第几层，奇数层收集时，每次加入到列表尾部；偶数层收集时，加入到列表头部。注意，此时收集每层遍历结果时要使用`LinkedList`，方便在列表首尾进行操作。

或者奇数层保持不变，偶数层将收集的结点逆置后加入结果。

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    int size = 0, level = 1;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        size = queue.size();
        LinkedList<Integer> levelNodes = new LinkedList<>();
        while(size-- != 0) {
            TreeNode node = queue.poll();
            if (level % 2 == 0) { //偶数层每次加入到列表头部
                levelNodes.addFirst(node.val);
            }else {
                levelNodes.addLast(node.val);
            }

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(levelNodes);
        level++; //层数+1
    }
    return res;
}
```



### [找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182000841-2025-9-1418:20:01.png" style="zoom:80%;" />

思路：

1. 利用层序遍历，当收集到最后一层的结果时，返回当前层第一个结点。
2.  将层序遍历顺序改为==从右到左==遍历，最后一个出列的结点即为所求。

```java
public int findBottomLeftValue(TreeNode root) {
    if (root.left == null && root.right == null) return root.val;
    Queue<TreeNode> queue = new LinkedList<>();
    TreeNode node = root;
    queue.offer(root);
    while(!queue.isEmpty()) {
        node = queue.poll();
        if (node.right != null) //先右
            queue.offer(node.right);
        if (node.left != null) //后左
            queue.offer(node.left);
    }
    return node.val;
}
```

### [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/) 

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182339643-2025-9-1418:23:40.png" style="zoom:80%;" />

 思路：利用层序遍历，每层遍历顺序为从左到右，记录并收集每层最后一个结点即可。

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null)
        return res;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int size = 0;
    while (!queue.isEmpty()) {
        size = queue.size();
        TreeNode node = null;
        while (size-- != 0) {
            node = queue.poll();
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(node.val); //收集每层最后一个节点的值
    }
    return res;
}
```



### [填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/) 

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182924491-2025-9-1418:29:27.png" style="zoom:80%;" />

思路：采用层序遍历，遍历每层的结点的同时连接结点的next指针域，可以像链表那样使用虚拟头结点便利结点的连接。

```java
public Node connect(Node root) {
    if (root == null) return root;

    int size = 0;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    Node headNode = new Node(); //头节点
    while (!queue.isEmpty()) {
        size = queue.size();
        Node pre = headNode; //每层开始时，pre指向头节点
        while (size-- != 0) {
            Node node = queue.poll();
            pre.next = node;
            pre = node;
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
    return root;
}
```



### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) 

**最大深度** 是从根节点到最远叶子节点的最长路径上的节点数量。

{% note primary%}

二叉树节点的**深度**：指<u>从根节点到该节点</u>的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）

二叉树节点的**高度**：指<u>从该节点到叶子节点</u>的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**用前序求的就是深度（从上往下累加），用后序求的是高度（从下往上累加）。**

{% endnote%}

思路：当前二叉树的最大深度即为这棵二叉树整体的高度，利用<u>层序遍历</u>或<u>后序遍历</u>求二叉树高度。

使用层序遍历时，每进入一层就深度加一，处理完所有层节点也就得到了树的高度。

使用后续遍历时，先求左子树深度，再求右子树深度，最后取左右深度中的最大值再加一，就是当前节点为根节点的树的高度。

```java
//层序求树的高度
public int maxDepth(TreeNode root) {
    if (root == null)
        return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int size = 0, deepth = 0;
    while (!queue.isEmpty()) {
        size = queue.size();
        while (size-- != 0) {
            TreeNode node = queue.poll();
            if (node.left != null)
                queue.offer(node.left);
            if (node.right != null)
                queue.offer(node.right);
        }
        deepth++; //高度+1
    }
    return deepth;
}

//后序求树的高度
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    //当前树的高度等于左右子树的最大高度+1
    return Math.max(leftDepth, rightDepth) + 1;
}
```



### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) 

**最小深度**是从根节点到最近叶子节点的最短路径上的节点数量。

思路：利用<u>层序遍历</u>或<u>后序遍历</u>求二叉树最小深度。

使用层序遍历，记录每层的深度，当某层中有结点的左右孩子均为空时，找到了最近的叶子结点，返回此时的深度即可。

使用后序遍历时，当一个节点右子树为空，左子树不为空时，则以该节点为根的子树的最小深度为左子树的深度+1，右不为空而左为空的情况亦同（当前节点不是叶子节点，而是只有一个孩子的节点，最近的叶子节点在不为空的那棵子树中）；当左右子树都不为空，则返回左右子树深度的最小值+1.

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int size = 0, deepth = 0;
    while (!queue.isEmpty()) {
        size = queue.size();
        deepth ++;
        TreeNode node = null;
        while (size-- != 0) {
            node = queue.poll();
            //如果当前节点的左右孩子都为空，直接返回最小深度
            if (node.left == null && node.right == null) 
                return deepth;
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
    return deepth;
}

//后序求最小深度：关键之处在于正确处理单子树为空的情况
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = minDepth(root.left);
    int rightDepth = minDepth(root.right);
    //如果左子树为空，最小深度等于右子树深度+1
    if (root.left == null) {
        return rightDepth + 1;
    }
    //如果右子树为空，最小深度等于左子树深度+1
    if (root.right == null) {
        return leftDepth + 1;
    }
    // 如果左右子树都存在，最小深度等于左右子树深度的较小值+1
    return Math.min(leftDepth, rightDepth) + 1;
}
```

## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914212843799-2025-9-1421:29:14.png" style="zoom:80%;" />

思路：**只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**。关键在于遍历顺序，遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

这道题目使用前序遍历、后序遍历、层序遍历都可以，唯独中序遍历不行。

{% note info %}

当使用中序遍历时：

1. 首先递归遍历左子树。
2. 然后访问当前节点并交换其左右子树。
3. 最后递归遍历右子树。

但问题在于，交换左右子树后，当前节点的右子树实际上变成了原来的左子树（刚刚被遍历过的子树）。这意味着接下来要遍历的“右子树”其实是已经遍历过的左子树，从而导致原来的左子树被再次遍历。

{% endnote%}

```java
public TreeNode invertTree(TreeNode root) {
    preOrderInvert(root);
    return root;
}
//先序遍历：先交换左右孩子结点，然后反转左子树、右子树
public void preOrderInvert(TreeNode node) {
    if (node == null) return;
    //交换当前结点的左右孩子
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
    
    preOrderInvert(node.left); //左
    preOrderInvert(node.right); //右
}

//迭代法略（使用先序遍历的迭代法或者层序遍历）
```



## 同时遍历两棵树

同时遍历两棵二叉树是指同步地访问两棵树中的对应节点，通常用于比较两棵树的结构或值是否相同，解决二叉树比较、合并或同步操作的问题。

采用递归方式时与一棵树的遍历逻辑是一样的，只要在递归函数中传入两棵树的根节点即可实现同步遍历。

采用迭代遍历时，需要将要比较的节点成对地放入队列或栈中，再每次成对的取出来进行比较实现同步遍历。

由于两棵树的结构不同，可能会遇到在某位置一棵树的节点为空，一棵树的结点不为空的情况。此时就要根据题目要求处理，例如：

- 在对称二叉树问题中，要同时遍历左右两棵子树。若遇到一个为空，一个不为空的情况，说明不是对称的，返回false。
- 在合并二叉树问题中，要同时遍历两棵树。若一个为空，一个不为空，就返回不为空的那个节点作为合并的结果，将它插入到新的树中。



###  [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914214110999-2025-9-1421:41:11.png" style="zoom:80%;" />

思路：判断二叉树是否对称，要比较的是根节点的左子树与右子树是不是可以**相互翻转**的。对于是否是可以相互翻转的，需要比较的是**两个子树的里侧和外侧的元素是否相等**。在这个问题中其实要比较的是两棵树（这两棵树是根结点的左右子树），在递归遍历过程中需要同时遍历这两棵树。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914223242109-2025-9-1422:32:51.png" style="zoom:80%;" />



因为要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等，所以只能用**后序遍历**。

{% note primary %}

像这种需要根据左右子树的处理结果来判断根节点情况的时候，只能采用**后序遍历**。先处理左右子树再处理根节点，收集左右子树的信息向上一层返回进行处理。

{% endnote %}

递归三部曲：

1. 确定递归函数的参数和返回值

   因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

   返回值是bool类型。

   ```java
   bool compare(TreeNode left, TreeNode right)
   ```

2. 确定返回条件

   首先要排除两个结点可能为空的情况，防止比较结点的值时，出现空指针异常。

   具体情况如下：

   - 左右结点都为空，对称，返回true

   - 左节点为空，右节点不为空，不对称，返回false
   - 左节点不为空，有节点为空，不对称，返回false
   - 左右节点都不为空，但值不相等，不对称，返回false

   最后，当左右节点都不为空且值相等时，需要递归判断以这两个结点为根的子树是否能相互翻转

   ```java
   if (left == null && right == null) return true;
   else if (left != null && right == null) return false;
   else if (left == null && right != null) return false;
   else if (left.val != right.val) return false;
   
   //等价的判断逻辑
   //左节点为空，右节点为空，说明是对称的
   if(left == null && right == null) return true;
   //左右一个节点不为空，或者都不为空但数值不同，返回false
   if (left == null || right == null || left.val != right.val) return false;
   ```

3. 单层处理逻辑

   此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

   - 判断二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子
   - 判断二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子
   - 如果内侧和外侧都对称，则返回true，否则返回false

```java
public boolean isSymmetric(TreeNode root) {
    if (root.left == null && root.right == null) 
        return true;
    return compare(root.left, root.right);
}

//判断左右子树是否可以翻转
public boolean compare(TreeNode left, TreeNode right) {
    if(left == null && right == null) return true;
    if (left == null || right == null || left.val != right.val) return false;
 	//后序遍历，先收集左右孩子的信息，再向上返回进行处理
    boolean outside = compare(left.left, right.right);
    boolean inside = compare(left.right, right.left);
    return outside && inside;
}
```

***

迭代法

思路：**同时遍历左右子树，把要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较**。

比如，使用队列进行处理，首先将根节点的左右孩子依次入队，再成对取出判断，若两节点都不为空且值相等时，再将左节点的左孩子和右节点的右孩子、左节点的右孩子和右节点的左孩子依次入队，下次循环时再次成对取出判断，以此类推。

![](https://gitee.com/cmyk359/img/raw/master/img/101.对称二叉树-2025-9-1422:54:24.gif)

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
	
    //注意：此处的队列实现不能用ArrayDeque，它不能存储null值，而左右孩子可能为null
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root.left);
    queue.offer(root.right);

    while (!queue.isEmpty()) {
        TreeNode leftNode = queue.poll();
        TreeNode rightNode = queue.poll();
        if (leftNode == null && rightNode == null) 
            continue;
        if (leftNode == null || rightNode == null || leftNode.val != rightNode.val)
            return false;
        //外侧节点成对入队
        queue.offer(leftNode.left);
        queue.offer(rightNode.right);
        //内侧节点成对入队
        queue.offer(leftNode.right);
        queue.offer(rightNode.left);
    }
    return true;
}
```

此外也可以使用层序遍历，再判断每层是否是回文（需要将null保存起来）

### [相同的树](https://leetcode.cn/problems/same-tree/) 

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091142047-2025-9-1509:11:51.png" style="zoom:80%;" />

判断s和t两个树是否**相等**的三个条件是**与**的关系，即：

1. s和t的根节点值相等；
2. 并且，s 的左子树和 t 的左子树相等；
3. 并且，s 的右子树和 t 的右子树相等。

思路：与上题思路完全相同，采用后序遍历方式，判断相同位置的节点是否都相同，返回结果

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null || p.val != q.val) return false;
	
    //比较两棵树的左孩子是否相同
    boolean left = isSameTree(p.left, q.left);
    //比较两棵树的右孩子是否相同
    boolean right = isSameTree(p.right, q.right);
    return left && right;
}
```

### [另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091256687-2025-9-1509:12:57.png" style="zoom:80%;" />

判断 t 是否为 s 的**子树**的三个条件是**或**的关系，即：

1. 当前两棵树相等；
2. 或者，t 是 s 的左子树；
3. 或者，t 是 s 的右子树。

本题采用先序遍历的方式，递归三部曲：

1. 确定参数和返回值

   要比较的是两棵树，因此参数是两棵树的根节点；返回值为布尔类型。

   ```java
   boolean isSubtree(TreeNode root, TreeNode subRoot)
   ```

2. 确定终止条件

   如果给定的两棵树都是空树，也算作一棵是另一棵的子树，返回true；

   如果一棵为空，另一棵不为空，则不是子树，返回false

   ```java
   if (root == null && subRoot == null) return true;
   if (root == null || subRoot == null) return false;
   ```

3. 确定单层递归的逻辑 

   首先检查当前树`root`是否与 `subRoot` 相同；如果当前树不匹配，则递归检查 `root` 的左子树是否包含 `subRoot`；如果左子树也不包含，则递归检查 `root` 的右子树是否包含 `subRoot`。

   最终若满足一条，则`subRoot`是`root`的子树。

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        return isSameTree(root, subRoot) //判断两棵树是否相等
            	|| isSubtree(root.left, subRoot) //递归判断左子树是否包含
            	|| isSubtree(root.right, subRoot); //递归判断右子树是否包含
    }
	
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null || p.val != q.val) return false;
        return isSameTree(p.left, q.left) 
            	&& isSameTree(p.right, q.right);
    }
}
```



### [合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915095258189-2025-9-1509:53:07.png" style="zoom:80%;" />

思路：采用**先序遍历**方式同时遍历两颗树，当遍历到的两个节点：

- 一个为空一个不为空时，它们合并的结果就是不为空的节点
- 两个都为空时，合并的结果就是空节点
- 两个都不为空时，新节点的值为这两个节点之和

可以重复利用root1这棵树，将root2合并到root1；也可以不改变原来树的结构，在合并过程中创建新节点记录合并结果。

也可以采用**迭代方式**，参考之前对称二叉树的迭代法，将要合并的两个节点成对地存入栈或队列中，在下次迭代中再成对地取出进行合并。

***

递归三部曲：

1. 确定参数和返回值

   参数就是要合并的两棵树的根节点，最终返回合并后新树的根节点，返回类型是`TreeNode`

   ```java
   TreeNode mergeTrees(TreeNode root1, TreeNode root2)
   ```

2. 确定终止条件

   当遍历到的两个节点一个为空，另一个不为空时，返回不为空的节点作为合并结果

   ```java
   //其中包含了两个都为null时返回null的情况
   if (root1 == null) return roo2;
   if (root2 == null) return root1;
   ```

3. 确定单层的处理逻辑

   合并两个不为空的节点，再递归的合并左子树和右子树，最终返回当前的根节点。

   ```java
   //创建一棵新的树而不改变给定树的结构
   TreeNode root = new TreeNode(root1.val + root2.val); 
   root.left = mergeTrees(root1.left, root2.left); //合并左子树，将合并结果插入到原来位置
   root.right = mergeTrees(root1.right, root2.right);//合并右子树，将合并结果插入到原来位置
   return root;
   
   //或者，重复利用root1
   root1.val += root2.val; //中
   root1.left = mergeTrees(root1.left, root2.left); //左
   root2.left = mergeTrees(root1.right, root2.left); //右
   return root1;
   ```

   

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) return root2;
    if (root2 == null) return root1; //其中包含了两个都为null时返回null的情况

    //创建一棵新的树而不改变给定树的结构
    TreeNode root = new TreeNode(root1.val + root2.val); 
    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);

    return root;
}
```

## [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

题目描述：给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

对于普通的二叉树可以利用各种遍历方法，在遍历的过程中统计结点数量即可。对于完全二叉树，有其自己的特性，不必通过遍历全部的结点来得到总结点数。

完全二叉树只有两种情况：一是满二叉树，二是最后一层叶子结点没有满

对于情况一：利用公式： $2^{树的深度} -1$计算，此时根节点深度为1

对于情况二，分别递归左孩子和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920111734067-2025-9-2011:17:43.png" style="zoom:80%;" />

那么在**完全二叉树中**如何判断子树是满二叉树：只需记录从根节点开始一直沿左孩子到叶子结点的深度 $leftDepth$ 和从根节点开始一直沿右孩子到叶子结点的深度 $rightDepth$。

- 若 $leftDepth == rightDepth$，则是满二叉树，利用公式得出此子树的结点数 $2^{leftDepth} - 1$，如此**只需遍历两侧的结点即可得到该子树的总结点数，而不用遍历无用的内侧节点。**
- 否则，继续递归判断以左右孩子为根的子树是否是满二叉树，得到左右子树的结点数再加1即是当前子树的总结点数。

由于要先计算左右子树的节点数，最后得到当前树的总节点数，故采用后序遍历。

***

递归三部曲：

1. 确定递归函数的参数和返回值

   传入的参数是当前树的根节点，最终返回树中的节点总数

   ```java
   int countNodes(TreeNode root)
   ```

2. 确定终止条件

   若根节点为null，则为空树，总节点数为 0

   若当前树是满二叉树，则总节点数为$2^{树的深度} -1$

3. 单层递归逻辑

   若当前子树不是满二叉树，则继续判断左右孩子的子树情况，总结点数为左右子树的结点之和再加一

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
	//判断当前子树是否为满二叉树，若是则返回子树的总节点数
    TreeNode leftChild = root.left;
    TreeNode rightChild = root.right;
    int leftDepth = 0, rightDepth = 0;
    while (leftChild != null) {
        leftDepth++;
        leftChild = leftChild.left;
    }
    while (rightChild != null) {
        rightDepth++;
        rightChild = rightChild.right;
    }

    if (leftDepth == rightDepth)
        return (2 << leftDepth) - 1;
	
    // 当前不是满二叉树，则递归处理统计左右子树的节点数，总结点数为左右子树的结点之和再加一
    int leftNums = countNodes(root.left);
    int rightNums = countNodes(root.right);
    return leftNums + rightNums + 1;
}
```

## [二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920182241500-2025-9-2018:22:43.png" style="zoom:80%;" />

本题要求从根节点到叶子的路径，所以要用**前序遍历**，这样才方便从父节点指向孩子节点，找到对应的路径。

此外，由于要找全部路径所以涉及到回溯。当从一个节点进入它的左子树收集完路径后，要回溯到当前节点，再转向收集右子树中的路径，这样才能收集到全部路径。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920211136576-2025-9-2021:11:42.png" style="zoom:80%;" />

在传统回溯中，path为记录路径的可变列表，每处理完一个节点就从path中收集删除记录进行回溯。

也可以在每个递归调用中创建新的字符串路径path来避免显式回溯。具体来说，在每次递归调用时，使用`StringBuilder`来构建新path的字符串，然后将这个新字符串传递给下一层递归，左右子树的递归调用接收的是这个新创建的路径副本。当递归返回时，当前层的`path`变量保持不变，不需要撤销操作。（**通过值传递的方式避免显式回溯**）这种方式下每次递归调用都创建新的字符串对象，字符串拼接操作可能较慢，特别是对于深度较大的树

递归三部曲：

1. 确定递归函数的参数和返回值

   需要传入根节点、路径记录path和收集结果的res，不需要返回值。

   采用传统回溯时，path为可变列表；采用值传递方式时，path为字符串

   ```java
   void getPath(TreeNode root, List<Integer> path, List<String> res) //传统回溯
   void getPath(TreeNode root, List<String> res, String path) //值传递方式
   ```

2. 确定终止条件

   当传入的节点为空时，是棵空树，直接返回。

   当传入的节点是叶子节点时，收集路径。

3. 确定单层递归逻辑

   采用先序遍历，将当前根节点加入到path中，再递归地处理左子树和右子树。

```java
//值传递方式避免显式回溯
public void getPath(TreeNode root, List<String> res, String path) {
    if (root == null) return;
    if (root.left == null && root.right == null) {
        res.add(new StringBuilder(path).append(root.val).toString());
    }

    path = new StringBuilder(path).append(root.val).append("->").toString();
    getPath(root.left, res, path);
    getPath(root.right, res, path);
}
public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    if (root == null) return res;
    getPath(root, res, "");
    return res;

}
```



```java
//传统回溯方式
public void getPath(TreeNode root, List<Integer> path, List<String> res) {

    path.add(root.val); //中，放在终止条件之前，确保叶子结点能加入到路径中

    if (root.left == null && root.right == null) { //终止条件,遇到叶子结点
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < path.size() - 1; i++) {
            sb.append(path.get(i)+"->");
        }
        sb.append(path.get(path.size() - 1)); //记录最后一个结点
        res.add(sb.toString()); //收集该条路径
        return;
    }

    if (root.left != null) {
        getPath(root.left, path, res);
        //回溯
        path.remove(path.size() - 1);
    }
    if (root.right != null) {
        getPath(root.right, path, res);
        //回溯
        path.remove(path.size() - 1);
    }
}

public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    getPath(root,path, res);
    return res;
}
```



## [验证平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

题目描述：给定一个二叉树，判断它是否是 平衡二叉树（AVL树）。

思路：对于给定的二叉树，若它的左子树是平衡二叉树，右子树也是平衡二叉树，且左右子树的高度差不超过1，则这棵树是平衡二叉树，有一个条件不成立，则不是AVL树。

采用**后序遍历**方式，先得到左右子树的高度，再判断是否满足平衡二叉数的定义。若是平衡二叉树，则返回当前树的高度，否则返回-1，表示不是平衡二叉树。

递归三部曲：

1. 确定递归函数的参数和返回值

   参数是树的根节点，返回值是该树的高度，若不是平衡二叉树返回-1.

   ```java
   // -1表示该树已经不是平衡二叉树了，否则返回值是以该节点为根节点的树的高度
   int getHeight(TreeNode root)
   ```

2. 确定终止条件

   当传入的节点指针为空时，说明是棵空树，返回高度0

3. 确定单层处理逻辑

   采用后序遍历方式，计算当前节点左子树和右子树的高度。

   若左子树或右子树不是平衡二叉树，直接返回-1。

   若左右子树都是AVL树，再判断二者高度相差是否超过1。若是，则返回-1；否则，返回当前树的高度：左右子树高度的最大值+1.

```java
public boolean isBalanced(TreeNode root) {
    if (getHeight(root) == -1)
        return false;
    return true;
}

public int getHeight(TreeNode root) {
    if (root == null) return 0;
    int leftHeight = getHeight(root.left);
    if (leftHeight == -1) return -1; //左子树不是AVL树

    int rightHeight = getHeight(root.right);
    if (rightHeight == -1) return -1; //右子树不是AVL树

    if (Math.abs(leftHeight - rightHeight) > 1)
        return -1; //左右子树不平衡
    //当时树是AVL树，返回高度
    return Math.max(leftHeight, rightHeight) + 1; 
}
```

***

进阶：[第 K 大的完美二叉子树的大小](https://leetcode.cn/problems/k-th-largest-perfect-subtree-size-in-binary-tree/)

## [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

题目描述：给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树（BST树）。

思路：BST树一个重要的性质是它**中序遍历的结果是递增的**。在遍历过程中检查，上一个遍历到的结点的值 与当前结点的值是否逆序，若逆序则不是二叉搜索树。

递归三部曲：

- 确定递归函数的参数及返回值

  需要定义一个**全局变量**`preVal`记录中序序列中当前节点的前一个节点的值。由于题目中节点的值可以取到int类型的最小值，所以`preVal`应该取更小的值以保证第一次比较的正确，此处取long的最小值。

  递归函数传入的参数是根节点，返回值为布尔类型

  ```java
  private long preValue = Long.MIN_VALUE; 
  public boolean isValidBST(TreeNode root){}
  ```

- 确定终止条件

  当传入的根节点为空时，说明为空树，空树也是BST树，返回true。

- 确定单层处理逻辑

  采用中序遍历，比较中序序列中前驱节点的值与当前节点值的大小，若前者更大，则不是BST树；否则，更新`preVal`为当前节点的值。

  若左子树和右子树中的节点都遵循这种关系，则整棵树是二叉排序树。

```java
private long preValue = Long.MIN_VALUE; 
public boolean isValidBST(TreeNode root) {
    if (root == null) return true;

    boolean isLeft = isValidBST(root.left);
	
    //也可以在这先判断左子树是否是BST树，若不是则直接返回。函数最终只需要返回右子树的判断结果即可
    //判断节点关系
    if (root.val <= preValue) 
        return false;
    preValue = root.val;

    boolean isRight = isValidBST(root.right);
	
    return isLeft && isRight;
}
```

***

使用迭代法，修改<u>非递归</u>中序遍历：使用一个变量preValue记录上一个遍历结点的值。将出栈结点的值和preValue比较，若不是升序，则返回false；否则修改preValue的值为当前出栈结点的值。

```java
public boolean isValidBST(TreeNode root) {
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode p = root;
    long preValue = Long.MIN_VALUE;
    while (p != null || !stack.empty()) {
        if (p != null) {
            stack.push(p);
            p = p.left;
        } else {
            p = stack.pop();
            if(preValue >= p.val)
                return false;
            else
                preValue = p.val;
            p = p.right;
        }
    }
    return true;
}
```



##  [验证完全二叉树](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

题目描述：给你一棵二叉树的根节点 `root` ，请你判断这棵树是否是一棵 **完全二叉树** 。

完全二叉树的重要性质：

- 最多存在一个度为1 的结点，且该结点只有左孩子而无右孩子
- 只有最后两层可能有叶结点

思路：在**层序遍历**过程中，若碰到一个结点有右无左，则不是完全二叉树。在遇到第一个不双全结点或叶结点后，之后的结点必须是叶结点，否则不是完全二叉树（两个否定条件）。使用一个布尔变量标记是否遇到不双全结点或叶结点。

```java
public boolean isCompleteTree(TreeNode root) {
    if (root == null ) return true;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean isLeaf = false; //判断是否遇到不双全节点

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        //如果有一个结点有右孩子而无左孩子，则不是完全二叉树
        if (node.left == null && node.right != null) 
            return false;
        //如果已经遇到过不双全结点，且其后不全是是叶子节点，则不是完全二叉树
        if (isLeaf && !(node.left == null && node.right == null))
            return false;
        //遇到不双全结点    
        if (node.left == null || node.right == null) 
            isLeaf = true;

        //左右孩子入队
        if (node.left != null)
            queue.offer(node.left);
        if (node.right != null)
            queue.offer(node.right);
    }
    return true;
}
```



***

进阶：[水壶问题](https://leetcode.cn/problems/water-and-jug-problem/)