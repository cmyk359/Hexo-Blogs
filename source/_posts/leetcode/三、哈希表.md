---
title: 三、哈希表
categories:
  - leetcode
abbrlink: 4f3efbd5
math: true
date: 2025-07-15 10:34:44
tags:
---

<meta name = "referrer", content = "no-referrer"/>

1、什么时候考虑使用哈希表？

- 需要频繁检查某个元素是否在数据集中出现过，或者需要确保元素唯一性。
- 根据元素特征进行分类
- 需要统计元素（数字、字符、字符串、对象等）出现的次数。
- 需要存储元素与其位置（下标、路径、状态等）的映射关系，以便后续快速访问。
- 需要求交集、并集、差集，或者判断子集关系。
- 需要建立两组对象之间的对应关系，或者需要存储子问题的结果以避免重复计算（动态规划、递归优化）

***

2、哪些数据结构可以做哈希表？

- 数组
- set集合
- map集合

{% note info%}

当值的范围较小时使用数组，直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

当没有规定值的范围时，应该采用HashSet，如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。在此基础上既要保存值又要保存其出现的位置、次数等时，应使用HashMap。

{% endnote%}

## [有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240806111930840-2024-8-611:19:34.png" style="zoom:80%;" />

> `s` 和 `t` 仅包含小写字母

思路：字符串中都是小写字母 a ~ z，用数组当哈希表，a对应数组下标0，b对应数组下标1，以此类推。先遍历第一个字符串，对每个字符在哈希表中的值+1，再遍历第二个字符串，对每个字符在哈希表中的值-1；最后若哈希表中元素全为0，则为有效的字母异位词。

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false; //长度不同，一定不是
    int tags[] = new int[26]; //数组元素默认初始化为0
    char[] chars_s = s.toCharArray();
    char[] chars_t = t.toCharArray();

    for (int i = 0; i < chars_s.length; i++) {
        tags[chars_s[i] - 'a'] ++;
    }
    for (int i = 0; i < chars_t.length; i++) {
        tags[chars_t[i] - 'a'] --;
    }

    for (int i = 0; i < tags.length; i++) {
        if (tags[i] != 0) return false;
    }
    return true;
}
```

## [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250715121347398-2025-7-1512:14:06.png" style="zoom:80%;" />

思路：每组的异位词都有共同点：每组中的字符串只是字母顺序不同，但对应的字母个数相同，在遍历字符串数组的时候就可以根据这个共同点进行分类。**一旦需要根据特征分类，就需要考虑散列表**。**以共同特征为键，以具有共同特征的元素集合为值。**

- 对于同组的字符串，若对字母进行排序后，会得到相同的结果。故散列表的键可以选为排序后的字符串。

  ```java
  public List<List<String>> groupAnagrams(String[] strs) {
      Map<String, List<String>> map = new HashMap<>();
      for (String str : strs) {
          char[] chars = str.toCharArray();
          Arrays.sort(chars);
          String key = new String(chars);
          List<String> list = map.getOrDefault(key, new ArrayList<String>());
          list.add(str);
          map.put(key, list);
      }
      return new ArrayList<List<String>>(map.values());
  }
  ```

  

- 同组中的每个字符串所含对应的字母个数相同，统计每个字符串中各个字母的个数并组成字符串，作为哈希表的键。如"eat"对应的键为"100010...010...0"

  ```java
  class Solution {
      public List<List<String>> groupAnagrams(String[] strs) {
          Map<String, List<String>> map = new HashMap<String, List<String>>();
          for (String str: strs) {
              int[] count = new int[26];
              char[] chars = str.toCharArray();
              //统计字母个数
              for (char c : chars) 
                  count[c -'a']++;
              //构造key
              StringBuilder sb = new StringBuilder();
              for (int num : count) {
                  sb.append((char)num);
                  sb.append("#");      
              }  
              String key = sb.toString();
              List<String> list = map.getOrDefault(key,new ArrayList<String>());
              list.add(str);
              map.put(key,list);
          }
          return new ArrayList<List<String>>(map.values());
      }
  }
  ```

  

## [两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 它们的 <u>交集</u>。输出结果中的每个元素一定是 **唯一** 的。我们可以不考虑输出结果的顺序 。

思路：

- 由于交集中每个元素是唯一的，故需要使用哈希表保存结果，并进行**去重**。先将数组一的值都放到哈希表中，再遍历数组二的每个元素，判断是否在哈希表中存在，若存在则放入结果（不重复放入）。
- 由于题中规定了元素值的范围为1000以内，可以使用数组来充当哈希表。

```java
===========================使用数组==========================
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] hash1 = new int[1002];
        int[] hash2 = new int[1002];
        for(int i : nums1)
            hash1[i]++;
        for(int i : nums2)
            hash2[i]++;
        List<Integer> resList = new ArrayList<>();
        for(int i = 0; i < 1002; i++)
            if(hash1[i] > 0 && hash2[i] > 0)
                resList.add(i);
        return resList.stream().mapToInt(x->x).toArray();
    }
}
========================使用HashSet==============================
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set1 = new HashSet<>();
        HashSet<Integer> resultSet = new HashSet<>();

        for (int i : nums1) 
            set1.add(i);
        
        for (int j : nums2) 
            if (set1.contains(j)) 
                resultSet.add(j);
        
        return resultSet.stream().mapToInt(x -> x).toArray();
    }
}
```

## [快乐数](https://leetcode.cn/problems/happy-number/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727092355124-2025-7-2709:23:56.png" style="zoom:80%;" />

**关键：找出过程中重复的数字，避免进入循环。**

- 方法一：集合法

  初始化HashSet，将n放入集合中，将当前数字每个位置的平方和加入集合。重复求各个位置平方和以及加入集合的操作，直至出现1时，返回true；或者，新数字已经在集合中存在时，返回false

  复杂度分析：假设从 n 到 1 或无限循环重复的第一个数一共需要经过 x 步变换，则时间复杂度为$O(x)$，空间复杂度为：$O(x)$，<u>其所需空间可能大到无法存储</u>。

  ```java
  //递归
  private Set<Integer> flag = new HashSet<>();
  
  public boolean isHappy(int n) {
      if (n == 1)
          return true;
      if (flag.contains(n))
          return false;
      flag.add(n);
      int part = 0, nextNum = 0;
      while (n != 0) {
          part = n % 10;
          n = n / 10;
          nextNum += part * part;
      }
      return isHappy(nextNum);
  }
  
  //迭代
  public boolean isHappy(int n) {
      Set<Integer> flags = new HashSet<>();
      while (n != 1) {
          flags.add(n);
          int part = 0, nextN = 0;
          while (n != 0) {
              part = n % 10;
              nextN += part * part;
              n = n / 10;
          }
          n = nextN;
          if (flags.contains(n)) 
              return false; //进入无限循环
      }
      return true;
  }
  ```

  

方法二：双指针法

把转换过程中的每一个数看作单链表的一个节点，将1看作单链表的最后一个元素，如果无法从n转换为 1，说明单链表中存在环。

使用**快慢指针**slow和fast进行有无环的判断。当slow不等于fast时，**slow每次转化一次，fast每次转化两次**；当slow等于fast时，若slow为1，则是快乐数，否则不是。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716104724873-2025-7-1610:47:30.png" style="zoom:80%;" />

复杂度分析：假设从 n 到 1 或无限循环重复的第一个数一共需要经过 x 步变换，则时间复杂度为$O(x)$，空间复杂度为：$O(1)$。

```java
public boolean isHappy(int n) {
    int slow = n, fast = n;
    do {
        slow = convert(slow);
        fast = convert(convert(fast));
    }while(slow != fast);

    return slow == 1;
}

public int convert(int n) {
    int part = 0, nextN = 0;
    while (n != 0) {
        part = n % 10;
        nextN += part * part;
        n = n / 10;
    }
    return nextN;
}
```

## [两数之和](https://leetcode.cn/problems/two-sum/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716105421644-2025-7-1610:55:04.png" style="zoom:80%;" />

思路：遍历数组，<u>记录已经遍历过的元素</u>，同时判断当前元素的剩余部分是否存在（是否已经遍历过），若存在，则返回这两数的下标。由于要查找当前元素是否存在，且同时可以得到所在下标，故使用**HashMap**作为哈希表，<u>元素值作为key，下标作为value</u>。

> 补充：由于是在已遍历过的元素中查找另一半，若当前元素的另一半存在且未遍历到，那么当之后遍历到另一半时，仍会找到这一组有效的组合。如target是6，nums中有2和4，且4在2后，当遍历到2时，已遍历到的元素中没有4，先不返回结果。当遍历到4时就会在已遍历元素中找到2，此时再返回。

```java
public int[] twoSum(int[] nums, int target) {
    int res[]  = new int[2];
    Map<Integer,Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int part = target - nums[i];
        //在已遍历到的集合中查找另一半
        if ( map.containsKey(part)) {
            res[0] = i;
            res[1] = map.get(part);
            break;
        }
        map.put(nums[i],i);
    }
    return res;
}
```

## [四数相加 II](https://leetcode.cn/problems/4sum-ii/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716111718395-2025-7-1611:17:22.png" style="zoom:80%;" />

思路：

- 暴力解法就是同时处理四个数组，使用四个for循环，时间复杂度太高。

- 换一种思路：对应第一个数组中每个元素x，判断是否能在剩余三个数组中各取一个元素找到之和为 -x的组合，这个组合出现了多少次，若-x的组合出现了 n次，则已经找了n个满足条件的元组。一次统计三个数组中是否有和为-x的组合，需要使用三个for循环，时间复杂度为$O(n^3)$。

  由于既要保存值，值的大小未知，且还要保存这个值出现的次数，故使用HashMap作为哈希表。

- 再进一步优化，**可以将四个数组两两分为一组，先将前两个数组中各元素的和以及出现的次数用HashMap保存起来，再计算后两个数组元素的和（若为x），则在哈希表中查找是否有值为-x的组合**，若存在则最终符合的元组数+=-x出现的次数。

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer, Integer> map = new HashMap<>();
    int sum, sum_c;
    //统计nums1和nums2中各元素的和及其出现次数
    for (int i : nums1) {
        for (int j : nums2) {
            sum = i + j;
            sum_c = map.getOrDefault(sum, 0);
            map.put(sum, sum_c + 1);
            //map.put(i + j, map.getOrDefault(i + j, 0) + 1)
        }
    }

    int count = 0; //记录最终满足条件的元组个数
    for (int i : nums3) {
        for (int j : nums4) {
            count += map.getOrDefault(0-i-j, 0);
        }
    }

    return count;
} 
```

## [三数之和](https://leetcode.cn/problems/3sum/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727103531203-2025-7-2710:35:36.png" style="zoom:80%;" />

题目要求结果中不能包含重复的三元组，关键是**去重**。

思路：

1、哈希法。先使用两层for循环记录数组中两个元素a+b的值，再使用哈希法确定0-(a+b)是否在数组中出现过。但是这种方法会产生重复的三元组，根据题目要求，需要进行去重。

去重逻辑：

- 第一个数的去重，由于数组已排序，相同数字相邻，当当前数与前一数相同时，跳过当前循环
- 使用set作为哈希表，并存储已遍历的第二个数，自动过滤重复值，对第二个数去重
- 第三个数由`complement = -nums[i] - nums[j]`计算得出，由前两个数唯一确定

```java
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // 关键：排序是去重的基础
        int n = nums.length;
        
        for (int i = 0; i < n - 2; i++) {
            // 第一个数去重：跳过重复值
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            Set<Integer> seen = new HashSet<>(); // 哈希表：存储第二个数
            
            for (int j = i + 1; j < n; j++) {
                int complement = -nums[i] - nums[j]; // 计算第三个数
                
                // 检查第三个数是否在哈希表中
                if (seen.contains(complement)) {
                    result.add(Arrays.asList(nums[i], complement, nums[j]));
                }
                seen.add(nums[j]); // 将当前数加入哈希表
            }
        }
        return result;
    }
```



***

2、双指针法。首先对数组排序，然后有一层for循环，i从下标0的地方开始，同时将一个下标left定义在i+1的位置上，将下标right定义在数组结尾的位置上。

还是在数组中找到三个数a、b、c，使得a+b+c=0，这里相当于a=nums[i]、b=nums[left]、c=nums[right]。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727104003050-2025-7-2710:40:04.png" style="zoom:80%;" />

如何移动left和right呢？

- 如果nums[i] + nums[left] + nums[right] > 0 ，说明 此时三数之和大了，因为数组排过序了，所以right下标就应该向左移动，这样才能让三数之和小一些。
- 如果 nums[i] + nums[left] + nums[right] < 0 ，说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些。
- 如果 nums[i] + nums[left] + nums[right]  = 0 ，说明找到了一个符合条件的三元组，**将其加入结果集并对b 和 c进行去重。**
- 直到left与right相遇为止。

去重逻辑分析

- 对第一个数字a的去重，判断逻辑为`i > 0 && nums[i] == nums[i - 1]`，若它与前一个元素相同则跳过。由于组成元组的值可以重复（只要他们是不同的数组元素），若将判断逻辑改为`nums[i] == nums[i+1]` ，因为left就等于i+1，此时相当于判断元组中是否由值相等的元素，有就跳过，这会漏掉符合条件的元组，如(-1, -1, 2)

- 对于第二、三个数字b和c的去重。当收集了一个元组后，需要**持续移动**left和right跳过相同的数字防止重复。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729103216117-2025-7-2910:32:27.png" style="zoom:80%;" />

  ```java
  //判断条件中要有 left < right，防止在某些情况下（如：-2，1，1，1，1），left直接移动到末尾或right移动到首部
  while (left < right && nums[left] == nums[left + 1])
      left++; //left去重,跳过右侧相同的元素
  
  while (left < right && nums[right] == nums[right - 1])
      right--; //right去重，跳过左侧相同的元素
  ```

完整代码：

```python
public static List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums); //升序排序
    List<List<Integer>> result = new ArrayList<>();
    
    int left, right;
    //判断 i、left、right三个位置相加是否为0
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) break; //数组值递增
        if (i > 0 && nums[i] == nums[i - 1]) continue; //i位置去重
        left = i + 1;
        right = nums.length - 1;
        //left不断向右移动，right不断向左移动
        while (left < right) {
            int sum =  nums[i] + nums[left] + nums[right];
            if (sum < 0) left++; // 和太小，将left右移
            else if (sum > 0) right--; //和太大，将right左移
            else { // 和为0，收集结果
                  result.add(Arrays.asList(nums[i],nums[left],nums[right]));

                  // 对b 和 c的重逻辑应该放在找到一个三元组之后
                  while (left < right && nums[left] == nums[left + 1])
                  left++; //left去重,跳过右侧相同的元素
                  while (left < right && nums[right] == nums[right - 1])
                  right--; //right去重，跳过左侧相同的元素

                  left++;
                  right--;
                 }
        }
    }
    return result;
}
```



## [四数之和](https://leetcode.cn/problems/4sum/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729110716530-2025-7-2911:07:18.png" style="zoom:80%;" />

四数之和，和三数之和是一个思路，都是使用双指针法, 基本解法就是在三数之和的基础上**再套一层for循环**。

与三数之和不同，target并不固定为0，而是输入的指定值。进行剪枝时，策略有所变化：

- 对i进行剪枝时，只满足 nums[i] > target 并不能pass掉这个元组，若nums[i] < 0 ,可能与后面某些数相加会变小，也可能变为target。需要同时满足`nums[i] > 0` 和 `nums[i] > targe`才可以排除这个数字。
- 对j进行剪枝时，要用`nums[i]+nums[j]`作为一个整体来和target比较，与i的剪枝策略相同，需要满足`nums[i] + nums[j] > 0 && nums[i] + nums[j] > target`

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729111742354-2025-7-2911:17:54.png" style="zoom:80%;" />

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        //i的剪枝
        if (nums[i] > 0 && nums[i] > target) break;
        //i的去重
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        for (int j = i + 1; j < nums.length; j++) {
            //内部循环与三数之和逻辑基本相同
            //j的剪枝
            if (nums[i] + nums[j] > 0 && nums[i] + nums[j] > target) break;
            //j的去重
            if (j > i + 1 && nums[j] == nums[j - 1]) continue;
            //双指针移动寻找符合条件的四元组
            int left = j + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];
                if (sum > target) right --;
                else if (sum < target) left ++;
                else {
                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                    //left和right的去重
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                }
            }
        }
    }
    return result;
}
```

