---
title: 四、字符串
math: true
categories:
  - leetcode
abbrlink: 36b020a8
date: 2025-07-18 10:17:59
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## [反转字符串](https://leetcode.cn/problems/reverse-string/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901152940156-2025-9-115:29:43.png" style="zoom:80%;" />

思路：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。

{% note info%}

使用**异或**运算交换a和b的元素值：

1. a ^= b;  // 此时a = a ^ b
2. b ^= a; // 等价于b= a ^ b ^ b = a ^ 0 = a,此时 b = a, a = a ^ b
3. a ^= b; //等价于 a = a ^ b ^ a = b, 此时 a = b, b = a完成交换。

{% endnote%}

```java
class Solution {
    public void reverseString(char[] s) {
        int l = 0;
        int r = s.length - 1;
        while (l < r) {
            s[l] ^= s[r];  //构造 a ^ b 的结果，并放在 a 中
            s[r] ^= s[l];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
            s[l] ^= s[r];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
            l++;
            r--;
        }
    }
}

// 第二种方法用temp来交换数值更多人容易理解些
class Solution {
    public void reverseString(char[] s) {
        int l = 0;
        int r = s.length - 1;
        while(l < r){
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l++;
            r--;
        }
    }
}
```

## [反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901154333985-2025-9-115:43:34.png" style="zoom:80%;" />

思路：在for循环遍历字符串的过程中，让i 每次移动 2 * k ，即 i += (2 * k)；每次i的位置就是待翻转区间的左端，然后再找到右端，翻转该区间内的字符即可。

> **所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。**

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] str = s.toCharArray();

        for(int i = 0; i < str.length; i += 2*k){
            int left = i;
            int right = Math.min(str.length - 1, left + k - 1);
            reverse(str,left, right);
        }
        return new String(str);
    }

    //反转指定范围内的字符
    public void reverse(char[] s, int l, int r) {
        while (l < r) {
            s[l] ^= s[r]; 
            s[r] ^= s[l]; 
            s[l] ^= s[r]; 
            l++;
            r--;
        }
    }
}
```



## [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240809183021689-2024-8-918:30:27.png" style="zoom:80%;" />

思路一：首先去除首尾以及中间多余的空格，然后整体翻转，再将每个单词翻转。**使用整体反转+局部反转就可以实现反转单词顺序的目的。**

```java
class Solution {
    public char[] removeExtraSpace(char[] s){
        int i = 0, j = 0;
        //双指针删除字符数组中的空白字符
        while (j < s.length) {
            if (s[j] != ' ') { //遇到非空格字符则加入
                s[i++] = s[j++];
                continue;
            }
            while(j < s.length && s[j] == ' ') j++; //遇到单词间的空格字符则跳过
            s[i++] = ' ';//手动添加一个分隔单词的空格
        }
        return Arrays.copyOfRange(s, 0, i);
    }

    public void reverseString(char[] s, int start, int end){
        while(start < end) {
            s[start] ^= s[end];
            s[end]  ^= s[start];
            s[start] ^= s[end];
            start++;
            end--;
        }
    }
    public void reverseEachWord(char[] s) {
        int start = 0;
        for (int i = 0; i < s.length; i++) {
            if (s[i] != ' ') continue;
            reverseString(s, start, i - 1);
            start = i + 1;
        }
        //翻转最后一个单词
        reverseString(s, start, s.length - 1);
    }

    
    public String reverseWords(String s) {
        //1、去除多余空格
        char[] nc = removeExtraSpace(s.trim().toCharArray()); //s.trim()删除首尾多余空格
        //2、整体翻转
        reverseString(nc, 0, nc.length - 1);
        //3、翻转每个单词
        reverseEachWord(nc);
        
        return new String(nc);
    }
}
```



思路二：直接将源字符串中的单词放到翻转后的位置。申请一个新字符数组存放结果，在原字符串中从后往前遍历，确定每一个单词的范围，从该范围内取出单词添加到新数组中，并且手动添加一个空格，最终结果末尾多加了一个空格。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240809184945736-2024-8-918:50:10.png" style="zoom:80%;" />

```java
class Solution {
    public String reverseWords(String s) {
        //原字符数组 original chars
        char[] oc = s.toCharArray();
        //新字符数组 new chars
        char[] nc = new char[oc.length + 1];//最终末尾会多一个空白字符
        int i = oc.length - 1, k = 0; //i指向旧数组末尾，k指向新数组开头
        while (i >= 0) {
            while(i >= 0 && oc[i] == ' ') i--; //跳过空格
            //此时i的位置要么为边界，要么为某个单词的右边界
            int right = i;
            while(i >= 0 && oc[i] != ' ') i--; //扫描单词
            // 此时i的位置要么为边界，要么为某个单词左边界的前一个位置
            //移动单词到新数组中
            for(int j = i + 1; j <= right; j++) {
                nc[k++] = oc[j];
                if (j == right)
                    nc[k++] = ' ';//手动插入一个空白字符
            }
        }
        if (k == 0) //源字符串中没有单词
            return ""; 
        return new String(nc, 0, k - 1);
    }
}
```

***

补充题目：右旋字符串

题目描述：字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。要求**不能申请额外空间，只能在本串上操作**（Java不能在字符串上修改，所以使用java一定要开辟新空间）

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

思路：这个问题与反转字符串中的单词基本一样。在右旋字符串中，可以将整个字符串分为两部分，尾部的k个字符和前面的剩余部分。将它们看成两个单词，右旋的效果与反转这两个单词的效果相同，可以采用上面两种思路解决。

[旋转字符串](https://leetcode.cn/problems/rotate-string/)也可以采用类似的方法，每次先整体反转，再将除尾字母外的部分做局部反转即可完成一次字符串整体的旋转操作，判断它和给定串是否相同。若旋转了"字符串长度"次后还未匹配，则说明不能旋转得到指定串。

它还有一种更巧妙的解法：字符串s后面再拼接一个s后，判断goal是否在其中出现过即可。**首尾相接后就包含了所有旋转操作的结果**，判断goal是否在其中即可。后面的[重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)也可用该思路解决。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250903193738615-2025-9-319:37:48.png" style="zoom:80%;" />

## [替换数字](https://kamacoder.com/problempage.php?pid=1064)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901163125134-2025-9-116:31:25.png" style="zoom:80%;" />

思路：

- 首先扩充数组到每个数字字符替换成 "number" 之后的大小。
- 然后使用双指针法**从后向前**替换数字字符。i指向新长度的末尾，j指向旧长度的末尾，使用j从后往前遍历旧数组元素，如果它是字母，将其移到新数组末尾；如果它是数字，则使用number填充新数组对应位置

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901164818797-2025-9-116:48:19.png" style="zoom:80%;" />

如果从前往后填充新数组，就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。

**其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后再从后向前进行操作。**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        int len = s.length();
        //计算扩容后的数组大小
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
                len += 5;
        }
        
        //创建新数组，转移元素
        char[] nc = new char[len];
        for (int i = 0; i < s.length(); i++) {
            nc[i] = s.charAt(i);
        }
        int j = s.length() - 1, i = len - 1;
        while (j >= 0) {
            if (nc[j] >= '0' && nc[j] <= '9') {
                nc[i--] = 'r';
                nc[i--] = 'e';
                nc[i--] = 'b';
                nc[i--] = 'm';
                nc[i--] = 'u';
                nc[i--] = 'n';
                j--;
            }else {
                nc[i--] = nc[j--];
            }
        }
        System.out.println(nc);
    }
}
```



## [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250902112903645-2025-9-211:29:30.png" style="zoom:80%;" />

题目要求找出模式串在文本串中首次出现的下标，是[KMP算法](https://catpaws.top/dac6dce7/#kmp算法实现)的经典应用场景。

```java
public int[] computeNext(String pattern) {
    int n = pattern.length();
    if (n == 0) return new int[0];
	
    //多申请一个空间，用next[n]保存整个模式串的最长相等前后缀长度
    int[] next = new int[n + 1];
    next[0] = -1; // 第一个位置固定为-1

    int j = -1; // 指向前缀的末尾位置
    int i = 0;  // 指向后缀的末尾位置
	
    //先递增索引i再赋值，故i的范围为[0,n-1]
    while (i < n) {
        // j == -1 表示需要从头开始匹配
        // pattern.charAt(i) == pattern.charAt(j) 表示匹配成功
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
            //先递增索引i再赋值，实现右移
            //next[i]保存着子串pattern[0:i-1]的最长相等前后缀长度
            next[i] = j; 
        } else {
            // 匹配失败，回溯到前一个可能匹配的位置，直到两字符匹配或到达初始条件为止
            j = next[j];
        }
    }
    
    return next;
}


public int kmpSearch(String text, String pattern) {
    if (pattern.isEmpty()) return 0;

    int[] next = computeNext(pattern);
    int i = 0; // 文本串指针
    int j = 0; // 模式串指针
    int n = text.length();
    int m = pattern.length();

    while (i < n && j < m) {
        // j == -1 表示模式串需要从头开始匹配
        if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
        } else {
            // 不匹配时，根据next数组回溯模式串指针
            j = next[j];
        }
    }

    // 如果模式串指针走到末尾，说明匹配成功
    if (j == m) {
        return i - j;
    }

    return -1;
}
```



## [重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

题目描述：对一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

思路一：将 s 拼接自身得到 s+s，然后去掉 s+s 的首尾字母，再检查这个新字符串中是否包含 s。如果包含，则 s 可以由子串重复构成；否则，不可以。去掉首尾字母的目的是排除原始 `s` 在开头和结尾的匹配，只检查中间部分是否出现 `s`

原理：如果字符串 `s` 可以由一个子串重复多次构成，那么 `s` 具有周期性，即存在一个子串 `t` 使得 `s = t + t + ... + t`，因此将`s`循环左移（或右移）`t`的长度倍后还会出现`s`。假设`s+s`并且去掉首尾字符构成的字符串为`T`，**`T`中包含了 `s` 的所有循环移位的集合**，如果 `s` 在其中出现，说明存在一个非平凡的循环移位（即不是原字符串本身）与 `s` 匹配。这表明 `s` 具有周期性，可以由一个子串重复构成；否则，`s` 不具有周期性。

```java
public boolean repeatedSubstringPattern(String s) {
    return (s+s).substring(1, 2 * s.length() - 1).contains(s);
}
```

***

思路二：通过KMP的next数组判断字符串是否由重复子串构成，next 数组存储了字符串的最长公共前后缀信息。

假设字符串s长度为n，由next[n]得到整个字符串的最长相等前后缀长度。若next[n] = 0，说明字符串没有任何相等前后缀，这意味着字符串中不存在重复的模式，因此无法由子串重复构成。(也可以反证，如果它可以由子串重复构成，必然存在非零的最长公共前后缀，next[n]一定大于0，与next[n] = 0矛盾，故它不能由子串重复构成)

**在模式串中，最长相等前缀或后缀所不包含的那部分子串就是最小重复子串。**例如，模式串s="ababab"，由其next数组知，它的最长相等前后缀长度为4，那么最长前缀不包含的那部分子串s[4:5] = "ab"就是最小重复子串，最小重复子串的长度为`n - next[n]`

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250904230557750-2025-9-423:05:58.png" style="zoom:80%;" />

如果 `next[n] > 0` 且 `n` 能被 `n - next[n]` 整除，则字符串 `s` 可以由子串 `s[0: n-next[n]-1]` 重复多次构成（重复次数至少为 2）。否则，不能由子串重复构成。

```java
public boolean repeatedSubstringPattern(String s) {
    int n = s.length();
    if (n == 1) return false; //一个字符不能由它自己重复多次组成

    int[] next = computeNext(s);
    if (next[n] == 0) return false; //没有任何公共前后缀

    return n % (n - next[n]) == 0;
}

//求next数组
public int[] computeNext(String s) {
    int n = s.length();
    //多申请一个空间，next[n]保存整个字符串的最长相等前后缀长度
    int[] next = new int[ n + 1];
    next[0] = -1;

    int j = -1; //指向前缀末尾
    int i = 0; //指向后缀末尾

    while (i < n) {
        if (j == -1 || s.charAt(i) == s.charAt(j)) {
            j++;
            i++;
            next[i] = j;
        } else{
            j = next[j];
        }
    }
    return next;
}
```



## [重复叠加字符串匹配](https://leetcode.cn/problems/repeated-string-match/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250905132043779-2025-9-513:20:45.png" style="zoom:80%;" />

判断字符串a至少要重复叠加多少次后才能包含b，基本思路就是a每叠加一次就从其中查找是否包含b，如果包含就返回当前重叠次数。其中在a叠加后的字符串中寻找b，可以使用[KMP算法](https://catpaws.top/dac6dce7/#kmp算法实现)或[Rabin-Karp 算法](https://catpaws.top/dac6dce7/#补充rk算法)

但是关键是如何判断不包含呢？重复次数的上限在哪呢？

设n = len(a), m = len(b)。当字符串 a 被重复多次时，形成的字符串是**周期性**的，周期长度为n。子串 b 在重复后的字符串中 可能从任何位置开始，但由于周期性，这些起始位置实际上只有 n 种可能的偏移量（即从 0 到 n−1，相对于 a 的起始位置）。

a 要重叠 $k =\lceil \frac{m}{n} \rceil$次才能保证它的长度至少与 b 相等，这样长度的字符串中才可能包含b。k 是重叠的最小次数，但 b可能从 a 的中间开始，因此仅重复 k 次可能不够。当重复 k+1 次后，字符串总长度为 (k+1)×n，这足够覆盖所有可能的起始偏移量，这是因为：

- 无论 b 从哪个偏移量开始（0 到 n−1），它都需要最多 n+len(b) 的长度来完整包含。
- 由于k×n≥len(b) ,有 (k+1)×n=k×n+n≥len(b)+n，这足以容纳任何起始位置的 b。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250906172046160-2025-9-617:20:55.png" style="zoom:80%;" />

如果 b 是 a 重复多次后的子串，它一定会在重复 k 次或 k+1次时出现。如果在这两种情况下都没有找到 b，那么即使重复更多次，也不会找到 b，因为额外的重复只是添加了相同的周期模式，但所有可能的匹配位置已经在 k+1次时被穷举了。

因此，只需检查 k 和 k+1 次重复是否包含 b，如果都不包含则返回 -1。

此外，我们不需要真正构建出 a 重复很多次后的字符串。由于它是周期性的，可以通过**模运算**在a中访问任何位置的字符。

```java
public int repeatedStringMatch(String a, String b) {
    int n = a.length(), m = b.length(); 
    if (n == 0) return -1;
    if (m == 0) return 0;

    int k = (int)Math.ceil((double)m / n); //最小重复次数
    int[] next = computeNext(b); //计算b的next数组
    if (kmpSearch(a, b, next, k))  return k;
    if (kmpSearch(a, b, next, k+ 1)) return k + 1;
    return -1;

}

public int[] computeNext(String b) {
    int n = b.length();

    int[] next = new int[n + 1];
    next[0] = -1;

    int j = -1;
    int i = 0;
    while (i < n) {
        if (j == -1 || b.charAt(i) == b.charAt(j)) {
            j++;
            i++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
    return next;
}

boolean kmpSearch(String a, String b, int[] next, int times) {
    int n = a.length(), m = b.length(); 
    int i = 0;
    int j = 0;

    while (i < times * n && j < m) {
        if (j == -1 || a.charAt(i % n) == b.charAt(j)) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    return j == m;
}
```



{% note info%}

总结：本题的关键是A重叠多次后生成的字符串是**周期性的**。字符串B可以出现在 将A重叠无数次后的字符串的任一位置，但由于重叠后的字符串具有周期性，B的起始偏移位置总是在一个A的内部，偏移范围是[0, len(A)-1]。将A重叠$k =\lceil \frac{m}{n} \rceil$次得到字符串S，它中已经包含了起始偏移在[0,x]范围内的与B长度相同的子串($x \in len(A)-1$)；当起始位置超过x时，与B长度相同的子串会有一部分延申出去，延申出去的长度不会超过len(A)，因此只需再重叠一次就能确保所有可能的起始偏移量都被覆盖。

总结一下周期性的字符串具有的重要性质：

- 每个周期字符串都有一个最小周期 p，它是所有可能周期中最小的。最小周期的长度 p 必须整除字符串的长度 n。
- 如果一个字符串有长度为 b 的边界（既是前缀又是后缀的子串），那么该字符串具有周期性，周期为 n - b。
- 周期字符串的循环移位仍然是周期字符串。具体来说，如果将周期字符串向左或向右移动其周期长度的倍数，得到的字符串与原字符串相同。

{% endnote %}

## [多次搜索](https://leetcode.cn/problems/multi-search-lcci/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250905120008101-2025-9-512:00:09.png" style="zoom:80%;" />

思路一：扩展应用[KMP算法](https://catpaws.top/dac6dce7/#kmp算法实现)处理多个模式串的匹配问题。将smalls中的每个字符串当作模式串，在主串big中寻找所有匹配的位置（此处允许重叠匹配），收集返回即可。

```java
public int[][] multiSearch(String big, String[] smalls) {

    List<List<Integer>> positions = new ArrayList<>();
    for (String pattern : smalls) {
        positions.add(getALLPosition(big, pattern));
    }
	
    return positions.stream()
        .map(subList -> subList.stream().mapToInt(Integer::intValue).toArray())
        .toArray(int[][]::new);
}

//KMP搜索所有匹配位置
public List<Integer> getALLPosition(String text, String pattern) {
    List<Integer> position = new ArrayList<>();
    // 模式串为空
    if (pattern.isEmpty()) 
        return position;

    int[] next = computeNext(pattern);

    int i = 0;
    int j = 0;  
    int n = text.length();
    int m = pattern.length();

    while (i < n) {
        if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;

            if (j == m) {
                position.add(i - j);
                j = next[j];
            }
        } else{
            j = next[j];
        }
    }
    return position;
}

//计算next数组
public int[] computeNext(String pattern) {
    int n = pattern.length();
    int[] next = new int[n + 1];
    next[0] = -1;

    int j = -1;
    int i = 0;

    while (i < n) {
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            j++;
            i++;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
    return next;
}
```

思路二：使用前缀树