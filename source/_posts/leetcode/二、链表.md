---
title: 二、链表
categories:
  - leetcode
abbrlink: 9d1ae18b
math: true
date: 2025-07-01 09:42:44
tags:
---

<meta name = "referrer", content = "no-referrer"/>
## [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713111517546-2025-7-1311:15:18.png" style="zoom:80%;" />



思路：

- 双指针法

  定义pre和cur指针，pre指向前一个结点，cur指向当前结点。初始时，pre指向null，cur指向头结点。再定义一个next指针保存cur的后继结点，方便进入下一轮循环。

  ```java
  public ListNode reverseList(ListNode head) {
      if (head == null || head.next == null)
          return head;
      ListNode pre = null, cur = head, next;
      while(cur != null) {
          next = cur.next;
          cur.next = pre;
          pre = cur;
          cur = next;
      }
      return pre;
  }
  //实际上pre指向反转后链表的头结点，cur指向剩余链表的头结点，每次用pre作为cur的后继就完成了反转
  ```

- 头插法逆置

  定义一个虚拟头结点，遍历链表，将每次遍历到的结点作为虚拟头结点的后继。

  ```java
  public ListNode reverseList(ListNode head) {
      ListNode headNode = new ListNode();
      ListNode p = head, q;
      //头插法翻转
      while (p != null) {
          q = p.next;
          p.next = headNode.next;
          headNode.next = p;
          p = q;
      }
      return headNode.next;
  }
  ```

## [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713185550914-2025-7-1318:55:55.png" style="zoom:80%;" />

思路：分组检查 → 断链翻转 → 重新连接。创建虚拟头结点 `dummy` 统一处理头节点翻转，同时记录最终链表的头结点。

- 每组向后遍历k个结点，检查当前组是否满足k个节点，若不足k个直接return
- 保存下组的首节点后，将当前组与下一组断开，使用辅助函数 reverseList 独立翻转当前组
- 翻转后的组连接到上一组的尾部，原组头节点（翻转后成为尾节点）连接下一组

**关键：断链，断链操作使翻转逻辑更简单**



<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713231240813-2025-7-1323:12:41.png" style="zoom:80%;" />

```java
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || head.next == null) return head;

    ListNode dummy = new ListNode();
    dummy.next = head;
    ListNode pre = dummy; // 上一组的尾节点
    while(pre.next != null) {
        // 1. 检查剩余节点是否足够k个
        ListNode end = pre;
        for (int i = 0; i < k; i++) {
            end = end.next;
            if (end == null) 
                return dummy.next; 
        }

        //2.记录关键节点
        ListNode start = pre.next; // 当前组头节点
        ListNode newGroup = end.next; //下一组头结点
        end.next = null; //断开当前组与下一组的连接

        //3.翻转后重新连接
        pre.next = reverseList(start); //翻转后连接到前一组尾部
        start.next = newGroup; //当前组尾部连接到下一组头部

        pre = start; //移动指针到下一组
    }
    return dummy.next;
}

public ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



## [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702100216382-2025-7-1400:01:58.png" style="zoom:80%;" />

思路：从两个链表头部开始各自向后遍历，每次找出两者中的最小值，插入到新链表的尾部，并将该链表 的遍历指针向后移动。若有一个遍历完毕，则将另一个剩余部分拼接到新链表尾部即可。

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        ListNode headNode = new ListNode();
        ListNode p = headNode; 
        while(list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                p.next = list1;
                list1 = list1.next;
            } else {
                p.next = list2;
                list2 = list2.next;
            }
            p = p.next;
        }
        //if (list1 == null)
        //    list1 = list2;
        //p.next = list1;
		p.next = list1 != null ? list1:list2;
        return headNode.next;
    }
}
```

## [合并 K 个有序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。



思路：**利用分治的思想，将 K 个链表的合并问题分解为多个两两合并的子问题，通过递归实现自底向上的归并排序。**参考归并排序，将给定的升序链表看做一个个数组元素，对这个数组进行排序，只不过最终归并两个数组元素时，使用的是合并两个两个升序链表的方法。（归并排序过程的某个切片就是将k个有序子数组合并成一个）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713235559285-2025-7-1323:56:00.png" style="zoom:67%;" />

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    if (lists.length == 1) return lists[0];

    //归并排序
    return mergeKLists(lists,0, lists.length - 1);

}

public ListNode mergeKLists(ListNode[] lists,int low, int high) {
    //low < high，说明需要继续拆分：
    if (low < high) {
        int mid = (low + high) / 2;
        ListNode list1 =  mergeKLists(lists, low , mid);
        ListNode list2 =  mergeKLists(lists, mid + 1, high);
        return merge2Lists(list1, list2);
    } else {
        return lists[low]; //low和high指向同一个，返回即可
    }
}

//合并两个有序链表
public ListNode merge2Lists(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode();
    ListNode p = head1, q = head2, tail = dummy;
    while (p != null && q != null) {
        if (p.val < q.val) {
            tail.next = p;
            p = p.next;
        } else {
            tail.next = q;
            q = q.next;
        }
        tail = tail.next;
    }

    tail.next = p != null ? p : q;
    return dummy.next;
}
```

## [排序链表](https://leetcode.cn/problems/7WHec2/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713160412088-2025-7-1316:04:14.png" style="zoom:80%;" />

思路：

- 采用插入排序对链表进行排序，每次选择未排序部分的第一个结点，在已排序部分寻找插入位置并插入，直至处理完所有未排序结点。时间复杂度$O(n^2)$，会超时

  ```java
  public ListNode sortList(ListNode head) {
      if (head == null || head.next == null)
          return head;
      ListNode headNode = new ListNode(); //虚拟头结点
      ListNode ptr = head.next;
      //先将第一个结点放入已排序部分，从第二个结点开始取
      headNode.next = head;
      headNode.next.next = null;
  
      ListNode nextNode, pre, cur;
      while (ptr != null) {
          //保存下一个待排序结点
          nextNode = ptr.next;
          pre = headNode;
          cur = pre.next;
          //在已排序部分寻找插入位置
          while (cur != null && cur.val < ptr.val) {
              pre = cur;
              cur = cur.next;
          }
          //插入
          ptr.next = pre.next;
          pre.next = ptr;
          ptr = nextNode;
      }
      return headNode.next;
  }
  ```

- 思路二：采用自顶向下的归并排序，时间复杂度O(n$log_2^n$)，空间复杂度为$O(log_2^n)$

  归并三部曲：分割、各自递归排序、最后合并

  1. 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针。
  2. 对两个子链表分别排序。
  3. 将两个排序后的子链表合并，得到完整的排序后的链表。

  ```java
  public ListNode sortList(ListNode head) {
      if (head == null || head.next == null)
          return head;
      //从中间切分链表
      ListNode newHead = division(head);
      //对前后两条链表分别进行排序
      ListNode firstList = sortList(head);
      ListNode secondList = sortList(newHead);
      //合并
      return merge(firstList, secondList);
  }
  
  //分割链表
  public ListNode division(ListNode head) {
      if(head == null || head.next == null) 
          return head;
  
      ListNode slow = head, fast = head;
      while(fast.next != null && fast.next.next != null) {
          slow = slow.next;
          fast = fast.next.next;
      }
      //此时slow指向前一个链表尾部，将其从slow处分成两个链表，并返回后一链表的第一个结点
      ListNode newHead = slow.next;
      slow.next = null;
      return newHead;
  }
  
  //合并两个有序链表
  public ListNode merge(ListNode head1, ListNode head2) {
      ListNode headNode = new ListNode(); //虚拟头结点
      //p,q用于遍历，tail执行新链表的尾结点
      ListNode p = head1, q= head2, tail = headNode;
      while (p != null && q != null) {
          if (p.val <= q.val) {
              tail.next = p;
              p = p.next;
          } else {
              tail.next = q;
              q = q.next;
          }
          tail = tail.next;
      }
      // if (q != null) 
      //     p = q;
      // tail.next = p;
      tail.next = (p != null ? p : q);
      return headNode.next;
  }
  ```

## [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702102216000-2025-7-210:22:34.png"  />

思路：

- 若给定的两个链表中有一个为空，则不可能相交。
- 首先分别遍历两个链表，记录它们的长度以及最后一个结点。若两者的最后一个结点不一致，则不可能相交。

- 之后，将两者**对齐**后同时向后移动。即让更长的链表先移动长度之差个单位后，同时向后移动。若两者相交，则会指向同一个结点，此时返回该结点。若不相交，则两者都会遍历到null。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA, q = headB;
        if (headA == null || headB == null) return null;
        
        int lenA = 0, lenB = 0;
        while (p.next != null) {
            lenA++;
            p = p.next;
        }
        while (q.next != null) {
            lenB++;
            q = q.next;
        }
        // 两链表的最后一个结点不同，必定不相交
        if (p != q) return null;

        //对齐
        if (lenA > lenB) {
            for (int i = 0; i < lenA - lenB; i++) 
                headA = headA.next;
        } else {
            for(int i = 0; i < lenB - lenA; i++) 
                headB = headB.next;
        }

        //一起向后移动
        while (headA != headB) {
            headA = headA.next;
            headB = headB.next;
        }

        return headA == null ? null:headA;

    }
}
```

***

进阶：给定两个**可能有环也可能无环**的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null

【要求】如果两个链表长度之和为N，时间复杂度请达到O（N），额外空间复杂度 请达到0（1）。

思路：

1. 首先判断两链表是否有环，有环则返回入环的第一个节点，无环则返回 null。

2. 对于各自返回的两个节点 n1 和 n2。

   1. 若n1和n2都为空，则两链表无环。此时分别遍历两链表，记录两链表的长度差值和各自的最后一个结点。若各自的最后一个结点不同，则两链表不相交；若相同则两链表相交，此时让长链表先移动差值步，之后两者一起移动，当第一次相等时，所指结点为第一个相交结点。

   2. 若n1和n2都不为空，则两链表均有环。此时只有三种种情况

      ![](https://gitee.com/cmyk359/img/raw/master/img/image-20240418110156214-2024-8-410:42:44.png)

      若n1和n2相同，则两链表相交，此时找第一个相交结点即可，和环无关，转换为两无环链表第一个相交结点的问题，即case3

      若n1和n2不同，则从n1出发，遍历一遍环，若能在其过程中找到n2则为case2,两链表相交，此时n1和n2均可为第一个相交结点；若没找到n2则为case1，不相交

   3. n1和n2有一个为空另一个不为空。**有环和无环的链表不可能相交。**若相交则共用这个环，另一个不可能为无环

## [环形链表I](https://leetcode.cn/problems/linked-list-cycle/)

判断链表是否存在环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702110950398-2025-7-211:09:52.png" style="zoom:80%;" />

思路：

- 使用**HashSet或HashMap**来保存已遍历过的结点（节点地址，而非值），每遍历一个结点，就查set或map看是否已经保存过。若没有查到，则将其存入；若查到则表示有环，且第一个查到的是第一个入环节点。若遍历到null则说明无环

- 使用**快慢指针**，快指针每次向后跳两个节点，慢指针每次向后跳一个结点。若链表有环，则当快慢指针进入环后，肯定会再次相遇，此时判断出链表有环；若快指针移动到null说明没有环。

  ```java
  /**
   * Definition for singly-linked list.
   * class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) {
   *         val = x;
   *         next = null;
   *     }
   * }
   */
  public class Solution {
      public boolean hasCycle(ListNode head) {
          if (head == null || head.next == null ) return false;
          //使用快慢指针，慢指针每次走一步，快指针每次走两步
          ListNode slow = head, fast  = head;
          while (fast != null && fast.next != null) {
              slow = slow.next;
              fast = fast.next.next;
              if (slow == fast) return true;
          }
          return false; //fast为null，链表中无环
      }
  }
  ```

  

## [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

链表存在环时，求第一个入环结点

思路：在使用快慢指针判断有环的基础上，快慢指针在环内相遇，此时，将快指针移到头部且每次只走一步，快慢指针同时出发，当两者再次相遇时共同指向的结点即为入环的第一个结点

细节：一开始让slow指针先走一步，fast指针先走两步 ，以便能进入下面的while循环，当再次相等时退出

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        //快慢指针分别先走一步
        ListNode slow = head.next;
        ListNode fast = head.next.next;

        while (slow != fast) {
            if (fast == null || fast.next == null) 
                return null; //无环
            slow = slow.next;
            fast = fast.next.next;
        }
        
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```



## [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

思路：使用快慢指针，慢指针一次走一步，快指针一次走两步，快指针到达链表尾部时，慢指针到达链表中部。当要删除中间结点时，让fast多走一步后slow再开始移动，最终slow会指向中间结点的前一个结点，方便删除。

补充：对于返回结点的不同，其slow和fast初始位置有所不同：

- 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
- 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
- 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

思路：

1. 首先判断链表中，没有结点、有一个结点、有两个结点时，该返回什么
2. 其次，画出最终返回时两指针的位置，再往前反推slow和fast该如何设置初始值才能满足条件
3. 最后，最终结点都是由slow返回。由于fast每次走两步，while的终止条件都为：fast.next != null && fast.next.next != null

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713105318434-2025-7-1310:53:19.png" style="zoom:80%;" />

```java
//1、输入链表头节点，奇数长度返回中点，偶数长度返回上中点
if ( head == null || head.next == null || head.next.next == null)
    return head;
slow = head;
fast = head;
while (fast.next != null && fast.next.next != null) {
      slow = slow.next;
      fast = fast.next.next;
}
return slow;

//2、输入链表头节点，奇数长度返回中点，偶数长度返回下中点
if (head == null || head.next == null)
    return head;
if (head.next.next == null) 
    return head.next;
//相当于第一种方式中slow和fast最终位置都后移一位
//偶数：slow指向了下中点
//奇数：slow还是指向中点，只不过fast指向了null，终止条件不同
slow = head.next;
fast = head.next;
....
    
    
    
    
    
//3、输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
if (head == null || head.next == null || head.next.next == null) 
    return null;
slow = head;
fast = head.next.next;
...

//4、输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个(上中点)
if (head == null || head.next == null)
    return null;
if (head.next.next == null)
    return head;
slow = head;
fast = head.next;
...
```

## [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713110215937-2025-7-1311:02:26.png" style="zoom:80%;" />

思路：

- 1、由于回文是正序和逆序相同，故可以使用栈，先将所有元素入栈，再边遍历链表边出栈，判断所有元素是否相同即可

- 2、基于1的方法，先使用快满指针找到链表中点，将中点以后的元素都入栈，再从链表头开始和出栈的元素比较是否相等，当栈为空时仍相同则为回文，否则不为（空间复杂度降一半）

- 3、（不使用辅助栈）还是利用快慢指针找到链表中点（或上中点），将其next设为null，且将后半部分链表**逆序**。之后从两边向中间一次判断结点是否相同，若直到一个指针为空仍相同，则为回文，否则不是。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240417181004501-2024-8-410:42:33.png" style="zoom:80%;" />

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        //1、找到链表的中点
        if (head == null || head.next == null )
            return true;
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        //2、逆置后半段
        ListNode pre = null, cur = slow, next;
        while (cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        //3、从两端向中间逐个对比
        ListNode p = head, q = pre;
        cur = pre; //保存后半段链表的头结点，用于后面恢复链表
        boolean result = true; //由于后续还要恢复链表，先将结果保存不返回
        while (p != null && q != null) {
            if (p.val != q.val) {
                result = false;
                break;
            }    
            p = p.next;
            q = q.next;
        }
        

        //4、恢复链表
        pre = null;
        while (cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
		
        return result;
    }
}
```

## [复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713113830648-2025-7-1311:38:31.png" style="zoom:80%;" />

思路：**关键是保存原结点和新结点的映射关系**

1. 使用HashMap保存原结点和新结点的映射关系，一开始遍历原链表，将原结点作为map的key，新结点作为map的value保存起来。再次遍历原链表，根据原链表的next和random指针，连接新结点的各指针域。

   ```java
           //1、使用HashMap保存新旧结点
   		....sssss
           //2、连接新结点的指针域
   		ptr = head;
           while (ptr != null) {
               //连接新结点的next指针域
               nodeMap.get(ptr).next = nodeMap.get(ptr.next); 
             //连接新结点的random指针域
               nodeMap.get(ptr).random = nodeMap.get(ptr.random);
             ptr = ptr.next;
           }
   ```

2. 使用next指针域来保存新结点和原结点的映射关系。**将新创建的结点插入到原结点之后，便可以通过访问原结点的next指针域轻松找到新结点**（与HashMap的功能相同）。在连接好新结点的各指针域后，需将新链表和原链表拆分开，此时只涉及next指针域方向的拆分。

   <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713153028805-2025-7-1315:30:41.png" style="zoom:80%;" />

   ```java
   /*
   // Definition for a Node.
   class Node {
       int val;
       Node next;
       Node random;
   
       public Node(int val) {
           this.val = val;
           this.next = null;
           this.random = null;
       }
   }
   */
   class Solution {
       public Node copyRandomList(Node head) {
           if (head == null)
               return head;
   
           //1、创建新节点，作为当前结点的后继
           Node cur = head;
           while (cur != null) {
               Node node = new Node(cur.val);
               node.next = cur.next;
               cur.next = node;
               cur = node.next;
           }
   
           //2、连接新链表中结点的random指针域
           //不能同时修改next指针域，可能会导致random设置出错
           cur = head;
           Node newNode;
           while (cur != null) {
               newNode = cur.next;
               newNode.random = cur.random == null ? null : cur.random.next;
               cur = newNode.next;
           }
   
           //3、分离链表，连接新链表的next指针域，同时恢复旧链表结构
           cur = head;
           Node newHead = cur.next; 
           while (cur != null) {
               newNode = cur.next;
               cur.next = newNode.next; //恢复旧结点的next
               newNode.next = newNode.next == null ? null : newNode.next.next;//连接新结点的next
               cur = cur.next;
           }
           return newHead;
       }
   }
   ```



## [重排链表](https://leetcode.cn/problems/reorder-list/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713172907881-2025-7-1317:29:12.png" style="zoom:80%;" />

思路：首先使用快满指针找到链表的中点，将其分成前后两个链表。再将后一个链表逆置。最后将前半段链表与逆置后的后半链表**合并**，其中时间复杂度0(n)，空间复杂度O(1)。

```java
public void reorderList(ListNode head) {
    if (head == null || head.next == null) return;
    //分割链表，返回后半链表头结点
    ListNode newHead = division(head);

    //后半链表逆置
    newHead = reverse(newHead);

    //两链表合并
    merge(head, newHead);
}

public ListNode division(ListNode head) {
    if (head == null || head.next == null) 
        return head;

    ListNode slow = head, fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    ListNode newHead = slow.next;
    slow.next = null;
    return newHead;
}

public ListNode reverse(ListNode head) {
    if (head == null || head.next == null)  return head;
    ListNode pre = null, cur = head, nextNode;
    while (cur != null) {
        nextNode = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nextNode;
    }
    return pre;
}

public void merge(ListNode head1, ListNode head2) {
    //按照之前的分割方法，后半链表长度 <= 前半链表长度
    ListNode p = head1, q = head2, next1, next2;
    while(q != null) {
        next1 = p.next;
        next2 = q.next;

        q.next = p.next;
        p.next = q;
        p = next1;
        q = next2;
    }
}
```

## [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

## [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

