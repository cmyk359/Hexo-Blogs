---
title: 一、数组
categories:
  - leetcode
abbrlink: c82a5987
math: true
date: 2025-07-01 09:42:33
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## 一、[找到数组的中间位置](https://leetcode.cn/problems/find-the-middle-index-in-array/)

找中心坐标i，使左右两侧的元素和相等

思路：

- 遍历一遍求出总和 sum；

- 遍历第二遍中求leftSum（初始为0），求中心坐标i；

  如果 leftsum == sum - leftsum - nums[i]，即在nums[i]两侧的和相等，i即为所求，返回。

  否则 继续统计leftsum：leftsum += nums[i]

- 没有 中心下标，返回 -1 ;

```java
class Solution {
    public int findMiddleIndex(int[] nums) {
        int sum = 0, leftSum = 0;
        for (int i = 0; i < nums.length; i++) 
            sum += nums[i];
        for (int i = 0; i < nums.length; i++) {
            //在nums[i]两侧的和相等
            if (leftSum == sum - leftSum - nums[i])
                return i; 
            leftSum += nums[i];
        }
        return  -1;
    }
}
```

## 二、[二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

{% note info%}

使用二分法的前提：数组有序，无重复元素（否则所返回的下标不唯一）

{% endnote%}

思路：

- 定义 target 是在一个在左闭右闭的区间里，**也就是[left, right]**，此时left == right是有意义的。当left  > rigth时查找失败，返回-1。
- 每次循环中：mid  = (left + right) / 2。
  - 若 target == nums[mid]，则找到目标值，返回mid。
  - 若 target > nums[mid]，则说明目标值在中间值的右侧，left = mid + 1继续查找。
  - 若 target < nums[mid]，则说明目标值在中间值的左侧，right = mid - 1继续查找。

> mid = left + ((right - left) >> 1) 等同于(left + right) /2，但两者相加可能会溢出 

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1) ; // 等同于(left + right)/2
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

## 三、[移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

思路：使用一个变量k，记录数组中不等于val的元素个数，初始为0。

遍历一遍数组，若nums[i] != val，则将其向前移动，移到nums[k++]的位置。遍历结束后，所有不等于val的元素都被移动到了数组前面。

> 双指针法：其中i和k是快指针和慢指针

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int k = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val)
                nums[k++] = nums[i];
        }
        return k;
    }
}
```

## 四、[有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

思路：数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 数组中元素有正有负，负数元素平方后可能变为更大的正数。
        // 由于数组非递减，平方后的最大值只可能在两端。所有数组元素平方后的数值呈现开口向上的抛物线走势，故采用双指针，像合并两个有序链表一样，从两端合并为一个整体有序的
        //不要平方后再排序，排序的时间复杂度至少为O(nlogn)    
        int[] result = new int[nums.length];
        int i = 0, j = nums.length - 1;
        int k = j;
        //类似于将两个升序链表从尾部开始合并为一个整体升序的链表
        while (i <= j) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                result[k--] = nums[j] * nums[j];
                j--;
            } else {
                result[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return result;
    }
}
```



## 五、[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901105457506-2025-9-110:55:10.png" style="zoom:80%;" />

**滑动窗口**

所谓滑动窗口，就是**不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。起始位置和终止位置之间就是滑动窗口的内容。滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在暴力解法中，是一个for循环控制滑动窗口的起始位置，一个for循环控制滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

如果只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的**<span style="color: red">终止位置</span>**。若循环的索引是起始位置的话，要不断收集不同区间内的值，就要按照暴力搜索的方法进行，与暴力解法无二。

 

要实现滑动窗口，主要确定一下三点

- 窗口内是什么？
- 如何移动窗口的起始位置？（<span style="color: red">关键</span>）
- 如何移动窗口的结束位置？

 在本题中：

窗口是满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的终止位置如何移动：终止位置是for循环中的索引，随for循环向后移动



滑动窗口的精妙之处在于根据当前子数组和的大小，不断调节子数组的起始位置，从而将时间复杂度从$O(n^2)$降低为$O(n)$

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int i = 0,sum = 0, result = Integer.MAX_VALUE, subLen =  0;
        //i是滑动窗口起始位置，j是终止位置
        for (int j = 0; j < nums.length; j++) {
            //求滑动窗口内元素的和
            sum += nums[j];
            while (sum >= target) { //持续移动起始位置
                subLen = j - i + 1;
                sum -= nums[i++];
                result = subLen < result ? subLen : result;
            }
        }
         return result == Integer.MAX_VALUE ? 0 : result;
    }
}

```



## 六、[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 1到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250701155744078-2025-7-115:57:45.png" style="zoom:80%;" />

思路：此处采用一圈一圈地，沿顺时针方向由外到内的方法“画出”该矩阵：

- 从左到右填充上行
- 从上到下填充右列
- 从右到左填充下行
- 从下到上填充左列

在遍历矩阵四条边时，统一坚持“左闭右开”的规则。按照左闭右开的原则画圈，如图所示：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250701160424648-2025-7-116:04:26.png" style="zoom:80%;" />

代码中的一些变量比较重要：

- loop：表示总共要画几圈，由于每圈一定会遍历到两条不同的行和列，故总共的圈数为n / 2。对应n是奇数的情况，最后手动填充中心位置的元素即可。
- startx，starty：在每一圈中，开始填充的初始位置是不同的，比如，第一圈为(0,0)，第二圈为(1,1)....
- offset：由于每条边采用 左闭右开 的遍历方式，在每一圈中，一条边遍历的终止位置不同，第一圈是[0,n -1)，第二圈是[1,n - 2)。此处使用offset变量来控制每条边遍历的终止位置

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int loop = n / 2; //总共处理n/2圈
        int startx = 0, starty = 0; //每圈开始填充的起始位置
        int offset = 1; //每条边采用 左闭右开 的遍历方式，每条边遍历的终止位置为 n - offset
        int count = 1; // 矩阵中需要填写的数字
        int i, j;
        
        while (loop-- > 0) {
            i = startx;
            j = starty;

            //处理第一行; 此时 i = startx, j = starty
            for (;j < n - offset; j++)
                matrix[i][j] = count++;
            
            //处理第n列；此时 i = startx, j = n - offset
            for (;i < n - offset; i++)
                matrix[i][j] = count++;
            
            //处理第n行；此时 i = n - offset, j = n - offset
            for (; j > starty; j--)
                matrix[i][j] = count++;
            
            //处理第一列；此时 i = n - offset, j = starty
            for (;i > startx; i--)
                matrix[i][j] = count++;
            
            startx++;
            starty++;
            offset++;
        }
        // n 为奇数时，单独处理矩阵中心的值
        if (n % 2 == 1) matrix[startx][starty] = count;
        return matrix;
    }
}
```

## 七、[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

***

思路一：参考螺旋矩阵II的解题方式，由内到外沿顺时针方向遍历，每条边遍历时遵守“左闭右开”原则

关于遍历的圈数，此时的矩阵是m*n的，遍历的圈数依赖于行和列中的最小值。

- 若 min(m,n)为偶数，则总的圈数是 min(m,n) / 2

- 若 min(m,n)为奇数，则总的圈数是 min(m,n) / 2 , 最终会剩余一行或一列，需要判断出是行还是列并手动添加到结果集中

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250701162328567-2025-7-116:23:37.png" style="zoom:80%;" />

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;//矩阵是m*n的
        int loop = Math.min(m, n) / 2;
        int startx = 0, starty = 0; //每圈开始的位置
        //遍历每行和列时，始终采用左闭右开的规则
        int offset = 1; //在每一圈中，用来控制某行或列遍历的终止位置
        int i, j;
        List<Integer> res = new ArrayList<>();

        while (loop-- > 0) {
            i = startx;
            j = starty;

            //遍历第一行；此时i = startx, j = starty
            for (; j < n - offset; j++)
                res.add(matrix[i][j]);

            //遍历最后一列；此时i = startx，j = n - offset
            for (; i < m - offset; i++)
                res.add(matrix[i][j]);

            //遍历最后一行；此时i = m - offset, j = n - offset
            for (; j > starty; j--)
                res.add(matrix[i][j]);

            //遍历第一列，此时i = m - offset, j = starty
            for (; i > startx; i--)
                res.add(matrix[i][j]);

            startx++;
            starty++;
            offset++;
        }

        // 处理剩余的单行或单列
        if (Math.min(m, n) % 2 == 1) { // 只有当最小边长为奇数时才有剩余
            if (m <= n) {
                // 剩余的是一行
                for (j = starty; j < n - offset + 1; j++) {
                    res.add(matrix[startx][j]);
                }
            } else {
                // 剩余的是一列
                for (i = startx; i < m - offset + 1; i++) {
                    res.add(matrix[i][starty]);
                }
            }
        }

        return res;
    }
}
```

总结：该解法通过计算总圈数，循环遍历每圈的四条边界，最后单独处理剩余的中间行或列，实现矩阵的顺时针螺旋遍历。采用左闭右开的遍历区间，避免重复访问边界元素。

***

思路二：

定义四个边界变量：top（上边界），bottom（下边界），left（左边界），right（右边界），分别初始化为矩阵的边缘。

利用四个边界控制螺旋遍历，顺时针方向依次遍历四条边，每遍历一条边界就将其缩小：

- 从左到右，顶部一层遍历完往下移一位，top++；
- 从上到下，遍历完右侧往左移一位，right--；
- 从右到左，判断`top <= bottom`，即是否上下都走完了。遍历完底部上移，bottom--；
- 从下到上，判断`left <= right`，遍历完左侧右移，left++；

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        // 初始化边界：左、右、上、下
        int left = 0, right = n - 1, top = 0, bottom = m - 1;
        List<Integer> res = new ArrayList<>();

        //遍历四个边界，并不断缩小
        while (left <= right && top <= bottom) {

            // 遍历上边界
            for (int j = left; j <= right; j++)
                res.add(matrix[top][j]);
            top++;// 上边界下移一行

            // 遍历右边界
            for (int i = top; i <= bottom; i++)
                res.add(matrix[i][right]);
            right--; //右边界左移一列

            // 判断上边界是否仍在下边界之上，当只剩一行时， 避免重复遍历
            if (top <= bottom) {
                // 遍历下边界
                for (int j = right; j >= left; j--)
                    res.add(matrix[bottom][j]);
                bottom--; // 下边界上移一行
            }

            // 判断左边界是否仍在右边界之左，当只有一列时，避免重复遍历
            if (left <= right) {
                // 遍历左边界列
                for (int i = bottom; i >= top; i--)
                    res.add(matrix[i][left]);
                left++;// 左边界右移一列
            }
        }
        return res;

    }
}
```

总结：通过维护四个边界变量，逐步缩小遍历范围，顺时针遍历矩阵的边界，直到所有元素被访问，实现了矩阵的螺旋顺序输出。该方法直观且易于理解。

## 八、[矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250701173040977-2025-7-117:30:43.png" style="zoom:80%;" />

思路：先扫描一边矩阵，记录哪些位置有0；再遍历一边矩阵，置0。

记录0元素的位置，可采用多个方案：

- 使用与原矩阵相同大小的矩阵，在第一次遍历中标记出0元素的位置。空间复杂度为$O(mn)$
- 使用与行和列相同大小的集合或数组，分别记录0元素所在的行和列的下标。空间复杂度为$O(m+n)$

- 使用矩阵的第一行和第一列代替之前的两个标记数组，同时使用两个标记记录第一行和第一列中是否有0.空间复杂度$O(1)$

```java
//思路二：使用与行和列相同大小的数组，分别记录0元素所在的行和列的下标。
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        //记录矩阵中0元素对应位置的行列坐标
        boolean[] row_flag = new boolean[m];
        boolean[] col_flag = new boolean[n];

        //标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {    
                    row_flag[i] = col_flag[j] = true;
                }
            }
        }

        //置0
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //该元素所在行或列存在0元素，则将它也置为0
                if(row_flag[i] || col_flag[j])
                    matrix[i][j] = 0;
            }
        }
    }
}
```



```java
//思路二：使用矩阵的第一行和第一列代替之前的两个标记数组。
//标记：首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列
//置零：然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        boolean row0_flag = false;
        boolean col0_flag = false;

        //第一行中是否存在0
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                row0_flag = true;
                break;
            }
        }

        //第一列中是否有0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col0_flag = true;
                break;
            }
        }

        //标记
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {    
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }

        //置0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                //该元素所在行或列存在0元素，则将它也置为0
                if(matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            }
        }

        //处理第一行
        if (row0_flag) {
            for (int j = 0; j < n; j++)
                matrix[0][j] = 0;
        }
        //处理第一列
        if(col0_flag) {
            for (int i = 0; i < m; i++) 
                matrix[i][0] = 0;
        }
    }
}
```

