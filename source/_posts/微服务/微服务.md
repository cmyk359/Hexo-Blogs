---
title: 微服务
categories:
  - 微服务
abbrlink: 460c1130
hide: true
date: 2025-02-05 10:27:48
tags:
---

<meta name = "referrer", content = "no-referrer"/>

#  一、服务调用

Java发送http请求可以使⽤Spring提供的RestTemplate，使⽤的基本步骤如下：

- 注册RestTemplate到Spring容器
-  调⽤RestTemplate的API发送请求

用RestTemplate发送http请求，包含四部分信息：

- ① 请求方式
- ② 请求路径
- ③ 请求参数
- ④  返回值类型

CartService 去调用 ItemService中的方法：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250204220304197-2025-2-422:21:55.png)

后面会使用OpenFeign完成服务调用。

#  二、服务注册和发现

当对一个服务进行多实例部署后，每个实例都有自己的IP或端⼝，使用RestTemplate发送http请求时需要指定路径，此时就十分困难了

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205114251666-2025-2-511:43:25.png" alt="image-20250205114251666" style="zoom:80%;" />

此时，每个`item-service`的实例其IP或端口不同，问题来了：

- item-service这么多实例，cart-service如何知道每一个实例的地址？
- http请求要写url地址，`cart-service`服务到底该调用哪个实例呢？
- 如果在运行过程中，某一个`item-service`实例宕机，`cart-service`依然在调用该怎么办？
- 如果并发太高，`item-service`临时多部署了N台实例，`cart-service`如何知道新实例的地址？

为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。

## 2.1、注册中⼼原理

在微服务远程调⽤的过程中，包括两个⻆⾊：

- 服务提供者：提供接⼝供其它微服务访问，⽐如 item-service

- 服务消费者：调⽤其它微服务提供的接⼝，⽐如 cart-service

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204214650433-2025-2-422:22:06.png" alt="image-20250204214650433" style="zoom: 67%;" />

流程如下：

- 服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心
- 调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）
- 调用者自己对实例列表负载均衡，挑选一个实例
- 调用者向该实例发起远程调用

当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？

- 服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）
- 当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除
- 当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表
- 当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表

## 2.2、服务注册(Nacos注册中⼼)

把`item-service`注册到Nacos，步骤如下：

- 引入依赖
- 配置Nacos地址
- 重启

### 添加依赖

在`item-service`的`pom.xml`中添加依赖：

```XML
<!--nacos 服务注册发现-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

### 配置Nacos

在`item-service`的`application.yml`中添加nacos地址配置：

```YAML
spring:
  application:
    name: item-service # 服务名称
  cloud:
    nacos:
      server-addr: 192.168.181.100:8848 # nacos地址
```

### 启动服务实例

再配置一个`item-service`的部署实例，测试一个服务多个实例的情况。

重启`item-service`的两个实例，访问nacos控制台，可以发现服务注册成功：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215600470-2025-2-422:22:11.png" alt="image-20250204215600470" style="zoom:67%;" />

点击详情，可以查看到`item-service`服务的两个实例信息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215640696-2025-2-422:22:14.png" alt="image-20250204215640696" style="zoom:67%;" />

## 2.3、服务发现

服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：

- 引入依赖
- 配置Nacos地址
- 发现并调用服务

### 引入依赖

服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。

我们在`cart-service`中的`pom.xml`中添加下面的依赖：

```XML
<!--nacos 服务注册发现-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。

因此，等一会儿`cart-service`启动，同样会注册到Nacos

### 配置Nacos地址

在`cart-service`的`application.yml`中添加nacos地址配置：

```YAML
spring:
  cloud:
    nacos:
      server-addr: 192.168.150.101:8848
```

### 发现并调用服务

接下来，服务调用者`cart-service`就可以去订阅`item-service`服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。

因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：

- 随机
- 轮询
- IP的hash
- 最近最少访问
- ...

这里我们可以选择最简单的随机负载均衡。

另外，服务发现需要用到一个工具，`DiscoveryClient`，SpringCloud已经帮我们自动装配，我们可以直接注入使用

![image-20250204220132797](https://gitee.com/cmyk359/img/raw/master/img/image-20250204220132797-2025-2-422:22:20.png)

接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口。但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：

![image-20250204220208262](https://gitee.com/cmyk359/img/raw/master/img/image-20250204220208262-2025-2-422:22:22.png)



{% note warning%}

思考：当服务注册和发现中心宕机时，一个服务还能完成远程调用吗？

当一个服务首次发起远程调用时，会将服务中心返回的实例接口信息缓存下来，定期与服务中心交换这些服务的健康信息。此后再向相同服务发起调用时，会先从本地的缓存中获取对应接口信息，即使服务中心宕机，只要缓存信息有效，仍能完成远程调用。

若首次发起调用时服务中心就已经宕机，则得不到对应的服务信息，无法完成远程调用。

{% endnote%}

# 三、OpenFeign

之前利用RestTemplate实现了服务的远程调用，但是远程调用的代码太复杂了，而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。

因此，我们必须想办法改变远程调用的开发模式，让**远程调用像本地方法调用一样简单**。这就要用到**OpenFeign**组件了。

其实远程调用的关键点就在于四个：

- 请求方式
- 请求路径
- 请求参数
- 返回值类型

所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。

## 3.1、快速入门

### 引入依赖

在`cart-service`服务的pom.xml中引入`OpenFeign`的依赖和`loadBalancer`依赖：

```XML
  <!--openFeign-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-openfeign</artifactId>
  </dependency>
  <!--负载均衡器-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-loadbalancer</artifactId>
  </dependency>
```

### 启用OpenFeign

在`cart-service`的`CartApplication`启动类上添加注解，启动OpenFeign功能：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204221636625-2025-2-422:22:26.png" alt="image-20250204221636625" style="zoom:67%;" />

### 编写OpenFeign客户端

`cart-service`中，定义一个新的接口，编写Feign客户端：

```Java
package com.hmall.cart.client;

import com.hmall.cart.domain.dto.ItemDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@FeignClient("item-service")
public interface ItemClient {

    /**
     * 通过item-service服务，根据商品ids查询商品列表
     * @param ids
     * @return
     */
    @GetMapping("/items")
    //通过负载均衡获得一个服务实例，取得其ip地址和端口，再拼接上请求路径
    //声明请求参数为ids，并且设置返回数据类型为List<ItemDTO>
    List<ItemDTO> getItemsByIds(@RequestParam("ids")Collection<Long> ids);
}
```

这里只需要声明接口，无需实现方法。接口中的几个关键信息：

- `@FeignClient("item-service")` ：声明服务名称
- `@GetMapping` ：声明请求方式
- `@GetMapping("/items")` ：声明请求路径
- `@RequestParam("ids") Collection<Long> ids` ：声明请求参数
- `List<ItemDTO>` ：返回值类型

有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向`http://item-service/items`发送一个`GET`请求，携带ids为请求参数，并自动将返回值处理为`List<ItemDTO>`。

我们只需要直接调用这个方法，即可实现远程调用了。

### 使用FeignClient

在`cart-service`的`com.hmall.cart.service.impl.CartServiceImpl`中改造代码，直接调用`ItemClient`的方法：

![image-20250204222032840](https://gitee.com/cmyk359/img/raw/master/img/image-20250204222032840-2025-2-422:22:30.png)

feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作。到了这里，我们不再需要RestTemplate了

## 3.2、抽取Feign客⼾端

之后拆分了交易微服务（`trade-service`），它也需要远程调用`item-service`中的根据id批量查询商品功能。这个需求与`cart-service`中是一样的。

因此，我们就需要在`trade-service`中再次定义`ItemClient`接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？

避免重复编码的办法就是**抽取**。不过这里有两种抽取思路：

- 思路1：抽取到微服务之外的公共module
- 思路2：每个微服务自己抽取一个module

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222611291-2025-2-422:26:12.png" alt="image-20250204222611291" style="zoom:67%;" />

方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。

方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。

由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.

在 hmall 下定义⼀个新的module，命名为hm-api，然后把ItemDTO和ItemClient都拷⻉过来，最终结构如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222821911-2025-2-422:28:23.png" alt="image-20250204222821911" style="zoom:67%;" />

现在，**任何微服务要调⽤ item-service 中的接⼝，只需要引⼊ hm-api 模块依赖即可**，⽆需⾃⼰编写Feign客⼾端了。

在 cart-service 的 pom.xml 中引⼊ hm-api 模块，删除 cart-service 中原来的ItemDTO和ItemClient

```XML
  <!--feign模块-->
  <dependency>
      <groupId>com.heima</groupId>
      <artifactId>hm-api</artifactId>
      <version>1.0.0</version>
  </dependency>
```



因为 ItemClient 现在定义到了 com.hmall.api.client 包下，⽽cart-service的启动类定义在 com.hmall.cart 包下，扫描不到 ItemClient 。需要在cart-service的启动类上添加声明，有两种⽅式：

- 方式1：声明扫描包：

  ![image-20250204223136419](https://gitee.com/cmyk359/img/raw/master/img/image-20250204223136419-2025-2-422:31:55.png)

- 方式2：声明要用的FeignClient

  ![image-20250204223153546](https://gitee.com/cmyk359/img/raw/master/img/image-20250204223153546-2025-2-422:31:56.png)

## 3.3、配置连接池

Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：

- HttpURLConnection：默认实现，不支持连接池
- Apache HttpClient ：支持连接池
- OKHttp：支持连接池

我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.

### 引入依赖

在`cart-service`的`pom.xml`中引入依赖：

```XML
<!--OK http 的依赖 -->
<dependency>
  <groupId>io.github.openfeign</groupId>
  <artifactId>feign-okhttp</artifactId>
</dependency>
```

### 开启连接池

在`cart-service`的`application.yml`配置文件中开启Feign的连接池功能：

```YAML
feign:
  okhttp:
    enabled: true # 开启OKHttp功能
```

重启服务，连接池就生效了。

## 3.4、日志配置

OpenFeign只会在FeignClient所在包的日志级别为**DEBUG**时，才会输出日志。而且其日志级别有4级：

- **NONE**：不记录任何日志信息，这是默认值。
- **BASIC**：仅记录请求的方法，URL以及响应状态码和执行时间
- **HEADERS**：在BASIC的基础上，额外记录了请求和响应的头信息
- **FULL**：记录所有请求和响应的明细，包括头信息、请求体、元数据。

Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。

### 定义日志级别

在hm-api模块下新建一个配置类，定义Feign的日志级别：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204223617696-2025-2-422:36:18.png" alt="image-20250204223617696" style="zoom: 80%;" />

```Java
package com.hmall.api.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;

public class DefaultFeignConfig {
    @Bean
    public Logger.Level feignLogLevel(){
        return Logger.Level.FULL;
    }
}
```

### 配置

要让日志级别生效，还需要配置这个类。有两种方式：

- **局部**生效：在某个`FeignClient`中配置，只对当前`FeignClient`生效

```Java
@FeignClient(value = "item-service", configuration = DefaultFeignConfig.class)
```

- **全局**生效：在`@EnableFeignClients`中配置，针对所有`FeignClient`生效。

```Java
@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)
```



# 四、网关路由

## 4.1、认识网关

什么是网关？

顾明思议，网关就是**网**络的**关**口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的**路由****和转发以及数据安全的校验**。

更通俗的来讲，网关就像是以前园区传达室的大爷。

- 外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。
- 外面的人要传话或送信，要找大爷。大爷帮你带给目标人。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224124122-2025-2-422:41:41.png" alt="image-20250204224124122" style="zoom:80%;" />

现在，微服务网关就起到同样的作用。**前端请求不能直接访问微服务，而是要请求网关**：

- 网关可以做安全控制，也就是登录身份校验，校验通过才放行
- 通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224217779-2025-2-422:42:18.png" alt="image-20250204224217779" style="zoom:80%;" />

在SpringCloud当中，提供了两种网关实现方案：

- Netflix Zuul：早期实现，目前已经淘汰
- SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强。

## 4.2、快速入门

由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：

- 创建网关微服务
- 引入SpringCloudGateway、NacosDiscovery依赖
- 编写启动类
- 配置网关路由

### 创建项目

在hmall下创建一个新的module，命名为hm-gateway，作为网关微服务：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224406642-2025-2-422:44:07.png" alt="image-20250204224406642" style="zoom:67%;" />

### 引入依赖

在`hm-gateway`模块的`pom.xml`文件中引入依赖：

```XML
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>hmall</artifactId>
        <groupId>com.heima</groupId>
        <version>1.0.0</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>hm-gateway</artifactId>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <!--common-->
        <dependency>
            <groupId>com.heima</groupId>
            <artifactId>hm-common</artifactId>
            <version>1.0.0</version>
        </dependency>
        <!--网关-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--nacos discovery-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <!--负载均衡-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>
    </dependencies>
    <build>
        <finalName>${project.artifactId}</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### 添加启动类

在`hm-gateway`模块的`com.hmall.gateway`包下新建一个启动类：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224530813-2025-2-422:45:32.png" alt="image-20250204224530813" style="zoom:67%;" />

```Java
package com.hmall.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
```

### 配置路由

在`hm-gateway`模块的`resources`目录新建一个`application.yaml`文件，内容如下：

```YAML
server:
  port: 8080
spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: 192.168.150.101:8848
    gateway:
      routes:
        - id: item # 路由规则id，自定义，唯一
          uri: lb://item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表
          predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务
            - Path=/items/**,/search/** # 这里是以请求路径作为判断规则
        - id: cart
          uri: lb://cart-service
          predicates:
            - Path=/carts/**
        - id: user
          uri: lb://user-service
          predicates:
            - Path=/users/**,/addresses/**
        - id: trade
          uri: lb://trade-service
          predicates:
            - Path=/orders/**
        - id: pay
          uri: lb://pay-service
          predicates:
            - Path=/pay-orders/**
```

### 测试

启动GatewayApplication，以 http://localhost:8080 拼接微服务接口路径来测试。例如：

http://localhost:8080/items/page?pageNo=1&pageSize=1

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224842832-2025-2-422:48:48.png" alt="image-20250204224842832" style="zoom:80%;" />

此时，启动UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了

## 4.3、路由过滤

路由规则的定义语法如下：

```YAML
spring:
  cloud:
    gateway:
      routes:
        - id: item
          uri: lb://item-service
          predicates:
            - Path=/items/**,/search/**
```

其中routes对应的类型如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225046745-2025-2-422:50:47.png" alt="image-20250204225046745" style="zoom:80%;" />

是一个集合，也就是说可以定义很多路由规则。集合中的`RouteDefinition`就是具体的路由规则定义，其中常见的属性如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225120770-2025-2-422:51:21.png" alt="image-20250204225120770" style="zoom:80%;" />

四个属性含义如下：

- `id`：路由的唯一标示
- `predicates`：路由断言，其实就是匹配条件
- `filters`：路由过滤条件，后面讲
- `uri`：路由目标地址，`lb://`代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。

这里重点关注`predicates`，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：

| **名称**   | **说明**                       | **示例**                                                     |
| :--------- | :----------------------------- | :----------------------------------------------------------- |
| After      | 是某个时间点后的请求           | - After=2037-01-20T17:42:47.789-07:00[America/Denver]        |
| Before     | 是某个时间点之前的请求         | - Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]        |
| Between    | 是某两个时间点之前的请求       | - Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver] |
| Cookie     | 请求必须包含某些cookie         | - Cookie=chocolate, ch.p                                     |
| Header     | 请求必须包含某些header         | - Header=X-Request-Id, \d+                                   |
| Host       | 请求必须是访问某个host（域名） | - Host=**.somehost.org,**.anotherhost.org                    |
| Method     | 请求方式必须是指定方式         | - Method=GET,POST                                            |
| Path       | 请求路径必须符合指定规则       | - Path=/red/{segment},/blue/**                               |
| Query      | 请求参数必须包含指定参数       | - Query=name, Jack或者- Query=name                           |
| RemoteAddr | 请求者的ip必须是指定范围       | - RemoteAddr=192.168.1.1/24                                  |
| weight     | 权重处理                       |                                                              |

# 五、网关登录校验

单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。

## 5.1、鉴权思路分析

我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：

- 每个微服务都需要知道JWT的秘钥，不安全
- 每个微服务重复编写登录校验代码、权限校验代码，麻烦

既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：

- 只需要在网关和用户服务保存秘钥
- 只需要在网关开发登录校验功能

此时，登录校验的流程如图：

![image-20250204225509082](https://gitee.com/cmyk359/img/raw/master/img/image-20250204225509082-2025-2-422:55:54.png)

不过，这里存在几个问题：

- 网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？
- 网关校验JWT之后，如何将用户信息传递给微服务？
- 微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？

这些问题将在接下来一一解决。

## 5.2、网关过滤器

登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是`Gateway`内部代码实现的，要想在请求转发之前做登录校验，就必须了解`Gateway`内部工作的基本原理。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225812687-2025-2-422:58:13.png" alt="image-20250204225812687" style="zoom:70%;" />

如图所示：

1. 客户端请求进入网关后由`HandlerMapping`对请求做判断，找到与当前请求匹配的路由规则（**`Route`**），然后将请求交给`WebHandler`去处理。
2. `WebHandler`则会加载当前路由下需要执行的过滤器链（**`Filter chain`**），然后按照顺序逐一执行过滤器（后面称为**`Filter`**）。
3. 图中`Filter`被虚线分为左右两部分，是因为`Filter`内部的逻辑分为`pre`和`post`两部分，分别会在请求路由到微服务**之前**和**之后**被执行。
4. 只有所有`Filter`的`pre`逻辑都依次顺序执行通过后，请求才会被路由到微服务。
5. 微服务返回结果后，再倒序执行`Filter`的`post`逻辑。
6. 最终把响应结果返回。

如图中所示，最终请求转发是有一个名为`NettyRoutingFilter`的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。**如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到`NettyRoutingFilter`之前**，这就符合我们的需求了！

那么，该如何实现一个网关过滤器呢？

网关过滤器链中的过滤器有两种：

- **`GatewayFilter`**：路由过滤器，作用范围比较灵活，可以是任意指定的路由`Route`. 
- **`GlobalFilter`**：全局过滤器，作用范围是所有路由，不可配置。

> **注意**：过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务

其实`GatewayFilter`和`GlobalFilter`这两种过滤器的方法签名完全一致：

```Java
/**
 * 处理请求并将其传递给下一个过滤器
 * @param exchange 当前请求的上下文，其中包含request、response等各种数据
 * @param chain 过滤器链，基于它向下传递请求
 * @return 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。
 */
Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
```

`FilteringWebHandler`在处理请求时，会将`GlobalFilter`装饰为`GatewayFilter`，然后放到同一个过滤器链中，排序以后依次执行。

`Gateway`内置的`GatewayFilter`过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个`Route`下，就作用于哪个`Route`.

例如，有一个过滤器叫做`AddRequestHeaderGatewayFilterFacotry`，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。

使用的使用只需要在application.yaml中这样配置：

```YAML
spring:
  cloud:
    gateway:
      routes:
      - id: test_route
        uri: lb://test-service
        predicates:
          -Path=/test/**
        filters:
          - AddRequestHeader=key, value # 逗号之前是请求头的key，逗号之后是value
```

如果想要让过滤器作用于所有的路由，则可以这样配置：

```YAML
spring:
  cloud:
    gateway:
      default-filters: # default-filters下的过滤器可以作用于所有路由
        - AddRequestHeader=key, value
      routes:
      - id: test_route
        uri: lb://test-service
        predicates:
          -Path=/test/**
```

## 5.3、自定义过滤器

无论是`GatewayFilter`还是`GlobalFilter`都支持自定义，只不过**编码**方式、**使用**方式略有差别。

### 自定义GatewayFilter

自定义`GatewayFilter`不是直接实现`GatewayFilter`，而是实现`AbstractGatewayFilterFactory`。最简单的方式是这样的：

```Java
@Component
public class PrintAnyGatewayFilterFactory extends AbstractGatewayFilterFactory<Object> {
    @Override
    public GatewayFilter apply(Object config) {
        return new GatewayFilter() {
            @Override
            public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                // 获取请求
                ServerHttpRequest request = exchange.getRequest();
                // 编写过滤器逻辑
                System.out.println("过滤器执行了");
                // 放行
                return chain.filter(exchange);
            }
        };
    }
}
```

> **注意**：该类的名称一定要以`GatewayFilterFactory`为后缀！

然后在yaml配置中这样使用：

```YAML
spring:
  cloud:
    gateway:
      default-filters:
            - PrintAny # 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器
```

另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：

```Java
@Component
public class PrintAnyGatewayFilterFactory // 父类泛型是内部类的Config类型
                extends AbstractGatewayFilterFactory<PrintAnyGatewayFilterFactory.Config> {

    @Override
    public GatewayFilter apply(Config config) {
        // OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：
        // - GatewayFilter：过滤器
        // - int order值：值越小，过滤器执行优先级越高
        return new OrderedGatewayFilter(new GatewayFilter() {
            @Override
            public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
                // 获取config值
                String a = config.getA();
                String b = config.getB();
                String c = config.getC();
                // 编写过滤器逻辑
                System.out.println("a = " + a);
                System.out.println("b = " + b);
                System.out.println("c = " + c);
                // 放行
                return chain.filter(exchange);
            }
        }, 100);
    }

    // 自定义配置属性，成员变量名称很重要，下面会用到
    @Data
    static class Config{
        private String a;
        private String b;
        private String c;
    }
    // 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取
    @Override
    public List<String> shortcutFieldOrder() {
        return List.of("a", "b", "c");
    }
        // 返回当前配置类的类型，也就是内部的Config
    @Override
    public Class<Config> getConfigClass() {
        return Config.class;
    }

}
```

然后在yaml文件中使用：

```YAML
spring:
  cloud:
    gateway:
      default-filters:
            - PrintAny=1,2,3 # 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制
```

上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。

还有一种用法，无需按照这个顺序，就是手动指定参数名：

```YAML
spring:
  cloud:
    gateway:
      default-filters:
            - name: PrintAny
              args: # 手动指定参数名，无需按照参数顺序
                a: 1
                b: 2
                c: 3
```

### 自定义GlobalFilter

自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：

```Java
@Component
public class PrintAnyGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 编写过滤器逻辑
        System.out.println("未登录，无法访问");
        // 放行
        // return chain.filter(exchange);

        // 拦截
        ServerHttpResponse response = exchange.getResponse();
        response.setRawStatusCode(401);
        return response.setComplete();
    }

    @Override
    public int getOrder() {
        // 过滤器执行顺序，值越小，优先级越高
        return 0;
    }
}
```

## 5.4、登录校验

利用自定义`GlobalFilter`来完成登录校验。

### JWT工具

登录校验需要用到JWT，而且JWT的加密需要秘钥和加密工具。这些在`hm-service`中已经有了，我们直接拷贝过来：

![image-20250204230713436](https://gitee.com/cmyk359/img/raw/master/img/image-20250204230713436-2025-2-423:07:34.png)

具体作用如下：

- `AuthProperties`：配置登录校验需要拦截的路径，因为不是所有的路径都需要登录才能访问
- `JwtProperties`：定义与JWT工具有关的属性，比如秘钥文件位置
- `SecurityConfig`：工具的自动装配
- `JwtTool`：JWT工具，其中包含了校验和解析`token`的功能
- `hmall.jks`：秘钥文件

其中`AuthProperties`和`JwtProperties`所需的属性要在`application.yaml`中配置：

```YAML
hm:
  jwt:
    location: classpath:hmall.jks # 秘钥地址
    alias: hmall # 秘钥别名
    password: hmall123 # 秘钥文件密码
    tokenTTL: 30m # 登录有效期
  auth:
    excludePaths: # 无需登录校验的路径
      - /search/**
      - /users/login
      - /items/**
```

### 登录校验过滤器

接下来，我们定义一个登录校验的过滤器：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204230850859-2025-2-423:08:52.png" alt="image-20250204230850859" style="zoom:80%;" />

代码如下：

```Java
package com.hmall.gateway.filter;

import com.hmall.common.exception.UnauthorizedException;
import com.hmall.common.utils.CollUtils;
import com.hmall.gateway.config.AuthProperties;
import com.hmall.gateway.util.JwtTool;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.List;

@Component
@RequiredArgsConstructor
@EnableConfigurationProperties(AuthProperties.class)
public class AuthGlobalFilter implements GlobalFilter, Ordered {

    private final JwtTool jwtTool;

    private final AuthProperties authProperties;

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1.获取Request
        ServerHttpRequest request = exchange.getRequest();
        // 2.判断是否不需要拦截
        if(isExclude(request.getPath().toString())){
            // 无需拦截，直接放行
            return chain.filter(exchange);
        }
        // 3.获取请求头中的token
        String token = null;
        List<String> headers = request.getHeaders().get("authorization");
        if (!CollUtils.isEmpty(headers)) {
            token = headers.get(0);
        }
        // 4.校验并解析token
        Long userId = null;
        try {
            userId = jwtTool.parseToken(token);
        } catch (UnauthorizedException e) {
            // 如果无效，拦截
            ServerHttpResponse response = exchange.getResponse();
            response.setRawStatusCode(401);
            return response.setComplete();
        }

        // TODO 5.如果有效，传递用户信息
        System.out.println("userId = " + userId);
        // 6.放行
        return chain.filter(exchange);
    }

    private boolean isExclude(String antPath) {
        for (String pathPattern : authProperties.getExcludePaths()) {
            if(antPathMatcher.match(pathPattern, antPath)){
                return true;
            }
        }
        return false;
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

  重启测试，会发现访问/items开头的路径，未登录状态下不会被拦截。访问其他路径则，未登录状态下请求会被拦截，并且返回`401`状态码。

## 5.5、微服务获取用户

现在，网关已经可以完成登录校验并获取登录用户身份信息。但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？

由于网关发送请求到微服务依然采用的是`Http`请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。

处理流程如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231322595-2025-2-423:13:25.png" alt="image-20250204231322595" style="zoom:80%;" />

因此，接下来我们要做的事情有：

- 改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务
- 编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行

### 保存用户到请求头

首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：

![image-20250204231454706](https://gitee.com/cmyk359/img/raw/master/img/image-20250204231454706-2025-2-423:14:55.png)

### 拦截器获取用户

在hm-common中已经有一个用于保存登录用户的ThreadLocal工具，其中已经提供了保存和获取用户的方法：

![image-20250204231715841](https://gitee.com/cmyk359/img/raw/master/img/image-20250204231715841-2025-2-423:17:17.png)

接下来，我们只需要编写拦截器，获取用户信息并保存到`UserContext`，然后放行即可。

由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在`hm-common`中，并写好自动装配。这样微服务只需要引入`hm-common`就可以直接具备拦截器功能，无需重复编写。

在`hm-common`模块下定义一个拦截器：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231841138-2025-2-423:18:47.png" alt="image-20250204231841138" style="zoom:80%;" />

具体代码如下：

```Java
package com.hmall.common.interceptor;

import cn.hutool.core.util.StrUtil;
import com.hmall.common.utils.UserContext;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UserInfoInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1.获取请求头中的用户信息
        String userInfo = request.getHeader("user-info");
        // 2.判断是否为空
        if (StrUtil.isNotBlank(userInfo)) {
            // 不为空，保存到ThreadLocal
                UserContext.setUser(Long.valueOf(userInfo));
        }
        // 3.放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserContext.removeUser();
    }
}
```

接着在`hm-common`模块下编写`SpringMVC`的配置类，配置登录拦截器：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231943536-2025-2-423:19:44.png" alt="image-20250204231943536" style="zoom:80%;" />

具体代码如下：

```Java
package com.hmall.common.config;

import com.hmall.common.interceptors.UserInfoInterceptor;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@ConditionalOnClass(DispatcherServlet.class)
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new UserInfoInterceptor());
    }
}
```



> 不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是com.hmall.common.config，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。
> 基于SpringBoot的自动装配原理，我们要将其添加到resources目录下的META-INF/spring.factories文件中：
>
> <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232123922-2025-2-423:21:25.png" alt="image-20250204232123922" style="zoom:72%;" />
>
> 内容如下：
>
> ```Properties
> org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
>   com.hmall.common.config.MyBatisConfig,\
>   com.hmall.common.config.MvcConfig
> ```
> 

## 5.6、OpenFeign传递用户

前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。

但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232321363-2025-2-423:23:22.png" alt="image-20250204232321363" style="zoom:80%;" />

下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，**订单服务调用购物车时并没有传递用户信息**，购物车服务无法知道当前用户是谁！

由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就**必须在微服务发起调用时把用户信息存入请求头**。

微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？

这里要借助Feign中提供的一个拦截器接口：`feign.RequestInterceptor`

```Java
public interface RequestInterceptor {

  /**
   * Called for every request. 
   * Add data using methods on the supplied {@link RequestTemplate}.
   */
  void apply(RequestTemplate template);
}
```

我们只需要实现这个接口，然后实现apply方法，利用`RequestTemplate`类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。

在`hm-api`模块的`com.hmall.api.config.DefaultFeignConfig`中编写这个拦截器：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232548649-2025-2-423:25:57.png" alt="image-20250204232548649" style="zoom:80%;" />

在`com.hmall.api.config.DefaultFeignConfig`中添加一个Bean：

```Java
@Bean
public RequestInterceptor userInfoRequestInterceptor(){
    return new RequestInterceptor() {
        @Override
        public void apply(RequestTemplate template) {
            // 获取登录用户
            Long userId = UserContext.getUser();
            if(userId == null) {
                // 如果为空则直接跳过
                return;
            }
            // 如果不为空则放入请求头中，传递给下游微服务
            template.header("user-info", userId.toString());
        }
    };
}
```

现在微服务之间通过OpenFeign调用时也会传递登录用户信息了。（其实就是拦截下来OpenFeign的转发请求，然后再请求头中添加上user-info字段后放行）

# 六、配置管理

到目前为止我们已经解决了微服务相关的几个问题：

- 微服务远程调用
- 微服务注册、发现
- 微服务请求路由、负载均衡
- 微服务登录用户信息传递

不过，现在依然还有几个问题需要解决：

- 网关路由在配置文件中写死了，如果变更必须重启微服务
- 某些业务配置在配置文件中写死了，每次修改都要重启服务
- 每个微服务都有很多重复的配置，维护成本高

这些问题都可以通过统一的**配置管理器服务**解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232913465-2025-2-423:29:14.png" alt="image-20250204232913465" style="zoom:80%;" />

微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。

网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。

{% note warning%}

当本地配置文件内容和Nacos中的配置相同时哪个生效？若从Nacos中导入多个配置文件，其中有的配置重复，哪个生效？

遵守一个原则：外部优先，先导入优先。

当本地配置与Nacos配置冲突时，以外部导入的Nacos配置为准；当多个配置文件中的配置冲突时，以先导入的配置为准。

{% endnote%}

## 6.1、配置共享

我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：

- 在Nacos中添加共享配置
- 微服务拉取配置

### 添加共享配置

以cart-service为例，我们看看有哪些配置是重复的，可以抽取的：

首先是jdbc相关配置：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233045536-2025-2-423:30:46.png" alt="image-20250204233045536" style="zoom:80%;" />

然后是日志配置：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233111051-2025-2-423:31:12.png" alt="image-20250204233111051" style="zoom:80%;" />

然后是swagger以及OpenFeign的配置：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233147280-2025-2-423:31:48.png" alt="image-20250204233147280" style="zoom:80%;" />

在nacos控制台分别添加这些配置，首先是jdbc相关配置，在`配置管理`->`配置列表`中点击`+`新建一个配置：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233329924-2025-2-423:33:30.png" alt="image-20250204233329924" style="zoom:80%;" />

在弹出的表单中填写信息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233423314-2025-2-423:34:42.png" alt="image-20250204233423314" style="zoom:80%;" />

其中详细的配置如下：

```YAML
spring:
  datasource:
    url: jdbc:mysql://${hm.db.host:192.168.150.101}:${hm.db.port:3306}/${hm.db.database}?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: ${hm.db.un:root}
    password: ${hm.db.pw:123}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto
```

注意这里的jdbc的相关参数并没有写死，例如：

- `数据库ip`：通过`${hm.db.host:192.168.150.101}`配置了默认值为`192.168.150.101`，同时允许通过`${hm.db.host}`来覆盖默认值
- `数据库端口`：通过`${hm.db.port:3306}`配置了默认值为`3306`，同时允许通过`${hm.db.port}`来覆盖默认值
- `数据库database`：可以通过`${hm.db.database}`来设定，无默认值

然后是统一的日志配置，命名为`shared-log.yaml`，配置内容如下：

```YAML
logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"
```

然后是统一的swagger配置，命名为`shared-swagger.yaml`，配置内容如下：

```YAML
knife4j:
  enable: true
  openapi:
    title: ${hm.swagger.title:黑马商城接口文档}
    description: ${hm.swagger.description:黑马商城接口文档}
    email: ${hm.swagger.email:zhanghuyi@itcast.cn}
    concat: ${hm.swagger.concat:虎哥}
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - ${hm.swagger.package}
```

注意，这里的swagger相关配置我们没有写死，例如：

- `title`：接口文档标题，我们用了`${hm.swagger.title}`来代替，将来可以用由户手动指定
- `email`：联系人邮箱，我们用了`${hm.swagger.email:``zhanghuyi@itcast.cn``}`，默认值是`zhanghuyi@itcast.cn`，同时允许用户利用`${hm.swagger.email}`来覆盖。

### 拉取共享配置

{% note info%}

更新：springboot >= 2.4.0版本，已经不使用bootstrap.yml作为启动配置文件了，参考：[#2905](https://github.com/alibaba/spring-cloud-alibaba/issues/2905)，确有必要时，需主动加入依赖spring-cloud-starter-bootstrap包。

Nacos也支持使用`spring.config.import`直接导入配置文件

```yaml
spring:
  config:
    import:
      - nacos:xxxx.yaml?group="分组"
      - nacos:xxxx.yaml?group="分组"
```

或者

```properties
spring.config.import[0]=nacos:springclouddemo2023x.properties?group=DEFAULT_GROUP
spring.config.import[1]=nacos:{dataId1}?group={group1}
spring.config.import[2]=nacos:{dataId2}?group={group2}
```

[参考](https://nacos.io/docs/v2.5/ecology/use-nacos-with-spring-cloud/#_top)

{% endnote%}

接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的`application.yaml`配置合并，完成项目上下文的初始化。

不过，需要注意的是，读取Nacos配置是SpringCloud上下文（`ApplicationContext`）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取`application.yaml`。

也就是说引导阶段，`application.yaml`文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？

SpringCloud在初始化上下文的时候会先读取一个名为`bootstrap.yaml`(或者`bootstrap.properties`)的文件，如果我们将nacos地址配置到`bootstrap.yaml`中，那么在项目引导阶段就可以读取nacos中的配置了。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233717814-2025-2-423:37:18.png" alt="image-20250204233717814" style="zoom: 80%;" />

因此，微服务整合Nacos配置管理的步骤如下，以cart-service微服务为例：

1）引入依赖：

在cart-service模块引入依赖：

```XML
  <!--nacos配置管理-->
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
  </dependency>
  <!--读取bootstrap文件-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-bootstrap</artifactId>
  </dependency>
```

2）新建bootstrap.yaml

在cart-service中的resources目录新建一个bootstrap.yaml文件：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101329880-2025-2-510:13:55.png" alt="image-20250205101329880" style="zoom:80%;" />

内容如下：

```YAML
spring:
  application:
    name: cart-service # 服务名称
  profiles:
    active: dev
  cloud:
    nacos:
      server-addr: 192.168.150.101 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
        shared-configs: # 共享配置
          - dataId: shared-jdbc.yaml # 共享mybatis配置
          - dataId: shared-log.yaml # 共享日志配置
          - dataId: shared-swagger.yaml # 共享日志配置
```

3）修改application.yaml

由于一些配置挪到了bootstrap.yaml，因此application.yaml需要修改为：

```YAML
server:
  port: 8082
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
hm:
  swagger:
    title: 购物车服务接口文档
    package: com.hmall.cart.controller
  db:
    database: hm-cart
```

重启服务，发现所有配置都生效了。

## 6.2、配置热更新

有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10。

![image-20250205101710519](https://gitee.com/cmyk359/img/raw/master/img/image-20250205101710519-2025-2-510:17:11.png)

现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。

但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？

这就要用到Nacos的配置热更新能力了，分为两步：

- 在Nacos中添加配置
- 在微服务读取配置

### 添加配置到Nacos

首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101836988-2025-2-510:18:38.png" alt="image-20250205101836988" style="zoom:80%;" />

注意文件的dataId格式：

```Plain
[服务名]-[spring.active.profile].[后缀名]
```

文件名称由三部分组成：

- **`服务名`**：当前是购物车服务，所以是`cart-service`
- **`spring.active.profile`**：就是spring boot中的`spring.active.profile`，可以省略，则所有profile共享该配置
- **`后缀名`**：例如yaml

这里我们直接使用`cart-service.yaml`这个名称，则不管是dev还是local环境都可以共享该配置。

配置内容如下：

```YAML
hm:
  cart:
    maxAmount: 1 # 购物车商品数量上限
```

### 配置热更新

接着，我们在微服务中读取配置，实现配置热更新。

在`cart-service`中新建一个属性读取类：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102028361-2025-2-510:20:31.png" alt="image-20250205102028361" style="zoom:80%;" />

代码如下：

```Java
package com.hmall.cart.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "hm.cart")  //配置批量绑定
public class CartProperties {
    private Integer maxAmount;
}
```

接着，在业务中使用该属性加载类：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102151605-2025-2-510:22:12.png" alt="image-20250205102151605" style="zoom:80%;" />

### 测试

测试，向购物车中添加多个商品：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102318787-2025-2-510:23:19.png" alt="image-20250205102318787" style="zoom:80%;" />

我们在nacos控制台，将购物车上限配置为5：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102409302-2025-2-510:24:10.png" alt="image-20250205102409302" style="zoom:80%;" />

无需重启，再次测试购物车功能：

![image-20250205102440893](https://gitee.com/cmyk359/img/raw/master/img/image-20250205102440893-2025-2-510:24:42.png)

加入成功！

无需重启服务，配置热更新就生效了！

## 6.3、数据隔离

需求描述：

- 项目有多套环境：dev，test，prod
- 每个微服务，同一种配置，在每套环境的值都不一样。
  - 如：datbase.properties
  - 如：common.properties·

- 项目可以通过切换环境，加载本环境的配置

那么如何区分多套环境、多种微服务、多种配置呢？

Nacos中的命名空间可以用来区分各种环境；每个命名空间中可以定义多个组，可以用来区分多个微服务；每个组中可以存在多个配置文件，作为该微服务的各种配置。

<img src="https://gitee.com/cmyk359/img/raw/c63a587dec6aad303020e9c189bd2b1b9544518b/img/image-20250708211528653-2025-7-821:15:30.png" style="zoom:80%;" />



比如：对应订单微服务，总共有三个环境：dev、test、prod，在不同环境中导入的配置文件也不同。具体配置如下：使用`profiles.active`指定当前所处的环境，连接Nacos配置中心时引用该配置的值，进入对应的命名空间（环境）。写三套配置，使用`activate.on-profile`指定当前配置在哪个环境下生效。

```yaml
spring:
  profiles:
    active: dev  #指定当前环境
  application:
    name: service-order
  cloud:
    nacos:
      server-addr: 192.168.181.100:8848
      config:
        namespace: ${spring.profiles.active:public}

---
spring:
  config:
    import:
      ##导入order分组（order微服务）的相关配置文件
      - nacos:shared-jdbc.yaml?group=order
      - nacos:shared-common.yaml?group=order
    activate:
      on-profile: dev # dev环境下生效
---
spring:
  config:
    import:
      ##导入order分组（order微服务）的相关配置文件
      - nacos:shared-jdbc.yaml?group=order
      - nacos:shared-common.yaml?group=order
      - nacos:service-order.yaml?group=order
    activate:
      on-profile: test # test环境下生效
---
spring:
  config:
    import:
      ##导入order分组（order微服务）的相关配置文件
      - nacos:service-order.yaml?group=order
    activate:
      on-profile: prod # prod环境下生效
```



## 6.4、动态路由

网关的路由配置全部是在项目启动时由`org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator`在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，无法利用之前的配置热更新来实现路由更新。

因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：

- 如何监听Nacos配置变更？
- 如何把路由信息更新到路由表？

### 监听Nacos配置变更

在Nacos官网中给出了手动监听Nacos配置变更的[SDK](https://nacos.io/zh-cn/docs/sdk.html)

如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。

```Java
public void addListener(String dataId, String group, Listener listener)
```

请求参数说明：

| **参数名** | **参数类型** | **描述**                                                     |
| :--------- | :----------- | :----------------------------------------------------------- |
| dataId     | string       | 配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（"."、":"、"-"、"_"）。不超过 256 字节。 |
| group      | string       | 配置分组，一般是默认的DEFAULT_GROUP。                        |
| listener   | Listener     | 监听器，配置变更进入监听器的回调函数。                       |

示例代码：

```Java
String serverAddr = "{serverAddr}";
String dataId = "{dataId}";
String group = "{group}";
// 1.创建ConfigService，连接Nacos
Properties properties = new Properties();
properties.put("serverAddr", serverAddr);
ConfigService configService = NacosFactory.createConfigService(properties);
// 2.读取配置
String content = configService.getConfig(dataId, group, 5000);
// 3.添加配置监听器
configService.addListener(dataId, group, new Listener() {
        @Override
        public void receiveConfigInfo(String configInfo) {
        // 配置变更的通知处理
                System.out.println("recieve1:" + configInfo);
        }
        @Override
        public Executor getExecutor() {
                return null;
        }
});
```

由于我们采用了`spring-cloud-starter-alibaba-nacos-config`自动装配，因此`ConfigService`已经在`com.alibaba.cloud.nacos.NacosConfigAutoConfiguration`中自动创建好了：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104346165-2025-2-510:43:47.png" alt="image-20250205104346165" style="zoom:80%;" />

因此，只要我们拿到`NacosConfigManager`就等于拿到了`ConfigService`，第一步就实现了

第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：

```Java
String getConfigAndSignListener(
    String dataId, // 配置文件id
    String group, // 配置组，走默认
    long timeoutMs, // 读取配置的超时时间
    Listener listener // 监听器
) throws NacosException;
```

既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。

### 更新路由

更新路由要用到`org.springframework.cloud.gateway.route.RouteDefinitionWriter`这个接口：

```Java
package org.springframework.cloud.gateway.route;

import reactor.core.publisher.Mono;

/**
 * @author Spencer Gibb
 */
public interface RouteDefinitionWriter {
        /**
     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由
     */
        Mono<Void> save(Mono<RouteDefinition> route);
        /**
     * 根据路由id删除某个路由
     */
        Mono<Void> delete(Mono<String> routeId);

}
```

这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：

- id：路由id
- predicates：路由匹配规则
- filters：路由过滤器
- uri：路由目的地

将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：

```JSON
{
  "id": "item",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}
  }],
  "filters": [],
  "uri": "lb://item-service"
}
```

以上JSON配置就等同于：

```YAML
spring:
  cloud:
    gateway:
      routes:
        - id: item
          uri: lb://item-service
          predicates:
            - Path=/items/**,/search/**
```

### 实现动态路由

首先， 我们在网关gateway引入依赖：

```XML
<!--统一配置管理-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
<!--加载bootstrap-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```

然后在网关`gateway`的`resources`目录创建`bootstrap.yaml`文件，内容如下：

```YAML
spring:
  application:
    name: gateway
  cloud:
    nacos:
      server-addr: 192.168.150.101
      config:
        file-extension: yaml
        shared-configs:
          - dataId: shared-log.yaml # 共享日志配置
```

接着，修改`gateway`的`resources`目录下的`application.yml`，把之前的路由移除，最终内容如下：

```YAML
server:
  port: 8080 # 端口
hm:
  jwt:
    location: classpath:hmall.jks # 秘钥地址
    alias: hmall # 秘钥别名
    password: hmall123 # 秘钥文件密码
    tokenTTL: 30m # 登录有效期
  auth:
    excludePaths: # 无需登录校验的路径
      - /search/**
      - /users/login
      - /items/**
```

然后，在`gateway`中定义配置监听器：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104818068-2025-2-510:48:31.png" alt="image-20250205104818068" style="zoom:80%;" />

其代码如下：

```Java
package com.hmall.gateway.routers;


import cn.hutool.json.JSONUtil;
import com.alibaba.cloud.nacos.NacosConfigManager;
import com.alibaba.nacos.api.config.listener.Listener;
import com.alibaba.nacos.api.exception.NacosException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.route.RouteDefinition;
import org.springframework.cloud.gateway.route.RouteDefinitionWriter;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import javax.annotation.PostConstruct;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executor;

@Component
@Slf4j
@RequiredArgsConstructor
public class DynamicRouteLoader {
    private final NacosConfigManager configManager;
    private final String dataId = "gateway-routes.json";
    private final String group = "DEFAULT_GROUP";
    private final RouteDefinitionWriter writer; //用来更新路由信息
    private final Set<String> routeIds = new HashSet<>();


    @PostConstruct //添加了该注解的方法，在当前这个bean初始化后执行
    public void initRouteConfigListener() throws NacosException {
        //1.项目启动时，先拉取初始配置，并且添加监听器
        String originConfigInfo = configManager.getConfigService()
                .getConfigAndSignListener(dataId, group, 5000, new Listener() {
                    @Override
                    public Executor getExecutor() { //返回一个线程池，由这个线程池执行
                        return null;
                    }

                    @Override
                    public void receiveConfigInfo(String configInfo) {
                        //2.监听到配置变更，更新路由表
                        updateConfigInfo(configInfo);
                    }
                });
        //3.第一次拉取到的配置，更新至路由表
        updateConfigInfo(originConfigInfo);
    }

    public void updateConfigInfo(String configInfo) {
        log.info("监听到路由信息变更：{}",configInfo);
        //1.解析配置文件，转化为RouteDefinition的对象列表
        List<RouteDefinition> routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);

        //2.删除原有的路由信息
        for (String routeId: routeIds) {
            writer.delete(Mono.just(routeId)).subscribe();
        }
        routeIds.clear();

        //3.更新路由信息
        for (RouteDefinition routeDefinition: routeDefinitions) {
            //3.1更新路由表
            writer.save(Mono.just(routeDefinition)).subscribe();
            //3.2 记录路由id，便于下次更新时删除
            routeIds.add(routeDefinition.getId());
        }
    }
}

```
重启网关，任意访问一个接口。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105231420-2025-2-510:52:57.png" alt="image-20250205105231420" style="zoom:80%;" />

发现是404，无法访问。

接下来，直接在Nacos控制台添加路由，路由文件名为gateway-routes.json，类型为json：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105106335-2025-2-510:51:31.png" alt="image-20250205105106335" style="zoom:80%;" />

配置内容如下：

```JSON
[
    {
        "id": "item",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/items/**", "_genkey_1":"/search/**"}
        }],
        "filters": [],
        "uri": "lb://item-service"
    },
    {
        "id": "cart",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/carts/**"}
        }],
        "filters": [],
        "uri": "lb://cart-service"
    },
    {
        "id": "user",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/users/**", "_genkey_1":"/addresses/**"}
        }],
        "filters": [],
        "uri": "lb://user-service"
    },
    {
        "id": "trade",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/orders/**"}
        }],
        "filters": [],
        "uri": "lb://trade-service"
    },
    {
        "id": "pay",
        "predicates": [{
            "name": "Path",
            "args": {"_genkey_0":"/pay-orders/**"}
        }],
        "filters": [],
        "uri": "lb://pay-service"
    }
]
```

无需重启网关，稍等几秒钟后，再次访问刚才的地址：
<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105326278-2025-2-510:53:27.png" alt="image-20250205105326278" style="zoom:80%;" />网关路由成功了！

# 七、微服务保护

在微服务远程调用的过程中，还存在几个问题需要解决。

首先是**业务健壮性**问题：

例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。

还有**级联失败**问题：

还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。

此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105935054-2025-2-510:59:49.png" alt="image-20250205105935054" style="zoom:80%;" />

依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。这就是**级联失败**问题，或者叫**雪崩**问题。

保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。

## 7.1、微服务保护方案

微服务保护的方案有很多，比如：

- 请求限流
- 线程隔离
- 服务熔断

这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务**降级**的方案。但通过这些方案，服务的健壮性得到了提升。

接下来，就逐一了解这些方案的原理。

### 请求限流

服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是**限制或控制**接口访问的并发流量，避免服务因流量激增而出现故障。

请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110306722-2025-2-511:03:07.png" alt="image-20250205110306722" style="zoom:80%;" />

### 线程隔离

当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。

线程隔离的思想来自轮船的舱壁模式：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110405106-2025-2-511:04:06.png" alt="image-20250205110405106" style="zoom:80%;" />

轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没。

为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110450434-2025-2-511:04:51.png" alt="image-20250205110450434" style="zoom:80%;" />

如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。

### 服务熔断

线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。

所以，我们要做两件事情：

- **编写服务降级逻辑**：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。
- **异常统计和熔断**：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110603765-2025-2-511:06:16.png" alt="image-20250205110603765" style="zoom:80%;" />

## 7.2、Sentinel

微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel。

### 介绍和安装

Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。[官方网站](https://sentinelguard.io/zh-cn/)

Sentinel 的使用可以分为两个部分:

- **核心库**（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。
- **控制台**（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。

为了方便监控微服务，我们先把Sentinel的控制台搭建出来。

1）下载jar包

[下载地址](https://github.com/alibaba/Sentinel/releases)

运行

2）运行

将jar包放在任意非中文、不包含特殊字符的目录下，重命名为`sentinel-dashboard.jar`。

然后运行如下命令启动控制台：

```Shell
java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
```

其它启动时可配置参数可参考[官方文档](https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9)

3）访问

访问[http://localhost:8090](http://localhost:8080)页面，就可以看到sentinel的控制台了：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111017652-2025-2-511:10:18.png" alt="image-20250205111017652" style="zoom:80%;" />

需要输入账号和密码，默认都是：sentinel

登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111102271-2025-2-511:11:03.png" alt="image-20250205111102271" style="zoom:80%;" />

> 注：sentinel 必须跟微服务处在同一个网络中。

### 微服务整合

我们在`cart-service`模块中整合sentinel，连接`sentinel-dashboard`控制台，步骤如下： 

1）引入sentinel依赖

```XML
<!--sentinel-->
<dependency>
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

2）配置控制台

修改application.yaml文件，添加下面内容：

```YAML
spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090
```

3）访问`cart-service`的任意端点

重启`cart-service`，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到`sentinel-dashboard`控制台。并展示出统计信息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111425351-2025-2-511:14:31.png" alt="image-20250205111425351" style="zoom:80%;" />

点击簇点链路菜单，会看到下面的页面：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111507034-2025-2-511:15:31.png" alt="image-20250205111507034" style="zoom:80%;" />

在微服务架构中，服务之间通过网络通信互相调用形成了一条条调用链路，每个服务节点都可以看作是这条链路上的一个“簇点”。所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被`Sentinel`监控的资源。默认情况下，`Sentinel`会监控`SpringMVC`的每一个`Endpoint`（controller接口）。

不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是`/carts`路径：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111731892-2025-2-511:17:33.png" alt="image-20250205111731892" style="zoom:80%;" />

默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。

所以我们可以选择打开Sentinel的请求方式前缀，把`请求方式 + 请求路径`作为簇点资源名：

首先，在`cart-service`的`application.yml`中添加下面的配置：

```YAML
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
      http-method-specify: true # 开启请求方式前缀
```

然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111828535-2025-2-511:18:29.png" alt="image-20250205111828535" style="zoom:80%;" />

### 请求限流实现

在簇点链路后面点击流控按钮，即可对其做限流配置：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101535636-2025-2-610:15:47.png" alt="image-20250206101535636" style="zoom:80%;" />

在弹出的菜单中这样填写：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101620493-2025-2-610:16:21.png" style="zoom:80%;" />

这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.

我们利用Jemeter做限流测试，我们每秒发出10个请求：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101640224-2025-2-610:16:41.png" style="zoom:80%;" />

最终监控结果如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101658752-2025-2-610:16:59.png" style="zoom:80%;" />

可以看出`GET:/carts`这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合我们的预期。

### 线程隔离实现

限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。

比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205112354921-2025-2-511:24:09.png" alt="image-20250205112354921" style="zoom:80%;" />

这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。

所以，我们要对查询商品的FeignClient接口做线程隔离。

#### OpenFeign整合Sentinel

修改cart-service模块的application.yml文件，开启Feign的sentinel功能：

```YAML
feign:
  sentinel:
    enabled: true # 开启feign对sentinel的支持
```

> 需要注意的是，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满。
>
> 所以我们需要配置一下cart-service模块的application.yml文件，修改tomcat连接：
>
> ```YAML
> server:
>   port: 8082
>   tomcat:
>     threads:
>       max: 50 # 允许的最大线程数
>     accept-count: 50 # 最大排队等待数量
>     max-connections: 100 # 允许的最大连接
> ```

然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101746909-2025-2-610:17:47.png" style="zoom:80%;" />

#### 配置线程隔离

接下来，点击查询商品的FeignClient对应的簇点资源后面的流控按钮：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101802772-2025-2-610:18:03.png" style="zoom:80%;" />

在弹出的表单中填写下面内容：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101823253-2025-2-610:18:24.png" alt="image-20250206101823253" style="zoom:80%;" />

注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101855768-2025-2-610:18:56.png" alt="image-20250206101855768" style="zoom:80%;" />

我们利用Jemeter测试，每秒发送100个请求：

![image-20250206101909204](https://gitee.com/cmyk359/img/raw/master/img/image-20250206101909204-2025-2-610:19:10.png)

最终测试结果如下：

![image-20250206101928213](https://gitee.com/cmyk359/img/raw/master/img/image-20250206101928213-2025-2-610:19:29.png)

进入查询购物车的请求每秒大概在100，而在查询商品时却只剩下每秒10左右，符合我们的预期。



此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现不受影响：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101942443-2025-2-610:19:43.png" alt="image-20250206101942443" />

响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响到其它接口。

### 服务熔断实现

之前利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了500毫秒延时），再加上线程隔离限定了线程数为5，导致接口吞吐能力有限，最终QPS只有10左右。这就导致了几个问题：

第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个**降级处理**逻辑。

第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口**熔断**。

#### 编写降级逻辑

触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。

给FeignClient编写失败后的降级逻辑有两种方式：

- 方式一：FallbackClass，无法对远程调用的异常做处理
- 方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。

**步骤一**：在hm-api模块中给`ItemClient`定义降级处理类，实现`FallbackFactory`：

![image-20250206102017583](https://gitee.com/cmyk359/img/raw/master/img/image-20250206102017583-2025-2-610:20:18.png)

代码如下：

```Java
package com.hmall.api.client.fallback;

import com.hmall.api.client.ItemClient;
import com.hmall.api.dto.ItemDTO;
import com.hmall.api.dto.OrderDetailDTO;
import com.hmall.common.exception.BizIllegalException;
import com.hmall.common.utils.CollUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.openfeign.FallbackFactory;

import java.util.Collection;
import java.util.List;

@Slf4j
public class ItemClientFallback implements FallbackFactory<ItemClient> {
    @Override
    public ItemClient create(Throwable cause) {
        return new ItemClient() {
            @Override
            public List<ItemDTO> queryItemByIds(Collection<Long> ids) {
                log.error("远程调用ItemClient#queryItemByIds方法出现异常，参数：{}", ids, cause);
                // 查询购物车允许失败，查询失败，返回空集合
                return CollUtils.emptyList();
            }

            @Override
            public void deductStock(List<OrderDetailDTO> items) {
                // 库存扣减业务需要触发事务回滚，查询失败，抛出异常
                throw new BizIllegalException(cause);
            }
        };
    }
}
```

**步骤二**：在`hm-api`模块中的`com.hmall.api.config.DefaultFeignConfig`类中将`ItemClientFallback`注册为一个`Bean`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102034921-2025-2-610:20:36.png" style="zoom:80%;" />

**步骤三**：在`hm-api`模块中的`ItemClient`接口中使用`ItemClientFallbackFactory`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102045669-2025-2-610:20:46.png" style="zoom:80%;" />

重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102112967-2025-2-610:21:13.png" style="zoom:80%;" />

但是未被限流的请求延时依然很高，导致最终的平局响应时间较长。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102130287-2025-2-610:21:43.png" style="zoom:80%;" />



#### 服务熔断

查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。

对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口**熔断**。当商品服务接口恢复正常后，再允许调用。这其实就是**断路器**的工作模式了。

Sentinel中的断路器不仅可以统计某个接口的**慢请求比例**，还可以统计**异常请求比例**。当这些比例超出阈值时，就会**熔断**该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。

断路器的工作状态切换有一个状态机来控制：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205113626096-2025-2-511:36:31.png" style="zoom:80%;" />

状态机包括三个状态：

- **closed**：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态
- **open**：打开状态，服务调用被**熔断**，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态
- **half-open**：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 
  - 请求成功：则切换到closed状态
  - 请求失败：则切换到open状态

我们可以在控制台通过点击簇点后的**`熔断`**按钮来配置熔断策略：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206102225807-2025-2-610:22:26.png)

在弹出的表格中这样填写：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206102244916-2025-2-610:22:46.png)

这种是按照慢调用比例来做熔断，上述配置的含义是：

- RT（Response Time）超过200毫秒的请求调用就是慢调用
- 统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断
- 熔断持续时长20s

配置完成后，再次利用Jemeter测试，可以发现：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206102256395-2025-2-610:22:57.png)

在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响。

此时整个购物车查询服务的平均RT影响不大：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206102313371-2025-2-610:23:14.png)



# 八、分布式事务

首先分析项目中下单业务整体流程：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102731634-2025-2-610:27:49.png" style="zoom:80%;" />

由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：

- 交易服务：下单事务
- 购物车服务：清理购物车事务
- 库存服务：扣减库存事务

整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为**分支事务**。多个有关联的分支事务一起就组成了**全局事务**。我们必须保证整个全局事务同时成功或失败。

我们知道每一个分支事务就是传统的**单体事务**，都可以满足ACID特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？

来做一个测试，先进入购物车页面：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102923519-2025-2-610:29:49.png" style="zoom:80%;" />

目前有4个购物车，然结算下单，进入订单结算页面：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206103018461-2025-2-610:30:46.png)

然后将购物车中某个商品的库存修改为`0`：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206103040482-2025-2-610:30:48.png)

然后，提交订单，最终因库存不足导致下单失败：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206103144332-2025-2-610:31:45.png)

然后我们去查看购物车列表，发现购物车数据依然被清空了，并未回滚：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103221262-2025-2-610:32:22.png" style="zoom:80%;" />

事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是<u>它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了</u>。

这就是分布式事务问题，出现以下情况之一就可能产生分布式事务问题：

- 业务跨多个服务实现
- 业务跨多个数据源实现



## 8.1、认识Seata

决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的[Seata](https://seata.apache.org/zh-cn/docs/overview/what-is-seata/)了。

其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：

就是找一个统一的**事务协调者**，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206104757749-2025-2-610:48:11.png" style="zoom:80%;" />

大多数的分布式事务框架都是基于这个理论来实现的。Seata也不例外，在Seata的事务管理中有三个重要的角色：

-  **TC (Transaction Coordinator) -** **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。 
-  **TM (Transaction Manager) -** **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。 
-  **RM (Resource Manager) -** **资源管理器：**管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。 

> TM监控整个方法的开始和结束，当方法开始时向TC报告开启全局事务；在方法执行结束后，向TC报告全局事务结束，TC根据各个分支事务RM的执行情况，判断各个分支事务应该提交还是回滚。

Seata的工作架构如图所示：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103827156-2025-2-610:38:49.png" style="zoom:80%;" />

其中，**TM**和**RM**可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来**TM**和**RM**就会协助微服务，实现本地分支事务与**TC**之间交互，实现事务的提交或回滚。

而**TC**服务则是事务协调中心，是一个独立的微服务，需要单独部署。

### 部署TC服务

[参考视频](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=51d78ede0a0127d1839d6abf9204d1ee&p=80)

### 微服务集成Seata

参与分布式事务的每一个微服务都需要集成Seata，我们以`trade-service`为例。

#### 引入依赖

为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此`trade-service`模块不仅仅要引入seata依赖，还要引入nacos依赖:

```XML
<!--统一配置管理-->
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
  </dependency>
  <!--读取bootstrap文件-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-bootstrap</artifactId>
  </dependency>
  <!--seata-->
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
  </dependency>
```

#### 改造配置

首先在nacos上添加一个共享的seata配置，命名为`shared-seata.yaml`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206105952552-2025-2-610:59:54.png" alt="image-20250206105952552" style="zoom:80%;" />

内容如下：

```YAML
seata:
  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址
    type: nacos # 注册中心类型 nacos
    nacos:
      server-addr: 192.168.150.101:8848 # nacos地址
      namespace: "" # namespace，默认为空
      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP
      application: seata-server # seata服务名称
      username: nacos
      password: nacos
  tx-service-group: hmall # 事务组名称
  service:
    vgroup-mapping: # 事务组与tc集群的映射关系
      hmall: "default"
```
然后，改造trade-service模块，添加bootstrap.yaml：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110054739-2025-2-611:00:55.png" alt="image-20250206110054739" style="zoom:80%;" />

内容如下:

```YAML
spring:
  application:
    name: trade-service # 服务名称
  profiles:
    active: dev
  cloud:
    nacos:
      server-addr: 192.168.150.101 # nacos地址
      config:
        file-extension: yaml # 文件后缀名
        shared-configs: # 共享配置
          - dataId: shared-jdbc.yaml # 共享mybatis配置
          - dataId: shared-log.yaml # 共享日志配置
          - dataId: shared-swagger.yaml # 共享日志配置
          - dataId: shared-seata.yaml # 共享seata配置
```

可以看到这里加载了共享的seata配置。

然后改造application.yaml文件，内容如下：

```YAML
server:
  port: 8085
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
  sentinel:
    enabled: true # 开启Feign对Sentinel的整合
hm:
  swagger:
    title: 交易服务接口文档
    package: com.hmall.trade.controller
  db:
    database: hm-trade
```

参考上述办法分别改造`hm-cart`和`hm-item`两个微服务模块。

#### 添加数据库表

seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。

将`seata-at.sql`分别文件导入hm-trade、hm-cart、hm-item三个数据库中。结果如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110624648-2025-2-611:06:37.png" style="zoom:80%;" />

至此为止，微服务整合的工作就完成了。可以参考上述方式对`hm-item`和`hm-cart`模块完成整合改造。

#### 测试

接下来就是测试的分布式事务的时候了。

找到`trade-service`模块下的`com.hmall.trade.service.impl.OrderServiceImpl`类中的`createOrder`方法，也就是下单业务方法。

将其上的`@Transactional`注解改为Seata提供的`@GlobalTransactional`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110816199-2025-2-611:08:17.png" style="zoom:80%;" />

`@GlobalTransactional`注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。

我们重启`trade-service`、`item-service`、`cart-service`三个服务。再次测试，发现分布式事务的问题解决了！

那么，Seata是如何解决分布式事务的呢？

Seata支持四种不同的分布式事务解决方案：

- **XA**
- **TCC**
- **AT**
- **SAGA**

此处只分析`XA`模式和`AT`模式的现原理。

## 8.2、XA模式

XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的关系型数据库都对 XA 规范 提供了支持。实现的原理都是基于两阶段提交。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206112243669-2025-2-611:22:48.png" style="zoom:80%;" />

一阶段：

- 事务协调者通知每个事务参与者执行本地事务
- 本地事务执行完成后报告事务执行状态给事务协调者，**此时事务不提交，继续持有数据库锁**

二阶段：

- 事务协调者基于一阶段的报告来判断下一步操作
- 如果一阶段都成功，则通知所有事务参与者，提交事务
- 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务

#### 原理分析

Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206111635526-2025-2-611:16:36.png" style="zoom:80%;" />

`RM`一阶段的工作：

1. 注册分支事务到`TC`
2. **执行分支业务sql但不提交**
3. 报告执行状态到`TC`

`TC`二阶段的工作：

- `TC`检测各分支事务执行状态
  - 如果都成功，通知所有RM提交事务
  - 如果有失败，通知所有RM回滚事务 

`RM`二阶段的工作：

- 接收`TC`指令，提交或回滚事务



#### 优缺点

`XA`模式的优点是什么？

- 事务的强一致性，满足ACID原则
- 常用数据库都支持，实现简单，并且没有代码侵入

`XA`模式的缺点是什么？

- 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差
- 依赖关系型数据库实现事务

#### 实现

Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：

1. 修改application.yml文件（每个参与事务的微服务），开启XA模式：

```YAML
seata:
  data-source-proxy-mode: XA
```

2. 给发起全局事务的入口方法添加`@GlobalTransactional`注解，本例中是OrderServicelmpl中的create方法：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113123686-2025-2-611:31:25.png" alt="image-20250206113123686" style="zoom:80%;" />

3. 重启服务并测试

## 8.3、AT模式

Seata主推的是AT模式，AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。

#### 原理分析

基本流程图：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113911361-2025-2-611:39:37.png" alt="image-20250206113911361" style="zoom:80%;" />

阶段一`RM`的工作：

- 注册分支事务
- **记录undo-log（数据快照）**
- 执行业务sql并**提交**
- 报告事务状态

阶段二提交时`RM`的工作：

- 删除undo-log即可

阶段二回滚时`RM`的工作：

- 根据undo-log恢复数据到更新前

> AT模式可能会出现短暂的数据不一致。如一阶段分支事务RM1执行sql并提交了，但分支事务RM2执行出错，需要等到二阶段回滚时才能保持与原来的数据一致。但由于RM1已经提交了事务，数据已经发生了变化，若此时有其他线程查询数据，会得到错误的结果。

#### 流程梳理

我们用一个真实的业务来梳理下AT模式的原理。

比如，现在有一个数据库表，记录用户余额：

| **id** | **money** |
| :----- | :-------- |
| 1      | 100       |

其中一个分支业务要执行的SQL为：

```SQL
 update tb_account set money = money - 10 where id = 1
```

AT模式下，当前分支事务执行流程如下：

**一阶段**：

1. `TM`发起并注册全局事务到`TC`
2. `TM`调用分支事务
3. 分支事务准备执行业务SQL
4. `RM`拦截业务SQL，根据where条件查询原始数据，形成快照。

```JSON
{
  "id": 1, "money": 100
}
```

5. `RM`执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90

6. `RM`报告本地事务状态给`TC`

**二阶段**：

1. `TM`通知`TC`事务结束
2. `TC`检查分支事务状态
   1. 如果都成功，则立即删除快照
   2. 如果有分支事务失败，需要回滚。读取快照数据（{"id": 1, "money": 100}），将快照恢复到数据库。此时数据库再次恢复为100

流程图如下：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206114246134-2025-2-611:42:47.png)

#### AT与XA的区别

简述`AT`模式与`XA`模式最大的区别是什么？

- `XA`模式一阶段不提交事务，锁定资源；`AT`模式一阶段直接提交，不锁定资源。
- `XA`模式依赖数据库机制实现回滚；`AT`模式利用数据快照实现数据回滚。
- `XA`模式强一致；`AT`模式最终一致

可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。

#### 实现

1. 添加seata-at.sql到微服务对应的数据库中：

   ![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206114846418-2025-2-611:48:49.png)

2. 修改application.yml文件，将事务模式修改为AT模式：

   ![](https://gitee.com/cmyk359/img/raw/master/img/image-20250206114917923-2025-2-611:49:24.png)

# 九、MQ基础

​	微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要**等待**服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为**同步调用**，也可以叫**同步通讯**。但在很多场景下，可能需要采用**异步通讯**的方式。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png" style="zoom:80%;" />

- 同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。
- 异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。

两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。

如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。

## 9.1、初识MQ

### 同步调用

目前项目中服务直接的调用都是基于OpenFeign的调用都属于是同步调用，以**余额支付功能**为例来分析，整个服务的流程如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095334972-2025-2-1109:53:36.png" style="zoom:80%;" />

- 支付服务需要先调用用户服务完成余额扣减
- 然后支付服务自己要更新支付流水单的状态
- 然后支付服务调用交易服务，更新业务订单状态为已支付

三个步骤依次执行，其中就存在3个问题：

1. 拓展性差

   目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。如果之后添加需求：

   - 用户支付成功后以短信或者其它方式通知用户，告知支付成功。

   - 增加积分或金币的概念，用户支付成功后，给用户以积分奖励或者返还金币
   - .....

   如果按照以上的服务调用方法，每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动。最终支付业务会越来越臃肿：

   <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095944590-2025-2-1109:59:45.png" style="zoom:80%;" />

2. 性能下降

   由于采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：

   <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100207999-2025-2-1110:02:09.png" style="zoom:80%;" />

3. **级联失败**

   由于是基于OpenFeign调用交易服务、通知服务。耦合性太高，一个服务失败会影响其他服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。这就是同步调用的**级联失败**问题。

而要解决这些问题，我们就必须用**异步调用**的方式来代替**同步调用**。

### 异步调用

异步调用方式其实就是基于**消息通知**的方式，一般包含三个角色：

- 消息发送者：投递消息的人，就是原来的调用方
- 消息代理：管理、暂存、转发消息，可以把它理解成微信服务器
- 消息接收者：接收和处理消息的人，就是原来的服务提供方

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100551228-2025-2-1110:05:52.png" style="zoom:80%;" />

在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息代理。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。

这样，发送消息的人和接收消息的人就完全解耦了。

还是以余额支付业务为例：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100738170-2025-2-1110:07:39.png" style="zoom:80%;" />

除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。

假如后序增加了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100924951-2025-2-1110:09:26.png" style="zoom:80%;" />

不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。

另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。

综上，异步调用的优势包括：

- 耦合度更低
- 性能更好
- 业务拓展性强
- 故障隔离，避免级联失败

当然，异步通信也并非完美无缺，它存在下列缺点：

- 完全依赖于Broker的可靠性、安全性和性能
- 架构复杂，后期维护和调试麻烦

### 技术选型

消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.

目比较常见的MQ实现：

- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka

几种MQ的对比：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101237979-2025-2-1110:12:39.png" style="zoom:80%;" />

追求可用性：Kafka、 RocketMQ 、RabbitMQ

追求可靠性：RabbitMQ、RocketMQ

追求吞吐能力：RocketMQ、Kafka

追求消息低延迟：RabbitMQ、Kafka

目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此选择RabbitMQ来学习。

## 9.2、RabbitMQ

RabbitMQ是基于Erlang语言开发的开源消息通信中间件，[官网地址](https://www.rabbitmq.com/)

RabbitMQ对应的架构如图：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101950426-2025-2-1110:19:51.png" style="zoom:80%;" />

其中包含几个概念：

- **`publisher`**：生产者，也就是发送消息的一方
- **`consumer`**：消费者，也就是消费消息的一方
- **`queue`**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理
- **`exchange`**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。
- **`virtual host`**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue



### 安装

基于Docker来安装RabbitMQ，使用下面的命令即可：

```bash
docker run \
 -e RABBITMQ_DEFAULT_USER=itheima \
 -e RABBITMQ_DEFAULT_PASS=123321 \
 -v mq-plugins:/plugins \
 --name mq \
 --hostname mq \
 -p 15672:15672 \
 -p 5672:5672 \
 --network hm-net\
 -d \
 rabbitmq:3.8-management
```

在创建MQ镜像时，将其添加到项目的网络`hm-net`中了。在安装命令中有两个映射的端口：

- 15672：RabbitMQ提供的管理控制台的端口
- 5672：RabbitMQ的消息发送处理接口

安装完成后，我们访问 `http://服务器ip:15672` 即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。

登录后即可看到管理控制台总览页面：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101903956-2025-2-1110:19:05.png" style="zoom:80%;" />



### 测试收发消息

#### 交换机

打开Exchanges选项卡，可以看到已经存在很多交换机：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211104959780-2025-2-1110:50:01.png" style="zoom:80%;" />

点击任意交换机，即可进入交换机详情页面。利用控制台中的publish message 发送一条消息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-1110:54:01.jpg" style="zoom:80%;" />

这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。

#### 队列

打开`Queues`选项卡，新建一个队列：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105803927-2025-2-1110:58:24.png" style="zoom:80%;" />

命名为`hello.queue1`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105928820-2025-2-1110:59:30.png" style="zoom:80%;" />

再以相同的方式，创建一个队列，密码为`hello.queue2`，最终队列列表如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110016831-2025-2-1111:00:18.png" style="zoom:80%;" />

此时，再次向`amq.fanout`交换机发送一条消息。会发现消息依然没有到达队列！！

怎么回事呢？

发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。

#### 绑定关系

点击`Exchanges`选项卡，点击`amq.fanout`交换机，进入交换机详情页，然后点击`Bindings`菜单，在表单中填写要绑定的队列名称：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110227010-2025-2-1111:02:28.png" style="zoom:80%;" />![](https://gitee.com/cmyk359/img/raw/master/img/image-20250211110313851-2025-2-1111:03:15.png)

相同的方式，将hello.queue2也绑定到改交换机。最终，绑定结果如下：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250211110313851-2025-2-1111:03:15.png)

#### 发送消息

再次回到exchange页面，找到刚刚绑定的`amq.fanout`，点击进入详情页，再次发送一条消息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110514041-2025-2-1111:05:52.png" style="zoom:80%;" />

回到`Queues`页面，可以发现`hello.queue`中已经有一条消息了：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110639183-2025-2-1111:06:52.png" style="zoom:80%;" />

点击队列名称，进入详情页，查看队列详情，点击get message，可以看到消息到达队列了：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110745382-2025-2-1111:07:52.png" style="zoom:80%;" />

这个时候如果有消费者监听了MQ的`hello.queue1`或`hello.queue2`队列，自然就能接收到消息了。

### 数据隔离

#### 用户管理

点击`Admin`选项卡，首先会看到RabbitMQ控制台的用户管理界面：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211111205706-2025-2-1111:12:12.png" style="zoom:80%;" />

这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的`admin`这个用户。仔细观察用户表格中的字段，如下：

- `Name`：`admin`，也就是用户名
- `Tags`：`administrator`，说明`admin`用户是超级管理员，拥有所有权限
- `Can access virtual host`： `/`，可以访问的`virtual host`，这里的`/`是默认的`virtual host`

当只搭建一套MQ集群，供多个不同项目同时使用时，为了避免互相干扰， 我们会利用`virtual host`的隔离特性，将不同项目隔离。一般会做两件事情：

- 给每个项目创建独立的运维账号，将管理权限分离。
- 给每个项目创建不同的`virtual host`，将每个项目的数据隔离。

#### 配置virtual host

给当前项目创建一个新的用户，命名为`hmall`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112238339-2025-2-1111:22:52.png" style="zoom:80%;" />

此时hmall⽤⼾没有任何 virtual host 的访问权限：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112640217-2025-2-1111:26:49.png" style="zoom:80%;" />

接下来为hmall用户配置权限

首先退出当前admin用户，切换到刚刚创建的hmall用户登录，然后点击`Virtual Hosts`菜单，进入`virtual host`管理页：

![image-20250211113429386](https://gitee.com/cmyk359/img/raw/master/img/image-20250211113429386-2025-2-1111:34:52.png)

可以看到目前只有一个默认的`virtual host`，名字为 `/`。

为hmall给黑马商城项目创建一个单独的`virtual host`，而不是使用默认的`/`。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113655596-2025-2-1111:37:40.png" style="zoom:80%;" />

创建完成后如图：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113816684-2025-2-1111:38:18.png" style="zoom:80%;" />

由于我们是登录`hmall`账户后创建的`virtual host`，因此回到`users`菜单，你会发现当前用户已经具备了对`/hmall`这个`virtual host`的访问权限了：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211114120125-2025-2-1111:41:22.png" style="zoom:80%;" />

此时，点击页面右上角的`virtual host`下拉菜单，切换`virtual host`为 `/hmall`：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250211114221894-2025-2-1111:42:24.png)

然后再次查看queues选项卡，会发现之前的队列已经看不到了：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250211114256298-2025-2-1111:42:57.png)

这就是基于`virtual host `的隔离效果。

## 9.3、SpringAMQP

将来开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。

由于`RabbitMQ`采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与`RabbitMQ`交互。并且`RabbitMQ`官方也提供了各种不同语言的客户端。

但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。

SpringAMQP的[官方地址](https://spring.io/projects/spring-amqp/)

SpringAMQP提供了三个功能：

- 自动声明队列、交换机及其绑定关系
- 基于注解的监听器模式，异步接收消息
- 封装了RabbitTemplate工具，用于发送消息

### 导入Demo

 [Demo地址](https://gitee.com/cmyk359/mq-demo)

项目结构如图：

![image-20250211123012687](https://gitee.com/cmyk359/img/raw/master/img/image-20250211123012687-2025-2-1112:30:25.png)

包括三部分：

- mq-demo：父工程，管理项目依赖
- publisher：消息的发送者
- consumer：消息的消费者

在父工程中已经添加了SpringAMQP的相关依赖，子工程中就可以直接使用了。

```xml
<!--AMQP依赖，包含RabbitMQ-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

### 快速入门

在之前的案例中，都是经过交换机发送消息到队列。为了测试方便，直接向队列发送消息，跳过交换机。

- publisher直接发送消息到队列
- 消费者监听并处理队列中的消息

> **注意**：这种模式一般测试使用，很少在生产中使用。

为了方便测试，先在控制台新建一个队列：simple.queue。接下来，就可以利用Java代码收发消息了。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211123649911-2025-2-1112:36:52.png" style="zoom:80%;" />

#### 消息发送

首先配置MQ地址，在`publisher`服务的`application.yml`中添加配置：

```yaml
spring:
  rabbitmq:
    host: 192.168.181.100 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码
```

然后在`publisher`服务中编写测试类`SpringAmqpTest`，并利用`RabbitTemplate`实现消息发送：

```java
@SpringBootTest
@Slf4j
class SpringAmqpTest {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void testSendMessage() {
        //1.队列名
        String queueName = "simple.queue";
        //2.消息
        ItemDoc itemDoc = new ItemDoc();
        itemDoc.setName("测试数据");
        //3.发送
        rabbitTemplate.convertAndSend(queueName,itemDoc);
    }
}
```

打开控制台，可以看到消息已经发送到队列中：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124025590-2025-2-1112:40:44.png" style="zoom:80%;" />

#### 消息接收

首先配置MQ地址，在`consumer`服务的`application.yml`中添加配置：

```yaml
spring:
  rabbitmq:
    host: 192.168.181.100 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码
```

然后在`consumer`服务的`com.itheima.consumer.listener`包中新建一个类`SpringRabbitListener`，代码如下：

```java
@Component
public class SpringRabbitListener {
    // 利用RabbitListener注解来声明要监听的队列信息
    // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。
    // 可以看到方法体中接收的就是消息体的内容
    @RabbitListener(queues = "simple.queue")
    public void listenSimpleQueueMessage(String msg) throws InterruptedException {
        System.out.println("spring 消费者接收到消息：【" + msg + "】");
    }
}
```

#### 测试

启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124457284-2025-2-1112:44:58.png" style="zoom:80%;" />

### WorkQueues模型

Work queues，任务模型。简单来说就是让**多个消费者**绑定到一个队列，共同消费队列中的消息。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124655817-2025-2-1112:46:56.png" style="zoom:80%;" />

当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。

此时就可以使用WorkQueues模型，**多个消费者共同处理消息处理，消息处理的速度就能大大提高**了。

接下来模拟WorkQueue，实现一个队列绑定多个消费者

基本思路如下：

1. 在RabbitMQ的控制台创建一个队列，名为work.queue
2. 在publisher服务中定义测试方法，发送50条消息到work.queue
3. 在consumer服务中定义两个消息监听者，都监听work.queue队列



首先，我们在控制台创建一个新的队列，命名为`work.queue`：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211125033080-2025-2-1112:50:34.png" style="zoom:80%;" />

#### 消息发送

循环发送消息，模拟大量消息堆积现象。在publisher服务中的SpringAmqpTest类中添加一个测试方法

```java
/**
     * workQueue
     * 向队列中不停发送消息，模拟消息堆积。
     */
@Test
public void testWorkQueue() throws InterruptedException {
    // 队列名称
    String queueName = "simple.queue";
    // 消息
    String message = "hello, message_";
    for (int i = 0; i < 50; i++) {
        // 发送消息，每20毫秒发送一次，相当于每秒发送50条消息
        rabbitTemplate.convertAndSend(queueName, message + i);
        Thread.sleep(20);
    }
}
```



# 十、MQ高级



# 十一、Elasticsearch

