---
title: JVM学习
categories:
  - Java
abbrlink: f0242a65
date: 2025-01-16 22:08:22
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## 一、JVM概述

JVM，即`Java Virtual Machine`，是java程序的运行环境（java<u>二进制字节码</u>的运行环境）。Java虚拟机负责装载字节码到其内部，解释/编译为对应平台上的机器码指令执行

![image-20250110105402958](https://gitee.com/cmyk359/img/raw/master/img/image-20250110105402958-2025-1-1116:57:19.png)

### 1.1、JVM的特点

‌**1. 跨平台性**‌：
JVM通过解释执行字节码指令，实现了Java程序的跨平台性。由于Java字节码是与平台无关的中间代码，所以Java程序可以在任何安装了JVM的平台上运行，实现了“一次编写，到处运行”的特性‌

‌**2. 自动内存管理**‌：
JVM提供了自动内存管理功能，包括垃圾回收机制，用于回收不再使用的内存对象，防止内存泄漏和碎片化。这一特性极大地减轻了开发人员的负担，使他们可以更加专注于业务逻辑的实现‌

‌**3. 安全性**‌：
JVM通过字节码验证、类加载机制等手段保证程序的安全性和稳定性。这些机制确保了只有经过验证的字节码才能在JVM上执行，从而防止了恶意代码的执行‌

**4. 高性能**‌：
JVM通常包含即时编译器（JIT），它负责将热点代码（经常执行的代码）编译为本地机器码，以提高程序的执行效率。这使得Java程序在运行时能够获得接近本地代码的性能‌

‌**5. 多态性**‌：
JVM支持多态性，允许通过相同的接口实现不同的实例，从而完成不同的业务操作。这一特性增强了Java程序的灵活性和可扩展性‌



> **区分：jvm和jdk、jre**
>
> Jdk中包括了Jre，Jre中包括了JVM。
>
> ![image-20240801170549707](https://gitee.com/cmyk359/img/raw/master/img/image-20240801170549707-2024-8-117:06:24.png)

### 1.2 常见的JVM

​	![image-20250110105646605](https://gitee.com/cmyk359/img/raw/master/img/image-20250110105646605-2025-1-1010:56:57.png)

### 1.3、JVM组成部分

1. 类加载器
2. 运行时数据区（JVM内存结构）
3. 执行引擎
4. 本地库接口

![JVM结构](https://gitee.com/cmyk359/img/raw/master/img/image-20240801171503494-2025-1-1116:57:00.png)

> ​    程序在执行之前先要把 java 代码转换成字节码（class 文件），jvm 首先需要把字节码通过一定的方式 **类加载器（ClassLoader）** 把文件加载到内存中的**运行时数据区（Runtime Data Area）** ，而字节码文件是 jvm 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 **执行引擎（Execution Engine）** 将字节码翻译成底层系统指令再交由CPU 去执行，而这个过程中可能需要调用其他语言的接口 **本地库接口（Native Interface）** 来实现整个程序的功能，这就是这 4 个主要组成部分的职责与功能。
> ​   而我们通常所说的 JVM 组成指的是 运行时数据区（Runtime Data  Area） ，因为通常需要程序员调试分析的区域就是“运行时数据区”，或者更具体的来说就是“运行时数据区”里面的 Heap（堆）模块。



## 二、运行时数据区

### 2.1、程序计数器

![程序计数器在JVM中的位置](https://gitee.com/cmyk359/img/raw/master/img/image-20250111170023475-2025-1-1117:00:24.png)

Program Counter Register程序计数器（寄存器）

作用：记住下一条**JVM指令**的执行地址。

特点：

- 是**线程私有的**。

  由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，**为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。**称之为“线程私有”的内存。

- 不会存在内存溢出

  程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。

### 2.2、虚拟机栈

![虚拟机栈在JVM中的位置](https://gitee.com/cmyk359/img/raw/master/img/image-20250111170226869-2025-1-1117:02:27.png)

Java 虚拟机栈：Java Virtual Machine Stacks，是**每个线程运行时所需要的内存**。

- 每个栈由多个**栈帧（Frame）**组成，是每次**方法调用时所占用的内存**，包括参数、局部变量，返回地址等。
- 虚拟机栈是**每个线程私有的**，每个线程运行时只能有一个活动栈帧，对应着当前正在执行的那个方法。

> 虚拟机栈中的栈帧（Stack Frame）是方法执行的基本单位。每当一个方法被调用时，都会在虚拟机栈中创建一个新的栈帧，该栈帧成为当前活动栈帧，用于存储该方法的局部变量、操作数栈等信息。当方法执行完成后，对应的栈帧会被移除，控制权回到前一个栈帧。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250110111943565-2025-1-1011:19:44.png" alt="image-20250110111943565" style="zoom:80%;" />

#### 问题辨析

- 垃圾回收是否涉及栈内存？

  不涉及。每个线程所分配的栈内存由一次次的方法调用产生的栈帧内存组成，而栈帧内存在每次方法调用结束后就会出栈释放，故不需要垃圾回收来管理栈内存。垃圾回收只是回收堆内存中的无用对象。

  

- 栈分配地越大越好吗？

  不是。在运行java代码时可以通过虚拟机参数 `-Xss size`指定栈内存的大小，**栈内存划分地越大，可以增加方法调用的次数，不会提高运行效率，反而会让可以分配的线程数变少** 。

  ![image-20240801182419579](https://gitee.com/cmyk359/img/raw/master/img/image-20240801182419579-2024-8-118:24:28.png)

- 方法内部的局部变量是否线程安全？

  - 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的（不会被其他线程所访问），如只在方法内部进行打印、运算等操作；超出范围，如被return，作为其他方法的参数等，就需要进线程安全相关控制。
  - 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。



#### 栈内存溢出问题

`java.lang.StackOverflowError`，可能引起该异常的原因：

- 栈帧过多导致栈内存溢出，如递归调用时没有设置正确的返回条件，进行若干次调用后导致栈溢出
- 栈帧过大导致栈内存溢出（不常出现）。

#### 线程运行诊断

案例一： CPU占用过多

1. 使用`top`命令定位哪个进程对cpu的占用过高，得到该进程的进程号PID

2. `ps H -eo pid,tid,%cpu | grep 进程id`，用ps命令进一步定位是哪个线程引起cpu占用过高，得到其线程号 TID

3. 使用 `jstack 进程id`，列出该进程中所有的java线程，包括虚拟机的线程和用户定义的线程。

   可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。

   ![image-20240801185543016](https://gitee.com/cmyk359/img/raw/master/img/image-20240801185543016-2024-8-118:55:43.png)



案例二：程序运行很长时间没有结果

使用`jstack`工具检查死锁情况。

首先通过 `top`命令得到cpu占用过高进程的PID，再使用`jstack PID`检查有无死锁情况。

![image-20240801190456065](https://gitee.com/cmyk359/img/raw/master/img/image-20240801190456065-2024-8-119:05:43.png)

### 2.3、本地方法栈

![本地方法栈在JVM中的位置](https://gitee.com/cmyk359/img/raw/master/img/image-20250111170334787-2025-1-1117:03:35.png)

**本地方法栈**的主要作用是**支持本地方法的执行**，为本地方法的运行提供内存空间。这些本地方法通常是用非Java语言（如C、C++）编写的，并通过Java Native Interface（JNI）或其他方式被Java程序调用。由于Java本身是跨平台的，有些操作无法直接用Java代码实现，因此需要通过本地方法来完成。

在Java中，`native`关键字用于声明一个方法是由本地代码（通常是用C或C++编写的）实现的，而不是由Java代码实现的。如`Object`类中的`clone`和`hashcode`等方法都是本地方法：

![image-20250111171412264](https://gitee.com/cmyk359/img/raw/master/img/image-20250111171412264-2025-1-1117:14:13.png)

特点：

- ‌**线程私有**‌：每个线程在执行本地方法时都会分配独立的本地方法栈空间，因此本地方法栈是线程私有的。

- ‌**动态增长和收缩**‌：根据需要，本地方法栈可以动态地增长和收缩。

本地方法栈与Java栈的区别

1. ‌**目的**‌：Java虚拟机栈用于支持Java方法的调用，而本地方法栈用于支持本地方法的调用。
2. ‌**数据结构**‌：Java虚拟机栈中的栈帧包含局部变量表、操作数栈等，而本地方法栈中的栈帧则可能包含本地方法特有的数据结构。
3. ‌**执行环境**‌：Java虚拟机栈中的方法在JVM中执行，而本地方法栈中的方法则在本地环境中执行。

### 2.4、堆

![堆在JVM中的位置](https://gitee.com/cmyk359/img/raw/master/img/image-20250111171542343-2025-1-1117:15:43.png)

#### 定义

通过 `new` 关键字，创建对象都会使用堆内存。

特点

- 它是**线程共享**的，堆中对象都需要考虑线程安全的问题。
- 有垃圾回收机制。堆是JVM中管理的**最大**一块内存区域，**是GC ( Garbage Collection，垃圾收集器)执行垃圾回收的重点区域。**

#### 堆内存的划分

![JVM内存划分](https://gitee.com/cmyk359/img/raw/master/img/image-20250115141508944-2025-1-1514:15:14.png)

JVM内存划分为堆内存和非堆内存，堆内存分为新生代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。

<span style="color : red">新生代</span>是用于存放新创建对象的区域，通常比较小。垃圾回收主要使用**复制算法**。新生代又可以进一步划分为以下三个部分：

- **Eden区**
  - 新创建的对象首先分配在Eden区。
  - 当Eden区满时，会触发新生代的垃圾回收（**Minor GC**）。
- **Survivor区（S0和S1）**：
  - 新生代中有两个Survivor区，分别称为**From**Space（S0）和**To**Space（S1）。
  - 在Minor GC时，存活的对象会被复制到其中一个Survivor区。
  - 经过一定次数的复制后，仍然存活的对象会被移动到老年代。



<span style="color : red">老年代</span>用于存放经过多次垃圾回收仍然存活的对象。老年代的特点是对象的生命周期较长，通常是应用程序中长期使用的对象。老年代的内存空间相对较大，垃圾回收（Major GC）相对复杂，可能会使用标记-清除、标记-压缩等算法。

<span style="color : red">永久代/元空间</span>

- **永久代（PermGen）**：
  - 在Java 8之前，JVM使用永久代来存放类的元数据（如类的结构信息、方法等）。
  - 永久代的大小是固定的，可能会导致`OutOfMemoryError`，尤其是在动态生成大量类的情况下。
- **元空间（Metaspace）**：
  - 从Java 8开始，永久代被元空间取代，元空间的内存不再使用堆内存，而是使用**本地内存**
  - 元空间的大小可以根据需要动态调整，解决了永久代固定大小的限制。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250115143110584-2025-1-1514:31:25.png" style="zoom:80%;" />

> **JVM堆内存为什么要分代设计？**
>
> JVM堆内存的分代设计是为了优化垃圾回收过程，基于对象生命周期的特征，能够提高回收效率、降低停顿时间、优化内存管理，并适应不同类型的应用程序。
>
> 1. 基于对象生命周期的特征
>
>    在Java应用程序中，大多数对象的生命周期相对较短。许多对象在创建后不久就会变得不可达，因此将这些短命对象与长命对象分开可以提高垃圾回收的效率。
>
>    - **新生代**：存放新创建的对象，通常大多数对象在短时间内就会被回收。
>    - **老年代**：存放经过多次垃圾回收仍然存活的对象，这些对象的生命周期较长。
>
> 2. 分代垃圾回收策略能够针对不同代的对象采用不同的回收策略：
>
>    - **新生代的回收（Minor GC）**：新生代的垃圾回收通常较快，因为大多数对象是短命的。Minor GC只需遍历Eden区和一个Survivor区，复制存活对象到另一个Survivor区，效率较高。
>    - **老年代的回收（Major GC）**：老年代的对象通常存活时间较长，老年代的回收相对复杂且耗时。通过将老年代与新生代分开，JVM可以减少对老年代的频繁回收，从而降低停顿时间。
>
> 3. 降低停顿时间
>
>    分代垃圾回收的设计使得新生代的回收更频繁且快速，而老年代的回收相对少且耗时。这样可以显著降低应用程序的停顿时间，提升用户体验。
>
> 4. 通过分代，JVM能够更有效地管理内存，减少内存碎片：
>
>    - 新生代中的对象在Minor GC后被整理到Survivor区，消除了短命对象的内存碎片。
>    - 老年代中的对象经过复杂的回收算法（如标记-清除、标记-压缩）进行整理，减少内存碎片，优化内存使用。
>
> 5. 适应不同类型的应用
>
>    分代设计使得JVM能够适应不同类型的应用程序，特别是那些有大量短命对象的应用（如Web应用、游戏等）。通过优化新生代的回收策略，能够提高这些应用的性能。

#### 存储的内容

![3ee7f13d62ab1efbf981c6e138eba66f](https://gitee.com/cmyk359/img/raw/master/img/3ee7f13d62ab1efbf981c6e138eba66f-2025-1-1210:28:02.png)

- **对象实例**：new 创建的对象，类初始化生成的对象，基本数据类型的数组也是对象实例(new 创建)

- **字符串常量池**

  StringTable/String Pool： JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

  > 字符串常量池存储的是 String 对象的直接引用或者对象，是一张 stringTable
  
- **静态变量**：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中

- **线程分配缓冲区** Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率

#### 字符串常量池

字符串常量池（String Pool / StringTable / 串池）的主要目的是存储字符串字面量，确保相同的字符串只存储一份，从而减少内存使用和提高性能。

> 串池是**运行时常量池**的一个特殊部分，专门用于存储字符串字面量。
>
> StringTable通过**哈希表**的结构来存储字符串，以确保相同的字符串在StringTable中只存在一个实例。

当JVM遇到一个字符串字面量时，它会按照以下步骤操作：

1. ‌**检查**‌：JVM首先会在字符串常量池中检查是否已经存在该字符串。
2. ‌**创建与返回**‌：
   - 如果存在，JVM会直接返回该字符串的引用，而不会创建新的字符串对象。
   - 如果不存在，JVM会在堆中创建一个新的字符串对象，将该对象的引用添加到字符串常量池中，并返回这个引用。

##### 内存位置

随着JDK版本的更新，字符串常量池的位置也发生了变化：

- ‌**JDK 1.6及之前**‌：字符串常量池位于方法区（也称为永久代）中。
- ‌**JDK 1.7**‌：字符串常量池被移动到了堆中，而运行时常量池（包含其他类型的常量，如类名、字段名、方法名等）仍然保留在方法区中。
- ‌**JDK 1.8及之后**‌：永久代被移除，方法区的实现变为了元空间（Metaspace），但字符串常量池仍然保留在堆中。

##### StringTable 特性

1、**字符串延迟加载**

**常量池中的字符串仅是符号，并不会立即被转换成对象。只有当字符串真正被使用时，它才会被加载到StringTable中，并转换成字符串对象。**

如下：常量池中的信息，都会被加载到运行时常量池中，这时 a、b 、ab 都是常量池中的符号，还没有变为 java 字符串对象，只有执行到引用它的代码时才会变为字符串对象，并该字符串对象放入字符串常量池中。

```java
// 初始时，字符串常量池(StringTable): []  
public static void main(String[] args) {
  String s1 = "a"; // 懒惰的
  String s2 = "b";
  String s3 = "ab";//此时，字符串常量池(StringTable): ["a","b","ab"]  
}
```

对以上代码编译后class文件，使用`javap -v 类名.class`命令进行反编译，查看对应的字节码文件

```bash
//常量池
// 常量池中的信息，都会被加载到运行时常量池中， 
// 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象，是懒惰的
Constant pool: 
   #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V
   #2 = String             #25            // a
   #3 = String             #26            // b
   #4 = String             #27            // ab



//运行代码       
 0: ldc           #2                  // String a
 2: astore_1 //存入局部变量表slot 1号位
 3: ldc           #3                  // String b
 5: astore_2
 6: ldc           #4                  // String ab
 8: astore_3
   
// ldc #2 会把 a 符号变为 "a" 字符串对象，并放入串池 StringTable: ["a"] 
// ldc #3 会把 b 符号变为 "b" 字符串对象，并放入串池 StringTable: ["a", "b"] 
// ldc #4 会把 ab 符号变为 "ab" 字符串对象，并放入串池 StringTable: ["a", "b" ,"ab"]    
   
       
//局部变量表(栈)  
LocalVariableTable:  
        Start  Length  Slot  Name   Signature
            0      51     0  args   [Ljava/lang/String;
            3      48     1    s1   Ljava/lang/String;
            6      45     2    s2   Ljava/lang/String;
            9      42     3    s3   Ljava/lang/String;

```

> 字符串常量池与`new String()`的区别
>
> - ‌**字符串字面量**‌：如`String str1 = "hello";`，这里的`"hello"`是一个字符串字面量，它会被存储在字符串常量池中。
>
> - ‌**`new String()`**‌：如
>
>   ```java
>   String str2 = new String("hello"); //这里会创建两个对象：
>   ```
>
>   1. 首先，在字符串常量池中检查是否存在`"hello"`，如果存在则直接使用其引用，否则在常量池中创建它。
>   2. 接着，在**堆**上创建一个新的`String`对象，其内容是`"hello"`，这个新对象与常量池中的字符串对象内容相同，但它们在内存中的位置（即引用）是不同的。

2、**字符串拼接**

- 字符串变量的拼接原理是：使用StringBuilder的append方法（JDK 1.8）
- 字符串**常量**拼接的原理是编译期优化，拼接结果放入常量池

```java
// 初始时，字符串常量池(StringTable): []  
public static void main(String[] args) {
  String s1 = "a"; // 懒惰的
  String s2 = "b";
  String s3 = "ab";//此时，字符串常量池(StringTable): ["a","b","ab"]  
    
  // 底层实现：new StringBuilder().append("a").append("b").toString() -->  new String("ab")   ，最终保存在堆中 
  String s4 = s1 + s2;   //字符串变量   // 返回的是堆内地址
  // javac 在编译期间的优化，结果已经在编译期确定为ab
  String s5 = "a" + "b"; //字符串常量
  
  System.out.println(s3 == s4); // F
  System.out.println(s3 == s5); // T
}
```

3、`intern`方法

在jdk1.8中，`intern`方法尝试将一个字符串对象尝试放入串池，在串池中：

- 存在一个字符串对象和该对象的字符串值相等，则返回 String Pool 中字符串的引用。
- 不存在，把该对象的**引用地址复制一份**放入串池，并返回串池中的引用地址

> 调用`intern`方法的字符串对象和串池中的对象**是同一个**

在jdk1.6中，`intern`方法尝试将一个字符串对象尝试放入串池，在串池中：

- 存在一个字符串对象和该对象的字符串值相等，则返回 String Pool 中字符串的引用。
- 不存在，会**把此对象复制一份**，放入串池，把串池中的对象返回

> 调用`intern`方法的字符串对象和串池中的对象**不是同一个**

```java
// StringTable: ["ab", "a", "b"]
public static void main(String[] args) {

  String x = "ab"; // StringTable: ["ab"]
  
  // 堆  new String("a")   new String("b")  new StringBuilder()  new String("ab")
  // StringTable: ["ab", "a", "b"]
  String s = new String("a") + new String("b"); //动态拼接的字符串只存在于堆中，还没有加入串池

  // 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回
  String s2 = s.intern(); 

  System.out.println(s == x);  // F
  System.out.println(s2 == x); // T
  
}
```

##### StringTable 垃圾回收

​	在Java 7及以前的版本中，StringTable位于堆内部的永久代（PermGen）中。由于永久代的空间有限，且只有在Full GC时才会进行垃圾回收，因此可能会导致很多已经无用的字符串对象仍存在于堆中，占用内存资源。

​	然而，在Java 8及以后的版本中，StringTable被移动到了JVM外部的元空间（Metaspace）中。在这里，GC会正常进行，因此StringTable中的无用字符串对象可以得到及时的回收。

​	当JVM进行垃圾回收时，如果StringTable中的**某个字符串对象不再被引用**，那么该字符串对象就会被视为垃圾，并会在后续的垃圾回收过程中被回收掉。

​	在某些情况下，当StringTable中的字符串对象数量过多时，可能会触发垃圾回收。例如，当向StringTable中添加大量字符串对象并使其失去引用时，垃圾回收器会回收这些无用的字符串对象所占用的内存空间。

##### StringTable 性能调优

两种方法：

- 使用虚拟机参数`-XX:StringTableSize=桶个数`,可以通过调整StringTable的桶（bucket）数量来优化其性能。增加桶的数量可以减少哈希碰撞次数，从而提高插入和取出字符串对象的效率。
- 使用`String.intern()`方法可以将字符串常量添加到StringTable中，从而实现字符串的复用，减少堆内存的占用。

#### 堆内存溢出

JVM堆在JVM启动时即被创建，其空间大小也随之确定，但可以通过JVM参数（如`-Xms`设置初始内存，`-Xmx`设置最大内存）进行调节。

虽然堆内存中会执行GC，但当创建的对象一直都有使用时，就无法被回收。这样的对象一直创建下去，最终会使堆内存没有足够的空间去存储生成的对象，JVM会抛出`java.lang.OutOfMemoryError`异常，即堆内存溢出‌。

#### 堆内存诊断工具

1. jps工具：查看当前系统中有哪些 java 进程
2. jmap 工具：查看堆内存占用情况，`jmap -heap 进程id`
3. jconsole工具：图形界面的，多功能的监测工具，可以连续监测
4. jvisualvm工具：以可视化的方法展示虚拟机，其中，“堆dump”功能可以查看堆的详细状态，包括堆的概况以及堆中所有的类，还能点进具体的一个类查看这个类的状态。



### 2.5、方法区

#### 定义

**方法区** （Method Area）：是JVM中各个**线程共享**的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

尽管《Java虚拟机规范》中将方法区描述为堆的一个逻辑部分，但它通常被称为“非堆”（Non-Heap），以与Java堆区分开来。

它是JVM规范中定义的一个概念，用于描述这部分内存的功能和用途。在不同的JVM实现中，方法区可以有不同的具体实现方式。

- 在Java 8之前的版本中，HotSpot虚拟机使用**永久代**（PermGen space）来作为方法区的具体实现。
- 从Java 8开始，HotSpot虚拟机移除了永久代的概念，取而代之的是**元空间**（Metaspace）。元空间同样用于存储类的元数据，但它并不在虚拟机内存中，而是使用本地内存（即操作系统的内存）。**将字符串常量池移动到堆中了**。

![image-20250112111605466](https://gitee.com/cmyk359/img/raw/master/img/image-20250112111605466-2025-1-1211:16:06.png)

> **方法区是一个概念（规范），而永久代或元空间是它的具体实现**‌。

#### 方法区组成

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250112110859615-2025-1-1211:09:00.png" alt="方法区结构" style="zoom:80%;" />

- **类元信息**：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表

- **常量池表**（Constant Pool Table）是 Class 文件的一部分，存储了**类在编译期间生成的静态常量、符号引用**。虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。
  
  - 静态常量：不需要后续解析，例如字符串字面量、数值字面量等。
  
    java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示。
  
    ```java
    final int a = 1;				//这个1便是字面量
    String b = "jwt";	//jwt便是字面量
    ```
  
  - 符号引用：需要进一步进行解析处理，如类、字段、方法、接口等的符号引用。
  
    在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址

- **运行时常量池**

  常量池是*.class 文件中的，当类加载到内存中后，JVM就会将常量池中的内容存放到运行时常量池中，并把里面的符号地址变为真实地址。

  运行期间可以动态放入新的常量。

#### 方法区内存溢出

​	在JDK 7及之前的版本中，JVM方法区是通过永久代（PermGen space）来实现的。当系统中存在大量的类加载，或者静态变量占用了过多的内存，就可能导致永久代内存不足，从而引发方法区内存溢出。此时，系统会抛出`java.lang.OutOfMemoryError: PermGen space`错误‌。可以通过调整`-XX:PermSize`和`-XX:MaxPermSize`参数来增加永久代的大小。

​	在JDK 8及之后的版本中，JVM方法区的实现改为了元空间（Metaspace）。元**空间使用本地内存，而不是JVM堆内存，因此其大小仅受本地内存限制。**然而，当系统中加载的类过多，或者静态变量占用了过多的内存，仍然可能导致元空间内存溢出。此时，系统会抛出`java.lang.OutOfMemoryError: Metaspace`错误‌。可以通过调整`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`参数来设置元空间内存大小。‌

减少不必要的类加载，避免静态变量占用过多内存。

### 2.6、直接内存

#### 概念

‌**直接内存是Java中一种基于操作系统内存的区域，直接分配在操作系统内存中，而不是在JVM的堆中，且不受JVM垃圾回收机制的管理**‌。常见于NIO操作时，用作数据缓冲区。由于属于操作系统内存，分配回收成本较高，但读写性能高。

直接内存主要应用于需要高效处理大量数据的场景，特别是那些对性能要求较高的应用。

使用传统IO进行大文件读写时，操作系统需要从用户态切换到内核态，从磁盘中将数据先读到内核中的缓冲区，由于java程序不能直接操作系统缓冲区数据，需要再将内核缓冲区的数据拷贝到java缓冲区中，以便用户程序进行处理。



![image-20250112182557560](https://gitee.com/cmyk359/img/raw/master/img/image-20250112182557560-2025-1-1218:26:04.png)

而采用NIO时，操作系统会开辟一片特殊的系统缓冲区，允许Java应用程序直接访问。这样，在操作系统内存和Java应用程序之间直接传输，避免了数据在用户空间和内核空间之间的频繁拷贝，提升了性能。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250112184751864-2025-1-1218:47:53.png" alt="image-20250112184751864" style="zoom:80%;" />

> 在传统的I/O模型中，数据需要在用户空间和内核空间之间频繁复制，这导致了大量的CPU和内存开销。而使用直接内存作为缓冲区，可以减少这种开销，因为数据可以直接在操作系统的内存区域中处理，而无需先复制到JVM的堆内存中。

#### 内存溢出

报错：`" java.lang.OutOfMemoryError: Direct buffer memory`

在Java程序中，可以使用`ByteBuffer.allocateDirect()`方法来分配直接内存。例如：

```java
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024); // 分配1MB的直接内存
```

ByteBuffer 有两种类型：

- 一种是基于直接内存（非堆内存）：DirectByteBuffer
- 一种是非直接内存（堆内存）：HeapByteBuffer

![0c785bdb248d0b747ef9f8abde64d93f](https://gitee.com/cmyk359/img/raw/master/img/0c785bdb248d0b747ef9f8abde64d93f-2025-1-1218:55:28.png)



|                  | 描述                                                         | 优点                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| HeapByteBuffer   | 在jvm堆上面的一个buffer，底层的本质是一个数组                | 由于内容维护在jvm里，所以把内容写进buffer里速度会快些；并且，可以更容易回收 |
| DirectByteBuffer | 底层的数据其实是维护在操作系统的内存中，而不是jvm里，DirectByteBuffer里维护了一个引用address指向了数据，从而操作数据 | 跟外设（IO设备）打交道时会快很多，因为外设读取jvm堆里的数据时，不是直接读取的，而是把jvm里的数据读到一个内存块里，再在这个块里读取的，如果使用DirectByteBuffer，则可以省去这一步，实现zero copy |



需要注意的是，直接内存的分配和释放需要由开发者手动管理。如果忘记释放已分配的直接内存，可能会导致内存泄漏和操作系统内存不足的问题。因此，在使用直接内存时，应确保在适当的时候释放内存。

此外，可以通过设置JVM参数`-XX:MaxDirectMemorySize`来限制直接内存的最大使用量。

#### 分配和回收原理

- 使用了 `Unsafe` 对象的 allocateMemory 方法完成直接内存的分配，setMemory 方法完成初始化
- 在ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory 来释放直接内存。
  

![源码分析](https://gitee.com/cmyk359/img/raw/master/img/直接内存分配和回收原理-2025-1-1221:30:59.png)



### 总结

三种常量池对比

JVM运行原理

## 三、执行引擎

### 3.1、垃圾回收

#### 如何判断对象可以回收

在Java虚拟机（JVM）中，判断一个对象是否可以被回收主要依赖于两种算法：**引用计数法**和**可达性分析算法**。

##### 引用计数法

为每个对象创建一个引用计数，当有对象引用它时，计数器加1；引用被释放时，计数器减1。当计数器的值为0时，表示该对象没有被任何引用指向，可以被回收。

- ‌**优点**‌：简单高效，实时判断对象是否可达。

- ‌**缺点**‌：无法处理**循环引用**的问题。如果两个或多个对象相互引用，即使它们没有其他外部引用，引用计数也不会降为零，导致内存泄漏。

  ![循环引用示例](https://gitee.com/cmyk359/img/raw/master/img/image-20250112215142926-2025-1-1221:51:49.png)

##### 可达性分析算法

<img src="https://gitee.com/cmyk359/img/raw/master/img/8981fe05be9e4951813435cdc8590b35-2025-1-1511:52:39.png" style="zoom:67%;" />

**Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。**

原理：从一组称为**GC Roots**的根对象出发，通过引用关系向下搜索，找到所有可以被直接或间接引用的对象。如果一个对象无法从GC Roots通过引用链找到，则被视为垃圾，可以被回收。

哪些对象可以作为GC Root？

GC Roots 是一组被认为是**活跃对象的引用**，它们是垃圾回收的起始点。

- **虚拟机栈中的引用**：每个线程都有自己的虚拟机栈，其中的局部变量和方法参数引用的对象。
- **方法区中的类静态属性**：被类的静态属性引用的对象。
- **方法区中的常量**：被常量引用的对象，通常是在方法区中定义的字符串常量等。
- **JNI（Java Native Interface）引用**：通过 JNI 引用的对象。
- **被系统类加载器加载的类**：在 JVM 中运行的系统类（如 `java.lang.String`）及其引用的对象。
- **活动线程**：所有正在运行的线程都被视为 GC Roots。
- **其他引用**：如某些特殊的引用或数据结构（例如，某些 JVM 实现可能会将特定的对象视为 GC Roots）。

##### 四种引用

在 Java 中，JVM 提供了四种引用类型，用于管理对象的生命周期和垃圾回收的行为。此外还提供了**引用队列**机制，是与**弱引用**和**虚引用**结合使用的一种机制，用于在对象被垃圾回收后接收通知。

**强引用（Strong Reference）**：

- 定义：强引用是 Java 中最常见的引用类型。只要强引用存在，垃圾回收器就不会回收被引用的对象。
- 特点：
  - 默认情况下创建的对象引用都是强引用。
  - 例如：`Object obj = new Object();` 这里的 `obj` 是一个强引用。
  - **即使在内存不足的情况下，强引用指向的对象也不会被回收。**
- 使用场景：适用于需要确保对象在整个生命周期内都存在的情况。

**软引用（Soft Reference）**：

- 定义：软引用用于描述一些有用但并非必需的对象，适合用于实现内存敏感的缓存。
- 特点：
  - **当系统内存不足时，垃圾回收器会尽可能回收软引用指向的对象，但在内存充足的情况下，软引用指向的对象不会被回收。**
  - 通过 `SoftReference` 类来创建软引用。
- 使用场景：软引用通常用于实现内存敏感的缓存。例如图片缓存、数据缓存等，能够在内存不足时自动释放不再使用的对象。

**弱引用（Weak Reference）**：

- 定义：弱引用用于描述一些非必需的对象，垃圾回收器在运行时会回收弱引用指向的对象。
- 特点：
  - 当垃圾回收器运行时，如果一个对象只被弱引用指向，那么**无论内存是否充足，该对象都会被回收。**
  - 通过 `WeakReference` 类来创建弱引用。
- 使用场景：适用于需要在内存中存储对象但不想影响其被回收的场景，例如监听器、事件处理等。

**虚引用（Phantom Reference）**：

- 定义：虚引用是最弱的一种引用类型，几乎没有实际用途。
- 特点：
  - **虚引用的存在并不会影响对象的生命周期，即使对象被虚引用指向，也可以被垃圾回收器回收。**
  - 主要用于跟踪对象的回收状态，通常与引用队列结合使用。
  - 通过 `PhantomReference` 类来创建虚引用。
- 使用场景：适用于需要在对象被回收后执行特定清理操作的场景，如释放资源、关闭文件等。

**引用队列（Reference Queue）**

- 定义：引用队列是与**弱引用**和**虚引用**一起使用的一种机制，用于在对象被垃圾回收后接收通知。
- 特点：
  - 当与弱引用或虚引用关联的对象被回收时，相关的引用会被加入到引用队列中。
  - 开发者可以通过检查引用队列来判断对象是否已被回收，并进行相应的处理。
- 使用场景：常用于资源管理和清理操作，确保在对象被回收后执行必要的清理工作。
- 工作流程：
  
  1. **创建引用队列**：使用 ReferenceQueue 类创建一个引用队列。
  
     ```java
     ReferenceQueue<MyObject> referenceQueue = new ReferenceQueue<>();
     ```
  
  2. **创建弱引用或虚引用**：创建一个弱引用或虚引用，并将其与引用队列关联。
  
     ```java
     MyObject myObject = new MyObject();
     WeakReference<MyObject> weakRef = new WeakReference<>(myObject, referenceQueue);
     ```
  
  3. **对象被回收**：当 myObject 对象被垃圾回收时，weakRef 将被加入到 referenceQueue 中。
  
  4. **处理引用队列**：调用 `poll()` 或 `remove()` 方法来检查引用队列，获取已被回收的对象的引用。
  
     ```java
     WeakReference<MyObject> ref = (WeakReference<MyObject>) referenceQueue.poll();
     while (ref != null) {
         // 对象已经被回收，可以执行清理操作
         ...
         ref = referenceQueue.poll();
     }
     
     ```
  
     

> 补充：
>
> 在 Java 中，**终结器引用**（Finalizer Reference）并不是一种正式的引用类型，而是与对象的终结方法（`finalize()`）相关的概念。每个 Java 对象都可以重写 finalize() 方法，在对象被垃圾回收前，JVM 会调用这个方法。这个方法可以用于释放非内存资源，例如关闭文件、网络连接等。当一个对象的 finalize() 方法被调用时，JVM 会将该对象的引用放入一个特殊的队列中，等待处理。存在的问题：
>
> - 对象的回收可能会延迟，直到 `finalize()` 方法执行完毕。
>- `finalize()` 方法的调用时机不确定，可能导致资源的延迟释放。
> - 如果对象的 `finalize()` 方法中抛出异常，可能会导致对象无法被正确回收。
> - 终结器引用可能会导致内存泄漏，因为如果一个对象的 `finalize()` 方法中持有对其他对象的引用，这些对象可能无法被回收。
> 
> 由于 `finalize()` 方法的缺陷，Java 9 以后引入了 `java.lang.ref.Cleaner` 类，作为一种更灵活和安全的资源管理方式。

#### 垃圾回收算法

##### 标记-清除算法（Mark-and-Sweep）

![标记-清除算法](https://gitee.com/cmyk359/img/raw/master/img/image-20250115115546268-2025-1-1511:55:47.png)



标记清除算法的基本思想是分为两个阶段：

- **标记阶段**：遍历所有可达对象，从根对象（GC Roots）开始，标记所有可达的对象。

- **清除阶段**：遍历整个堆，清除未被标记的对象，从而释放内存。

  > JVM会将这些对象的内存回收到堆的空闲列表中，供后续的对象分配使用。

优点

- **简单易实现**：标记清除算法的实现相对简单，易于理解和实现。
- **空间利用率高**：在清除阶段，所有未被标记的对象都被回收，能有效释放内存。

缺点

- **内存碎片**：标记清除算法在清除阶段只会释放未被标记的对象的内存，但不会整理已被标记的对象，导致内存碎片问题。随着时间的推移，可能会导致内存中产生大量的小块空闲内存，影响后续的内存分配效率。
- **暂停时间**：在标记和清除阶段，JVM会暂停应用程序的执行，可能导致较长的停顿时间，影响应用程序的响应性。

> 为了克服标记清除算法的缺点，后来的垃圾回收算法如标记压缩算法（Mark-Compact）和分代收集算法（Generational GC）应运而生。
>
> - **标记压缩算法**：在清除阶段不仅清除未被标记的对象，还会对存活的对象进行整理，消除内存碎片。
> - **分代收集算法**：将对象分为新生代和老年代，针对不同代的对象采用不同的回收策略，以提高垃圾回收的效率。

##### 标记-压缩算法（Mark-and-Compact）

![标记-压缩（整理）算法](https://gitee.com/cmyk359/img/raw/master/img/image-20250115124530620-2025-1-1512:45:35.png)

标记压缩算法在标记清除的基础上进行了改进，增加了内存整理的步骤：

- **标记阶段**：与标记清除相同，标记所有可达对象。
- **压缩阶段**：在清除未标记对象后，将存活的对象移动到堆的一端，整理内存，消除碎片。

**优点**：

- 消除了内存碎片，提高了内存的利用率。
- 由于对象是连续存放的，后续的内存分配效率提高。

**缺点**：

- 移动对象可能会导致指针更新，增加了实现复杂性。



##### 复制算法（Copying）

![复制算法](https://gitee.com/cmyk359/img/raw/master/img/image-20250115124610042-2025-1-1512:46:21.png)

复制算法将堆内存分为两个相等的区域（通常称为“From区”和“To区”），在垃圾回收时只使用其中一个区域。

- **From区**：当前正在使用的区域，存放新生代对象。
- **To区**：空闲区域，准备接收存活的对象。

在进行垃圾回收时，算法会从根对象（GC Roots）开始，遍历From区中的所有可达对象。将存活的对象复制到To区，并更新对象的引用。一旦复制完成，From区中的所有对象都被视为不可达的，整个From区的内存可以被直接回收。之后，From区和To区的角色会交换，To区变成From区，准备下一次的垃圾回收。

- 优点：内存碎片少，适用于存活对象较少的情况。
- 缺点：需要两倍的内存空间。

> 复制算法特别适合用于新生代的垃圾回收，因为：
>
> - 新生代中的对象生命周期较短，大多数对象在垃圾回收时会被清除。
> - 存活对象相对较少，复制的开销相对较小。

##### 分代收集算法（Generational Collection）

![image-20250115145827992](https://gitee.com/cmyk359/img/raw/master/img/image-20250115145827992-2025-1-1514:58:30.png)

- 新创建的对象，都会先分配到`Eden`（伊甸园）区
- 当`Eden`区内存不足时，会触发`Minor GC`，通常会导致较短的 STW 事件。
- 标记伊甸园与 from中的存活对象，将存活对象采用**复制算法**复制到to中，复制完毕后，伊甸园和from内存都得到释放。最终存活的对象年龄加一，并且交换from和to。
- 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（幸存区内存不足或大对象会导致提前晋升）
- 当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发`Full GC`，可能会导致较长的 STW 事件。

> 补充：
>
> 1、相关的分代GC概念
>
> - 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为
>   - 新生代收集（Minor GC / Young GC）：指目标只是新生代的垃圾收集
>   - 老年代收集（Major GC / Old GC）:指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外注意，“Major GC”这个说法现在有点混淆，在不同的资料上常有不同所指，需按照上下文区别到底是指老年代的收集还是整堆收集。
>   - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
> - 整堆收集（Full GC）：整个Java堆和方法区的垃圾收集
>
> 2、STW（stop-the-world）
>
> STW 是指在进行垃圾回收时，JVM 会暂停所有应用程序线程的执行，以便安全地进行内存清理和整理。这意味着在 GC 进行的期间，所有用户线程都会被暂停，无法执行任何代码。STW 的原因如下：
>
> - **内存管理**：在进行垃圾回收时，JVM 需要确保没有其他线程在访问或修改对象的状态。这是为了避免在回收过程中出现不一致性或数据损坏。
> - **保证安全性**：通过暂停所有线程，JVM 可以确保在标记、清除或整理对象时，所有引用都是有效的，从而保证内存的安全性。

#### HotSpot的算法实现细节

前面讲的垃圾收集算法在运行时是怎样去保证其执行效率和正确性的呢？在此分析HotSpot的算法实现细节，同时<u>为介绍各款垃圾收集器做前置知识铺垫</u>。（内容都很枯燥，可以暂时跳过，遇到相关知识的时候再返回来看，该部分内容主要参考《深入理解Java虚拟机》第三章的内容）

##### 根节点枚举

​	我们以可达性分析算法中从GC Roots集合找引用链这个操作作为介绍虚拟机高效实现的第一个例子。固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。

​	迄今为止，**所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的**，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但**根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行**——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。

​	由于目前主流Java虚拟机使用的都是准确式垃圾收集（这个概念在第1章介绍Exact VM相对于Classic VM的改进时介绍过），所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，**虚拟机应当是有办法直接得到哪些地方存放着对象引用的**。在HotSpot 的解决方案里，是使用一组称为<span style = "color: red">**OopMap**</span>的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

##### 安全点

​	在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。

​	实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到**，只是在“特定的位置”记录了这些信息**，这些位置被称为<span style = "color: red">安全点</span>（Safepoint）。<u>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</u>

​	因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“**是否具有让程序长时间执行的特征**”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

​	对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：**抢先式中断**（Preemptive Suspension）和**主动式中断**（Voluntary Suspension）.

- 抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。
- 主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。

由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式， 把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的`test`指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。

![轮询指令](https://gitee.com/cmyk359/img/raw/master/img/image-20250118112752886-2025-1-1811:27:55.png)

##### 安全区域

使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了， 但实际情况却并不一定。安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。

安全区域是指**能够确保在某一段代码片段之中，引用关系不会发生变化**，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被<u>扩展拉伸</u>了的安全点。

**当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。**

##### 记忆集与卡表

由于**对象不是孤立的，对象之间会存在跨代引用**，当进行新生代的垃圾收集时，新生代中的对象完全有可能被老年代的对象引用，为了找出该区域（新生代）中的存活对象，不得不在固定的GC Roots之外，再遍历整个老年代中所有的对象来保证可达性分析结果的正确性。老年代占用的空间更大，存活的对象更多，这样花费的时间就更长了。

> 不只是新生代和老年代之间有跨代引用问题，所有涉及部分区域收集（Partial GC）行为的垃圾收集器，如G1，ZGC，都会面临同样的问题。

为了解决跨带引用问题，垃圾收集在新生代中建立了名为<span style="color : red">**记忆表**（**Remembered Set**）</span>的数据结构，用以避免将整个老年代加入GC Roots的扫描范围。记忆集是**一种用于记录从非收集区域指向收集区域的指针集合**的<u>抽象数据结构</u>。收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针就可以了，并不需要了解这些跨代指针的具体信息。因此，记忆集有三种精度的方案来记录跨代指针：

- 字长精度：每个记录精确到一个机器字长，该字包含跨代指针。
- 对象精度：每个记录精确到一个对象，该对象中包含跨代指针。
- 卡精度：每个记录精确到一个内存区域，该区域中包含跨代指针。

为了节省记忆集的存储和维护成本，可以采用更为粗犷的记忆粒度。第三种“卡精度”所指的是使用一种称为<span style="color : red">“**卡表（Card Table）**”</span>的方式去实现记忆集，也是目前最常用的记忆集实现方式。

> 记忆集其实是一种抽象的数据结构，只定义了记忆集的行为意图，并没有定义其行为的具体实现。而卡表就是记忆集的一种具体实现，它定义了记忆集的的记录精度，与堆内存的映射关系等。

卡表最简单的实现形式可以是一个**字节数组**，而HotSpot虚拟机确实也是这样做的。

```java
// HotSpot默认的卡表标记逻辑
CARD_TABLE [this address >> 9] = 0;
```

字节数组`CARD_TABLE`的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为<span style = "color : red">**卡页（Card Page）**</span>，一个卡页中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段包含跨代指针，那就将对应卡表的数据元素标识为1，称为这个元素<span style="color : red">变脏（Dirty）</span>,没有则表示为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，只需把它们加入GC Roots中一并扫描，就能避免对整个老年代中所有对象扫描。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118110852229-2025-1-1811:09:13.png" alt="卡表和卡页对应示意图" style="zoom:80%;" />

##### 写屏障

我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。

卡表元素何时变脏的答案是很明确的——**有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻**。但问题是如何变 脏，即如何在对象赋值的那一刻去更新维护卡表呢？假如是解释执行的字节码，那相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间；但在编译执行的场景中呢？经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，**把维护卡表的动作放到每一个赋值操作之中**。

在HotSpot虚拟机里是通过<span style="color:red">**写屏障（Write Barrier）**</span>技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的**AOP**切面（类似于与Spring中的AOP操作），会在引用对象赋值前后做一些额外的动作。主要分为两个：

- **写前屏障（Pre-Write Barrier）**：引用对象赋值前的特殊处理
- **写后屏障（Post-Write Barrier）**：引用对象赋值后的特殊处理

应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。

除了写屏障的开销外，卡表在高并发场景下还面临着“**伪共享**”（False Sharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。

​	假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免伪共享问题，一种简单的解决方案是**不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏**。

在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。

##### 并发的可达性分析

​	当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，**可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行**。在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事情。

​	要知道包含“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。

想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？为了能解释清楚这个问题，我们引入<span style="color: red">**三色标记（Tri-color Marking）**</span>作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“**是否访问过**”这个条件标记成以下三种颜色：

- **白色**：**表示对象尚未被垃圾收集器访问过**。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- **黑色**：**表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。**黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- **灰色**：**表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过**。

> 关于可达性分析的扫描过程，读者不妨发挥一下想象力，把它看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。

如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作呢？收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。

- 一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。(**多标)**

- 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。（**漏标**）

  下面表演示了这样的致命错误具体是如何产生的。

![并发出现“对象消失”问题的示意图](https://gitee.com/cmyk359/img/raw/master/img/image-20250118114200926-2025-1-1811:42:11.png)

Wilson于1994年在理论上证明了，当且仅当以下两个条件**同时满足时**，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

因此，要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：**增量更新**（Incremental Update）和**原始快照**（Snapshot At The Beginning， **SATB**）。

增量更新要破坏的是第一个条件，**当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来**，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。

原始快照要破坏的是第二个条件，**当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来**，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，**CMS是基于增量更新来做并发标记的**，**G1、Shenandoah则是用原始快照来实现。**

#### GC相关的虚拟机参数

| 参数                  | 含义                                                         |
| --------------------- | ------------------------------------------------------------ |
| 堆初始大小            | -Xms                                                         |
| 堆最大大小            | -Xmx或-XX:MaxHeapSize=size                                   |
| 新生代大小            | -Xmn或（-XX:NewSize=size + -XX:MaxNewSize=size）             |
| 幸存区比例（动态）    | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 幸存区比例            | -XX:SurvivorRatio=ratio                                      |
| 晋升阈值              | -XX:MaxTenuringThreshold=threshold                           |
| 晋升详情              | -XX:+PrintTenuringDistribution                               |
| GC详情                | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC 前执行 MinorGC | -XX:+ScavengeBeforeFullGC                                    |

#### 垃圾收集器

##### 串行垃圾收集器

‌JVM串行垃圾回收器是**单线程**的垃圾回收器，用于新生代和老年代的垃圾回收‌。

串行垃圾回收器主要分为**Serial**（用于新生代）和**Serial Old**（用于老年代）。

- Serial作用于新生代，采用**复制算法**
- Serial Old作用于老年代，采用**标记-整理算法**

垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

![image-20250115214257033](https://gitee.com/cmyk359/img/raw/master/img/image-20250115214257033-2025-1-1521:43:11.png)



**优点**

- 实现简单
- 内存占用小：由于只使用单线程，串行垃圾回收器的内存占用较小，适合资源有限的环境。
- 适合小型应用：在小型应用程序或内存需求不高的场景中，串行垃圾回收器能够提供良好的性能。

**缺点**

- 不适合多核处理器：串行垃圾回收器只能使用一个线程进行垃圾回收，无法充分利用多核处理器的计算能力，导致性能瓶颈。
- 较长的停顿时间：由于在垃圾回收期间暂停所有应用程序线程，可能导致较长的停顿时间，影响用户体验。
- 不适合大规模应用：在内存需求较高或对象存活时间较长的应用中，串行垃圾回收器可能导致性能下降和响应延迟。



JVM参数：

```bash
-XX:+UseSerialGC  #启用串行垃圾回收器
```



##### 并行垃圾收集器

JVM并行垃圾收集器是一个**多线程**的收集器，它通过使用多个线程并行执行垃圾回收任务，用于在多个处理器或多线程硬件上加速应用程序的吞吐量‌。

**Parallel New**和**Parallel Old**是一个并行垃圾回收器，**JDK8默认使用此垃圾回收器**

- Parallel New作用于新生代，采用复制算法
- Parallel Old作用于老年代，采用标记-整理算法

![image-20250115220147508](https://gitee.com/cmyk359/img/raw/master/img/image-20250115220147508-2025-1-1522:01:49.png)

**优点**

- 高吞吐量：并行垃圾收集器能够充分利用多核处理器，通过并行执行垃圾回收任务，提高了整体吞吐量。
- 适合长时间运行的应用：对于需要长时间运行的应用程序（如服务器应用），并行垃圾收集器能够有效减少内存的使用和回收时间。
- 较短的停顿时间：由于多个线程同时工作，垃圾回收的时间相对较短，尽管仍然会出现停顿，但相比于串行垃圾回收器会有所改善。

**缺点**

- STW 停顿：尽管并行垃圾收集器减少了停顿时间，但在进行垃圾回收时仍然会暂停所有应用程序线程
- 内存使用：内存使用的增加，因为并行回收需要更多的内存来存储线程的状态和堆的结构。

**JVM参数**

- 启用并行垃圾收集器（启用其中一个，另一个也会自动启用）

  ```bash
  -XX:+UseParallelGC  #启用新生代并行垃圾收集器
  -XX:+UseParallelOldGC #启用老年代并行垃圾收集器
  ```

- 设置并行线程的数量

  ```bash
  -XX:ParallelGCThreads=<number>
  ```

- 允许 JVM 根据运行时的内存使用情况动态调整堆的大小和各个代的比例

  ```bash
  -XX:+UseAdaptiveSizePolicy
  ```

- 控制垃圾回收时间与应用程序运行时间的比率 (**影响垃圾回收的频率**)

  ```bash
  -XX:GCTimeRatio=ratio
  #ratio 是一个整数值，表示在 100 个时间单位中，允许垃圾回收占用的最大时间。
  #该参数的设置会影响垃圾回收的频率和策略。
  #较低的 GCTimeRatio 值会使 JVM 更加频繁地进行垃圾回收，以保持应用程序的响应性，而较高的值则可能导致更少的垃圾回收。
  ```

- 设置垃圾回收的最大停顿时间 (**影响每次垃圾回收的持续时间**)

  ```bash
  -XX:MaxGCPauseMillis=ms
  #ms 是一个整数值，表示最大期望的停顿时间,默认设置为 200ms
  #当启用此参数时，JVM 会尽量调整垃圾回收的策略，以满足这一停顿时间的要求。这可能会导致更频繁的垃圾回收或使用不同的回收算法，以确保停顿时间在设定的阈值内。
  ```

> `-XX:GCTimeRatio` 可以影响垃圾回收的频率，而 `-XX:MaxGCPauseMillis` 则可以影响每次垃圾回收的持续时间。这两个参数可以结合使用，以优化 Java 应用程序的性能，减少停顿时间，提高响应能力。合理配置和调优这两个参数将有助于满足不同应用程序的性能需求。

##### CMS（并发）垃圾收集器

CMS全称 Concurrent Mark Sweep，是一款**并发**的、使用**标记-清除算法**的垃圾回收器，该回收器是**针对老年代**垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是**在进行垃圾回收时，应用程序仍然能正常运行**。

![image-20250115224356132](https://gitee.com/cmyk359/img/raw/master/img/image-20250115224356132-2025-1-1522:43:57.png)

CMS 垃圾收集器的工作过程主要分为以下几个阶段：

1. ‌**初始标记**‌：标记存活的对象，此阶段会引发STW，但时间较短‌（只需标记直接可达的对象）
2. **并发标记**‌：沿着初始标记阶段标记的对象寻找存活对象，该阶段与应用程序并发运行‌
3. **重新标记**：标记在并发标记阶段中发生变更的对象，此阶段也会引发STW，但时间相对较短‌
4. **并发清除‌**：清除未被标记的对象，该阶段与应用程序并发运行‌



在CMS的并发标记阶段，应用程序线程可能会创建新的对象引用或修改现有的对象引用。为了确保这些新增的对象引用能够被正确标记，CMS使用了**增量更新**技术。增量更新通过写屏障来实现。当写屏障检测到新增的跨代引用时，它会将这些引用记录到一个增量更新队列中。在并发标记的后续阶段（如重新标记阶段），CMS会遍历这个增量更新队列，重新扫描这些新增的引用，并将它们标记为存活对象。

> 其中**初始标记**、**重新标记**这两个阶段仍然需要 "Stop The Wold"

**优点**

- **低停顿时间**：CMS 垃圾收集器的并发特性使得大部分垃圾回收过程可以在应用程序运行时进行，从而显著减少了停顿时间。

**缺点**

- **对处理器资源敏感**：在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。

- **无法处理浮动垃圾，并且可能发生Concurrent Mode Failure（并发模式失败）**

  ​	浮动垃圾是指在并发标记阶段完成后，但在实际的清除阶段之前，被创建或引用的新对象。由于这部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。

  ​	由于在垃圾收集阶段用户线程还需要持续运行，就需要预留足够的内存空间供给用户线程使用，因此CMS会在老年代空间使用达到一定比例（默认值为92%）后就开始执行清理。如果设定的CMS启动阈值太大，导致预留的内存空间无法满足程序分配新对象的需要，就会出现“并发失败”。此时，JVM会冻结用户线程执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这种情况下停顿时间就很长了。

- **产生内存碎片**：CMS 使用的是标记-清除算法， 在清除未被标记的对象后，可能会导致内存碎片的产生。这可能会影响老年代的可用内存，导致 Full GC（完全垃圾回收）的发生。

**JVM参数**

- 启用 CMS 垃圾收集器

  ```bash
  -XX:+UseConcMarkSweepGC
  ```

- 设置并发标记的线程数

  ```bash
  -XX:ConcGCThreads=<number>
  ```

- 设置CMS 的触发百分比（默认为92%）

  ```bash
  -XX:CMSInitiatingOccupancyFraction=percent
  ```

- 在执行重新标记阶段之前，会先执行一次新生代的垃圾回收

  ```bash
  -XX:+CMSScavengeBeforeRemark
  #通过清理新生代，可以减少需要在老年代进行标记的对象数量，降低老年代的内存压力，从而降低 Full GC的发生概率。
  ```

##### G1 垃圾收集器

G1（**Garbage First**）垃圾回收器不同于上述的几款垃圾回收器，其采用独特的**内存管理策略**，实现对整个堆空间的垃圾回收。

G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（**Region**）,每个Region都可以根据需要，扮演新生代的eden空间、Survivor空间、或者老年代空间。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250116233802743-2025-1-1623:38:07.png" alt="G1垃圾回收器的Region图示" style="zoom:80%;" />

其中区域Region的内存大小默认是通过整个堆内存大小除以`2048`得到的，例如整个堆内存为`4G`，则Region = 4G / 2048 = 2M，同时也支持通过JVM参数来指定Region的内存大小。

Region中还有一类特殊的`Humongous`区域，专门用来存放大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。对于超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region中。G1会把Humongous Region作为**老年代**的一部分来看待（由于大对象的复制成本较高，直接放入老年代可以减少内存碎片和复制开销）。

G1收集器突出表现出来的一点是通过一个停顿预测模型来根据**用户配置的收集停顿时间**（默认为200ms）来选择Region组成**回收集（Collection Set，简称CSet）**，优先处理这些回收价值收益最大的Region，即那些大部分空间是可回收垃圾的区域。这种策略使得G1能够高效地回收垃圾，同时减少停顿时间。这也是G1得名“Garbage-First”的原因‌。

> 关于停顿时间的设置不是越短越好，设置的太短导致每次选出来的回收集只占堆内存的一小部分，回收速度赶不上分配速度，导致垃圾慢慢堆积，最多占满堆引发Full GC反而降低了性能。停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。通常将其设置为一两百或者两三百毫秒是比较合适的。

G1垃圾收集器如何建立起可靠的停顿预测模型？G1垃圾收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集的都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。用户可以使用JVM参数指定收集的停顿时间，G1收集器会记录每个Region的回收耗时、每个Region记忆集中的脏卡数量等各个可测量的步骤花费的成本，并得出平均值、标准偏差、置信度等统计信息，然后通过这些信息预测现在开始回收的话，由哪些Region组成的回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

G1从整体来看是基于 标记-整理算法实现的，但从局部（两个Region之间）上看又是基于 标记-复制算法实现，无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎块。

JVM参数

- 启用G1的垃圾回收器

  ```bash
  -XX:+UseG1GC
  ```

- 指定Region的内存大小

  ```bash
  -XX:G1HeapRegionSize=n
  ```

- 设置最大暂停时间（默认200ms）	

  ```bash
  -XX:MaxGCPauseMillis=n
  ```

- 指定垃圾回收工作的线程数量

  ```bash
  -XX:ParallelGCThreads=n
  ```

  

##### G1垃圾收集器原理

G1垃圾回收有两种方式：新生代回收（**Young GC**）和 混合回收（**Mixed GC**）

- Young GC：主要针对新生代区域的垃圾回收，包括`Eden`区和`Survivor`区。当所有`Eden`区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次Young GC，回收`Eden`区和`Survivor`区，复制移动到另外的`Survivor`幸存者（年龄+1）或Old老年代区（提前晋升的）.
- Mixed GC：Mixed GC是G1垃圾回收器**独有的**，针对新生代和部分老年代区域的垃圾回收。当老年代的占有率达到阀值（默认45%）或新生代被分配大对象时，会触发一次Mixed GC，回收所有新生代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。

###### Young GC原理

G1垃圾回收器新生代回收时，采用了三种关键技术，分别是**记忆集**、**卡表**和**写屏障**。接下来我们层层递进，研究一下这些技术分别解决了什么问题。

当G1触发**Young GC**时，只会扫描新生代区域（扮演`Eden`区 和 `Survivor`区的Region）的对象，从`GC Root`根对象出发时，很容易扫描出新生代的对象以及新生代对象引用的其它新生代的对象。但对象不是孤立的，对象之间会存在跨代引用，新生代中的对象完全有可能被老年代的对象引用。

为了解决跨Region的引用对象问题，G1使用[记忆集](https://www.catpaws.top/f0242a65/#记忆集与卡表)来记录跨代引用，避免对全部扮演老年代的Region的扫描。在G1收集器上记忆集的应用要复杂很多，它将所有的`Region`区域按大小划分为多个分块，称为**卡页（Card Page）**，并对每个卡页进行编号。每个`Region`都维护有自己的记忆集，每个`Region`区域都会有额外配备一小块内存，这块内存称为**卡表（Card Table）**，用于记录整个堆空间中有哪些卡页引用了自己`Region`区域的对象。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118135812675-2025-1-1813:58:17.png" style="zoom:80%;" />

卡表的底层数据结构是字节数组，每一个字节对应一个卡页，当某个卡页中的对象引用自己`Region`区域的对象时，会将卡表对应编号位置的字节修改为`1`，为`1`的字节被称之为**脏卡**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118140108976-2025-1-1814:01:10.png" style="zoom:80%;" />

此时，进行Yong GC时，只用遍历各个`Region`的卡表，找到所有字节为`1`的脏卡，将其也加入到`GC Root`根对象集合中，就能确保被老年代引用的新生代对象标记为存活，也避免了对所有老年代对象的扫描。

更新卡表状态的底层采用了**写屏障**技术（具体为写后屏障），当执行对象引用相关的代码时，会在其代码前后插入对应的指令。写屏障类似与Spring中的`AOP`，会在引用对象赋值前后做一些额外的动作，主要分为两个：

- **写前屏障**：引用对象赋值前的特殊处理
- **写后屏障**：引用对象赋值后的特殊处理

写后屏障指令判断到老年代对象引用年轻代对象时，会更改卡表中对应的字节为脏卡，同时会将脏卡放入到一个**脏卡队列**中，**JVM会通过单独的线程，定期读取脏卡队列中的数据，更新记忆集**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118141509292-2025-1-1814:15:10.png" style="zoom:80%;" />

###### Mixed GC原理

混合回收是针对**年轻代**和**部分老年代**区域的垃圾回收，当老年代内存占用率达到设定阈值，或分配大对象时，将会触发混合回收**Mixed GC**。

由于`Old`老年代区往往存在较多对象，G1垃圾回收器为提升执行效率，减少STW，部分耗时较长的阶段采用了与用户线程并发执行。

> 由于用户程序要继续运行，在这个过程中肯定会持续有新对象被创建，G1为每个Region设计了两个名为 **TAMS** (Top at Mark Start)的指针，把Region中的一部分空间划分出来用于并发回收过程中新对象的分配，并发回收时新分配的对象地址都必须在这两个指针的位置以上。G1收集器默认在这个地址以上的对象都是被隐式标记过的，即默认它是存活的，不纳入回收范围。
>
> 与CMS中的并发失败导致Full GC类型，如果内存回收速度赶不上内存分配速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间的STW。

同时为进一步提升处理速度，以及解决并发阶段可能存在的对象引用变化问题，采用**三色标记**和**SATB**技术。总体分为**初始标记**、**并发标记**、**最终标记**、**筛选回收**四个阶段。

1. **初始标记**

   初始标记阶段仅仅是标记一下GC Roots能直接关联到的对象，并且修改**TAMS**指针的值，让下一阶段用户线程并发运行时能正确地在可用的Region内分配对象。

   该阶段需要线程停顿，但耗时很短，而是借用进行 Minor GC的时候同步完成的。

   实际上，标记对象其实是通过**位图**（**bitmap**）实现的。在对象的内存布局中，G1会使用一个标记位图来记录对象是否被标记。每个对象都有一个标记位，初始状态为未标记（或清除状态），对于每个从GC Roots可达的对象，G1会在对象的标记位中设置标记，表示该对象是存活的。

2. **并发标记**

   从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可以与用户线程并发执行。

   由于应用程序线程仍在运行，可能会产生新的对象引用关系或者修改了已有对象的引用关系，导致标记结果不准确。为了解决这个问题，G1收集器采用了[三色标记法](https://www.catpaws.top/f0242a65/#并发的可达性分析)，并使用原始快照（**SATB**）解决并发标记阶段可能产生的对象引用变化问题。

   SATB算法通过**写前屏障**来破坏“对象消失”问题的条件。在并发标记过程中，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来。这些记录的信息在<u>最终标记</u>阶段被用来修正并发标记过程中可能出现的误标或漏标情况，从而确保标记的准确性。

   > CMS垃圾回收器也使用到了三色标记算法，但它使用**增量更新**解决并发中对象引用变化问题

3. **最终标记**

   最终标记阶段会暂停用户线程，主要用于**修正并发标记期间产生变动的对象**。

   G1会遍历在并发标记期间记录的写屏障信息，检查哪些对象的引用发生了变化。对于这些引用，G1会再次从GC Roots出发，标记所有新增的可达对象。

4. **筛选回收**

   负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region中的存活对象复制到空的Region中，再清理掉旧Region的全部空间。这里的操作设计存活对象的移动，必须暂停用户线程，由多条收集器线程并行完成。

![Mixed GC运行示意图](https://gitee.com/cmyk359/img/raw/master/img/image-20250118152622942-2025-1-1815:26:24.png)

> 除了并发标记阶段，其余三个阶段都需要暂停用户进程

##### ZGC 收集器

[参考文章](https://blog.csdn.net/qq_42192693/article/details/145106593)

#### 垃圾回收调优



## 四、类加载和字节码技术

### 4.1、类文件结构

根据JVM规范，类文件结构如下：

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问修饰
    u2             this_class;//当前类信息
    u2             super_class;//父类信息
    u2             interfaces_count;//包含接口的数量
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段数量
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一	个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

将以下代码使用 `javac`编译成Class文件后，使用idea的 BinEd插件查看其十六进制内容。
```java
package ClassStructureExplore;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119111901788-2025-1-1911:21:44.png" style=" width: 80%;height: auto;">

#### 魔数

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119154747077-2025-1-1915:47:48.png" style="zoom:80%;" />

每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）。

0-3字节，表示它是否是【class】类型的文件。

- 魔数值固定为 `0xCAFEBABE`，不符合则会抛出错误

#### 版本

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119154830103-2025-1-1915:48:31.png" style="zoom:80%;" />

4-7字节，共4个字节。其中 4-5字节代表的是编译的副版本号 minor_version，6-7字节是编译的主版本号 major_version

案例中`0x0037`转化为十进制为55，代表JDK 11（56 代表JDK 12，以此类推）

#### 常量池

第8、9字节为`constant_pool_count`，即常量池长度。constant_pool 是一种表结构以 1 ~ constant_pool_count - 1 为索引，表明有多少个常量池表项。案例中第8、9字节为`0x001F`（31），表示常量池有#1~#30项，注意#0 项不计入，也没有值。

表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池

- 字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等


- 符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

![](https://gitee.com/cmyk359/img/raw/master/img/8832b8158e55fe19bef734c32fc91767-2025-1-1915:42:18.png)

> 查表方法：例如标志为`0x0A`，转化为十进制为10，查表得标志为10对应的常量是 `CONSTANT_Methodref_info` 方法引用信息，其中信息包含三部分，分别为 `tag` 1字节值为10，两个索引项`index`分别占两个字节，指向方法的所属类和方法名称在常量池中的位置索引。

尝试分析：

第 #1 项 标志为`0x0A` 表示一个方法引用信息。`0x0006`和`0x0011` (17) 表示它引用了常量池中#6 和#17 项来获得这个方法的【所属类】 和 【方法名】

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119155347744-2025-1-1915:53:49.png" style="zoom:67%;" />



第 #2 项 标志为`0x09` 表示一个字段的引用信息，`0x0012`（18）和`0x0013`（19）表示 它引用了第常量池中的第 #18、#19项来获得这个字段的【所属类】和【字段描述】

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119155347744-2025-1-1915:53:49.png" style="zoom: 67%;" />

第 #3 项，标志为`0x08`表示它是一个字符串字面量，`0x0014`(20)表示该字符串的字面量保存在常量池中第 #20 项。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119161400969-2025-1-1916:14:02.png" style="zoom: 67%;" />

第 #4 项，标志为`0x0A` 表示是一个方法引用信息，`0x0015`和`0x0016` 表示引用了第常量池中的第 #21、#22项来获得这个方法的【所属类】 和 【方法名】。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119161851115-2025-1-1916:18:52.png" style="zoom: 67%;" />

第 #5 项，标志为`0x07`表示一个 Class信息，`0x0017`表示它引用了常量池中#23 项

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119162125562-2025-1-1916:21:26.png" style="zoom: 67%;" />

第 #6 项， 标志为`0x07`表示一个Class信息，`0x0018`表示它引用了常量池中#24 项

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119162540728-2025-1-1916:25:42.png" style="zoom: 67%;" />

第 #7 项，标志为`0x01` 表示一个utf8 字符串，`0x0006` 表示字符串长度为 6，字符串内容为`<init>`

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119163514390-2025-1-1916:35:15.png" style="zoom: 67%;" />

第 #8 项，标志为`0x01` 表示一个utf8 字符串，`0x0003` 表示字符串长度为 ，字符串内容为`()V`，表示方法无参、无返回值。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119173448460-2025-1-1917:34:57.png" style="zoom:67%;" />

......依次分析下去。

可以使用`javap -v xxx.class >xxx.txt`将Class文件反编译并写入到一个txt文件中进行查看，其中常量池信息如下，可以和上面字节码的分析结果对比，二者是吻合的。

![image-20250119174911689](https://gitee.com/cmyk359/img/raw/master/img/image-20250119174911689-2025-1-1917:49:43.png)

#### 访问标识

访问标识（access_flag），又叫访问标志、访问标记，访问标识符用于描述类或接口的访问权限（如 public、private 等）、是否为抽象类、是否为接口、是否声明为 final 等信息。

访问标识符在 Java 字节码文件中占用**两个字节**（16位），这些位被用来表示不同的访问权限和特性。

访问标识符的具体内容‌：

![](https://gitee.com/cmyk359/img/raw/master/img/image-20250119182107640-2025-1-1918:21:10.png)

访问标识符是通过位操作来组合的。例如，如果一个类既是 public 的又是 final 的，那么它的访问标识符将是 ACC_PUBLIC（0x0001）和 ACC_FINAL（0x0010）的并集，即 0x0011。

在案例中，该类的访问修饰符为`0x0021` = `0x0020` + `0x0001`，代表 ACC_PUBLIC 和 ACC_SUPER

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119182524858-2025-1-1918:25:26.png" style="zoom: 80%;" />

#### 索引集合

‌**本类索引、父类索引、接口索引**，这些索引用于确定类的继承关系，包括类的名称、父类的名称、实现的接口列表等。这些值指向常量池中的对应常量。

- 本类索引：用于确定这个类的全限定名

  当前案例中，`0x0005`: cp_info #5 (即常量池第5项) -> cp_info #23 -> ClassStructureExplore/HelloWorld

- 父类索引：用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个

  当前案例中，`0x0006`: cp_info #6 -> cp_info #24 ->java/lang/Object

- 接口索引集合：用来描述这个类实现了哪些接口

  - interfaces_count 表示接口数量
  - interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中

  当前案例中，`0x0000`：表示当前类没有实现接口

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119184458104-2025-1-1918:45:06.png" style="zoom:80%;" />

#### 字段表集合

​	字段 fields 用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量（local variables）以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述。

- `fields_count`（字段计数器）：表示当前 class 文件 fields 表的成员个数，用两个字节来表示

  本案例中，`0x0000`表示当前 class 文件没有字段

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119185852407-2025-1-1918:58:53.png" style="zoom:67%;" />

- `fields[]`（字段表）: fields表中的每个成员都是一个 `fields_info `结构的数据项，用于表示当前类或接口中某个字段的完整描述

#### 方法表集合

#### 属性表集合