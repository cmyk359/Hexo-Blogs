---
title: 五、树和二叉树
abbrlink: 453281de
categories:
  - 数据结构
date: 2024-12-07 12:32:13
tags:
  - 树
  - 二叉树
  - 线索二叉树
  - 哈夫曼树
  - 并查集
math: true
---

<meta name="referrer" content="no-referrer" />

## 一、树的基本概念

### 1.1、树的定义

树的定义：树是一种递归的数据结构，是n（n≥0）个结点的有限集。当n=0时，称为空树。在任意一棵非空树中满足：

- 有且仅有一个根节点
- 当n>1时，其余节点可分为m(m>0)个不相交的有限集T1,T2,..Tm，其中每个集合本身又是一棵树，并且称为根的子树

非空树的性质：

- 有且仅有一个根结点。
- 根结点没有前驱，除根结点外的所有结点有且仅有一个前驱。
- 每个结点可以有0个或多个后继。
- 没有后继的结点称为叶子结点，有后继的结点称为分支结点。

树是一种递归的数据结构，是一种**逻辑结构**，也是一种分层结构，适合于表示具有层次结构的数据。



### 1.2、基本术语

结点之间关系的描述：

- 祖先结点：从该结点到根结点的唯一路径上的所有结点，均是其祖先结点。
- 子孙结点：从该结点出发的所有分支中的结点，都是其子孙结点。

- 双亲结点（父结点）：一个结点的直接前驱是其父结点。
- 孩子结点：一个结点的直接后继是其孩子结点。

- 兄弟结点：有相同双亲的结点称为兄弟结点。
- 堂兄弟结点：双亲在同一层的结点互为堂兄弟。



- 路径：树中两个结点之间的路径是由这两个结点之间所经过的**结点序列**构成。由于树中的分支是有向的，即双亲指向孩子，所以**树中的路径是从上向下的**。
- 路径长度：路径上所经过的**边的个数**。
  - 树的路径长度：从根结点到每个结点的路径长度之和（注意和哈夫曼树的带权路径长度相区别）
  - 树的内路径长度：除叶结点外，从根到树中其他所有结点的路径长度之和
  - 树的外路径长度：从根结点到树中所有叶子结点的路径长度之和

结点、树的属性描述：

- 结点的层次（深度）：是从根结点开始**自顶向下**逐层累加的。（水面）
- 节点的高度：从叶节点开始**自底向上**逐层累加的。（高楼）
- 树的高度（深度）：总共有多少层。



- 结点的度：孩子的个数称为该结点的度。
- 树的度：各结点度的最大值。



- 有序树：逻辑上看，树中的各个子树从左至右是有次序的，不能互换。
- 无序树：逻辑上看，树中的各个子树从左至右是没有次序的，可以互换。

具体看需要用树存储什么信息，是否需要用节点的左右位置来反应某些逻辑关系，若需要则为有序树，否则为无序树。

- 森林：m(m≥0)个互不相交的树的集合

  

### 1.3、树的常考性质

- **总结点数 = 总度数  + 1** （总度数即树所有分支的个数，即除根结点外所有结点的个数）

- 度为m的树和m叉树

  - 度为m的树：树中所有结点的最大度数为m

  - m叉树：每个结点最多有m个孩子的树，即每个结点的度最大是m，也可以为0

  | 度为m的树                     | m叉树                   |
  | ----------------------------- | ----------------------- |
  | 任意结点的度 ≤ m              | 任意结点的度 ≤ m        |
  | 至少有一个度为m的结点         | 允许所有结点的度均小于m |
  | 一定是非空树，至少有m+1个结点 | 可以是空树              |

- 度为m的树第i层至多有$m^{i-1}$个结点。（第一层有一个，第二层有m个，第三层有$m^2$个，以此类推）

  m叉树的第i层至多有$m^{i-1}$个结点。

- 高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点（等比数列求和），至少有h个结点

- 高度为h，度为m的树至多有$\frac{m^h-1}{m-1}$个结点，至少有h+m-1个结点

- 具有n个结点的m叉树，其最大高度为n，最小高度为$\lceil \log_m{[n(m-1)+1]}\rceil$。

  具有n个结点的度为m的树，其最大高度为$n-m+1$,最小高度为$\lceil \log_m{[n(m-1)+1]}\rceil$。

  - 推导：设最小高度为h，则前h-1层最多共有 $\frac{m^{h-1}-1}{m-1}$个结点，前h层最多共有$\frac{m^h-1}{m-1}$个结点

    $\therefore$     $\frac{m^{h-1}-1}{m-1}$ < $n $  ≤ $\frac{m^h-1}{m-1}$

    $\therefore$    $m^{h-1}$ < $n(m-1) + 1$ ≤ $m^h$

    $\therefore$      $h-1$  < $log_m{[n(m-1)+1]}$  ≤ $h$

    $\therefore$     $h = \lceil log_m{[n(m-1)+1]}\rceil$

- 对度为m的树，$n_i$表示度为$i$的结点个数  
  - 总结点数  $=n_0+n_1+...+n_m$，其中$n_0$表示叶子结点的个数
  - 总度数 $=n_1*1+n_2*2+...+n_m*m$，总度数即总分支数，度为$i$的结点有$n_i$个，度为$i$的结点引出$i$条分支。
  - 总结点数 = 总度数 + 1。

## 二、二叉树

### 2.1、二叉树的定义及特性

**定义**：二叉树是n（n≥0）个结点的有限集合：

- 或者为空二叉树，即$n=0$
- 或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。

特点：每个结点至多有两棵子树；**二叉树是有序树，左右子树不能颠倒。**

**区分二叉树和度为二的有序树**：

- 度为$2$的有序树至少有$3$个结点，而二叉树可以为空。
- 度为$2$的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这孩子就无须区分其左右次序。而二叉树无论其孩子数是否为$2$，均需确定其左右次序，即**二叉树的结点间次序不是相对于另一结点而言，而是确定的。**



### 2.2、几个特殊的二叉树

**满二叉树**

一棵高度为$h$，且含有$2^h-1$个结点的二叉树，即树中每层都含有最多的结点。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216152040612-2024-12-723:06:46.png" alt="image-20230216152040612" style="zoom: 50%;" />

- 只有最后一层有叶子结点
- 不存在度为 $1$ 的结点
- 按层序从 $1$ 开始编号，结点 $i$ 的左孩子为 $2i$ ,结点 $i$ 的右孩子为 $2i+1$ ；$i$ 结点的父节点为 $\lfloor i/2\rfloor$（如果有的话）。
  - 对于一棵满m叉树，按层序从1开始编号，结点$i$的第一个孩子编号为 $(i-1)*m+2$，结点$i$的双亲结点编号为 $ \lfloor \frac{(i-2)}{m} \rfloor +1$。
  - 推导：首先对于第$i$个分支结点，其前面有 $i-1$个分支结点，而每个分支结点都有$m$个孩子，故第$i$个分支结点的第一个孩子前 共有 $(i-1)*m+1$个结点（1是根结点），故其第一个孩子的编号为$(i-1)*m+2$；反推得，结点$i$的双亲结点编号为$\lfloor \frac{(i-2)}{m} \rfloor +1$。
- n个结点的满二叉树中有 $\color{red} \frac{n+1}{2}$个叶子结点。（$n = 2^h-1$，叶子结点个数为 $2^{h-1} = \frac{n+1}{2}$ ）

**完全二叉树**

当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。（在对应满二叉树的基础上，去掉一些<u>连续的编号更大的</u>结点后，即为完全二叉树。）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216153410676-2024-12-723:06:59.png" alt="image-20230216153410676" style="zoom:50%;" />

- 只有最后两层可能有叶子结点

- **最多存在一个度为 $1$ 的结点，且该结点只有左孩子而没有右孩子。**

- 编号规则和满二叉树相同

- 总结点数为$n$ ，编号为 $i$ 的结点，$i \leq \lfloor n/2 \rfloor$ 时为分支结点，$i \geq \lfloor n/2 \rfloor$ 时为叶子结点。（$\lfloor n/2\rfloor$,即$\lfloor 前 h-1层结点个数\rfloor$）


> 满二叉树是一种特殊的完全二叉树，但完全二叉树不一定是满二叉树。

**二叉排序树**

- 定义：一棵二叉树或者是空二叉树，或者是具有以下性质的二叉树

  - 左子树上所有结点的关键字均小于根结点的关键字
  - 右子树上所有结点的关键字均大于根结点的关键字
  - 左子树和右子树又分别是一棵二叉排序树

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155034041-2024-12-723:07:08.png" alt="image-20230216155034041" style="zoom:50%;" />

- 二叉排序树可用于元素的排序、搜索，若一棵二叉排序树是平衡二叉树，其效率会高很多。

**平衡二叉树**

- 树上任一结点的左子树和右子树的深度之差不超多 $1$。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155116782-2024-12-723:07:14.png" alt="image-20230216155116782" style="zoom: 50%;" />

### 2.3、二叉树的常考性质

- **$n$ 个结点可以构成 $\color{red} \frac{1}{n+1} C_{2n}^{n}$ （卡特兰数）个不同的二叉树**

- 设**非空二叉树**中度为0、1、2的结点的个数分别为 $n_0,n_1，n_2$，则 $\color{red}n_0 = n_2 + 1$。**（叶子结点比二分支结点多一个）**

  推导：总结点数 $n = n_0 + n_1 + n_2$，$n = n_1 + 2n_2 + 1$，故 $n_0 = n_2 + 1$

- 二叉树第 $i$ 层最多有 $2^{i-1}$ 个结点 
- 高度为 $h$ 的二叉树至多有 $2^h - 1$ 个结点 （满二叉树）。

完全二叉树的常考性质：

- **具有 $n$ （$n>0$）个结点的完全二叉树，其高度为 $\lceil log_2{(n+1)}\rceil$或 $\lfloor log_2n\rfloor +  1$。**

  **同理，第 $i$ 个结点所在的层次为  $\lceil log_2{(i+1)}\rceil$或 $\lfloor log_2i\rfloor +  1$。**

  推导：高为 $h$ 的二叉树至多有 $2^h - 1$个结点，高度为 $h-1$ 的二叉树至多有 $2^{h-1} - 1$ 个结点

  ​					$\therefore$						$2^{h-1} -1 < n \le 2^h -1$ 

  ​					$\therefore$                         $h-1 < log_2{(n+1)} \le h$

  ​					$\therefore$ 						$h = \lceil log_2{(n+1)}\rceil$

  ​			或者，高为 $h-1$ 的二叉树至多有 $2^{h-1} -1 $个结点，故高为 $h$ 的二叉树至少比其多一个结点，为$2^{h-1}$个；高为 $h$ 的二叉树至多有 $2^{h} -1 $个结点，故高为 $h+1$ 的二叉树至少比其多一个结点，为$2^h$个

  ​					$\therefore$ 						$2^{h-1} \le n <2^h$

  ​					$\therefore$ 						$h-1 \le log_2n < h$

  ​					$\therefore$ 						$h = \lfloor log_2n\rfloor + 1$

- 高度为 $h$ 的完全二叉树至少有 $2^{h-1}$个结点，最多有 $2^h -1$个结点。

- **对于完全二叉树，可由结点数 $n$ 推断出度为 $0,1,2$的结点个数 $n_0,n_1,n_2$。**

  $\because$ 完全二叉树最多有一个度为 1 的结点，故 $n_1 = 0$或$1$

   又$\because$ $n_0 = n_2 + 1$， $\therefore$ $n_0 + n_2 = 2 n_2 + 1$

  $\therefore$  $ \color{red} n_0 + n_2 一定是奇数$

  当结点数$n =2k$个为偶数时，$n_1 =1, n_0 =k,n_2=k-1$；即 $n_1 =1, n_0 =\frac{n}{2},n_2={\frac{n}{2}-1}$

  当结点数$n = 2k-1$个为奇数时，$n_1 =0, n_0 =k,n_2=k-1$；即$n_1 =0, n_0 =\frac{n+1}{2},n_2=\frac{n+1}{2}-1$

### 2.4、二叉树的存储结构

**二叉树的顺序存储**

​	二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。

​	依据二叉树的性质，**满二叉树和完全二叉树用顺序存储比较合适**，对一般的二叉树，为了让数组下标反映二叉树中结点之间的关系，只能添加一些空结点，造成存储空间的大量浪费。

**二叉树的链式存储**

```c++
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

**在含有$n$ 个结点的二叉链表中，有$n+1$个空链域。**



### 2.5、二叉树的遍历

二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，且仅被访问一次。

遍历一棵二叉树便要决定对根节点$N$ ,左子树 $L$ 和右子树 $R$ 的访问顺序，常见的遍历次序有 先序$(NLR)$、中序$(LNR)$、后序$(LRN)$三种遍历方法。**其中的”序“是指访问根结点在何时被访问。三种遍历算法中，遍历左、右子树的顺序是固定的，只是访问根结点的顺序不同，所以叶子结点的先后顺序是完全相同的。**



#### 先序遍历（NLR）

> 递归遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preOrder(root,res);
        return res;
    }
    public void preOrder(TreeNode root, List<Integer> res) {
        if (root == null) return; 
        res.add(root.val);
        preOrder(root.left,res);
        preOrder(root.right,res);
    }
}
```

> 非递归遍历

- 首先根节点入栈。
- 此后，若栈不为空，则弹出栈顶元素访问。若栈顶元素右孩子不为空，则先入栈右孩子；若栈顶元素左孩子不为空，则再入栈左孩子。（由于栈后进先出的特性，入栈时先右后左，出栈处理时先左后右）

```java
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>(); 
        if (root != null) {
            Stack<TreeNode> nodeStack = new Stack<TreeNode>();
            TreeNode node;
            nodeStack.push(root);
            while (!nodeStack.empty()) {
                node = nodeStack.pop();
                list.add(node.val); //根
                if (node.right != null) { //右
                    nodeStack.push(node.right);
                }
                if (node.left != null) { //左
                    nodeStack.push(node.left);
                }
            }
        }
        return list;
    }
```

#### 中序遍历（LNR）

> 递归遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inOrder(root, res);
        return res;
    }
    public void inOrder(TreeNode root, List<Integer> res) {
        if (root == null) return;
        inOrder(root.left, res);
        res.add(root.val);
        inOrder(root.right, res);
    }
}
```



> 非递归遍历

思路：①沿着根的左孩子，依次	入栈，直至左孩子为空。此时说明已经找到可以输出的结点 ；②栈顶元素出栈并访问，若其右孩子为空，继续执行②，若其右孩子不为空，将右子树转执行①。

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList();
        Stack<TreeNode> stack = new Stack<TreeNode> ();
        TreeNode p = root;
        while (p != null || !stack.empty()) {
            if (p != null) { //一路向左，不空就入栈
                stack.push(p);
                p = p.left;
            } else { //左孩子为空，可以访问当前结点，出栈
                p = stack.pop();
                list.add(p.val);
                p = p.right; //转向右孩子
            }
        }
        return list;
    }
```

将其中访问结点的操作`list.add(p.val)`，放在左孩子入栈前即为先序遍历

#### 后序遍历（LRN）

> 递归遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer>res = new ArrayList<>();
        postOrder(root,res);
        return res;
    }
    public void postOrder(TreeNode root, List<Integer>res) {
        if (root == null) return;
        postOrder(root.left,res);
        postOrder(root.right,res);
        res.add(root.val);
    }
}
```



> 非递归遍历

方法一：按照先序遍历的做法，先根节点入栈，再右孩子入栈，再左孩子入栈，最后得到的遍历序列是  `根 左 右`, 若颠倒其中左右孩子入栈顺序可到最终的遍历顺序为 `根 右 左` ，再将其逆序（不直接输出，而是存入另一个栈中）可得到后序遍历序列 `左 右 根`

```java
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode node; 
        if (root != null) {
            stack.push(root);
            while (!stack.empty()) {
                node = stack.pop();
                list.add(node.val);
                //入栈时顺序为：根左右，出栈收集时得到顺序为：根右左，最后逆序即可得到后序遍历序列
                if (node.left != null) {
                    stack.push(node.left);
                }
                if (node.right != null) {
                    stack.push(node.right);
                }
            }
        }
    	Collections.reverse(list);//逆序
        return list;
}
```

方法二：用一个栈实现。使用c指向栈顶结点，h跟踪刚出栈访问的结点。

对于后序序列 ：左 右 根，

- 当栈顶元素的左孩子不为空且刚出栈访问的结点h不是栈顶结点c的左孩子 ，h也不是右孩子时（当h是右孩子时，说明右子树已经处理完了，左子树也一定处理完了），说明c的左子树还未后序遍历完，将左孩子入栈；
- 当栈顶元素的右孩子不为空且刚出栈的不是右孩子时，说明右子树未处理完，将右孩子入栈；
- 最后当左右孩子都处理完，或左右孩子均为空时，栈顶元素出栈访问

```java
public List<Integer> postorderTraversal(TreeNode root) {
        
        List<Integer> list = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<TreeNode>();

        if (root == null) return list;

        TreeNode h = root; //跟踪最近出栈的结点
        TreeNode c = null; //c指向栈顶结点

        stack.push(h);
        while (!stack.empty()) {
            c = stack.peek(); 
            if (c.left != null && h != c.left && h != c.right) //最近出栈访问的既不是c左孩子也不是c的右孩子，则c的左子树还没处理完
                stack.push(c.left);
            else if (c.right != null && h != c.right) //最近出栈访问的不是c的右孩子，则c的右子树还未处理完
                stack.push(c.right); 
            else {	//左右子树均处理完，或左右子树都为空时，处理当前结点
                h = stack.pop();
                list.add(h.val);
            }
        }
        return list;
     }
```


#### 层序遍历

1. 初始化一个辅助队列，根节点入队
2. 若队列非空，队头结点出队并访问该结点，将其左右孩子分别插到队尾（如果有的话）
3. 重复2直至队列为空

```c++
void LeverOrder(BiTree T) {
    InitQueue(Q);
    BiTree p;
    EnQueue(Q, T);
    while (!IsEmpty(Q)) {
        DeQueue(Q, p);
        visit(p);
        if (p->lchild != NULL) {
            EnQueue(p->lchild);
        }
        if (p->rchild != NULL) {
            EnQueue(p->rchild);
        }
    }
}
```



#### 由遍历序列构造二叉树

方法：先从前序、后序、层序序列中寻找根节点，再根据中序序列划分左右子树，再找左右子树的根节点，进一步划分。

- 前序 + 中序：  前序：  <u>根节点</u> 、左子树前序遍历序列、右子树前序遍历序列
- 后序 + 中序：  后序：左子树后序遍历序列、右子树后序遍历序列、<u>根节点</u>
- 层序 + 中序：  层序： <u>根节点</u>、 左子树的根、右子树的根



> 注意点

- 要唯一确定一棵二叉树，必须给出**中序遍历序列**，以及另一种遍历序列。

- 先序和后序不能唯一确定一棵二叉树，但可以确定二叉树中结点的**祖先关系**，如先序序列为 e bdc 和后序序列 bcd e,则e是bcd的祖先，b 和 d是兄弟，d是c的祖先；
- 前中后序遍历次序是访问根结点的顺序不同，而<u>访问左右子树的次序是固定的</u>，所以**左子树中结点在右子树结点之前，所有叶子结点的次序相同**
- 前序为NLR，后序为LRN，**若前序序列和后序序列刚好相反**，则不可能有一个结点同时有左右孩子，即所有非叶结点都只有一个孩子，则其树高为结点个数（要么为NL和LN，要么为NR和RN），只有一个叶结点；**若前序序列和后序序列相同**，即NLR = LRN，则L和R都为空，该二叉树只有一个根结点。
- 一棵二叉树的**前序序列和中序序列相同**，即NLR = LNR，则所有非叶结点都只能只有右孩子。

- 先序的最后一个结点，中序的最后一个结点、后序的第一个结点
  - 二叉树先序遍历的最后一个结点，先从根结点开始沿右孩子走到底，若该结点没有左孩子则该结点为最后一个遍历的结点，若有左孩子，则最后一个结点在其左子树中，同样的方法寻找。
  - 二叉树中序遍历的最后一个结点，一定是从根开始沿右孩子走到底的结点
  - 二叉树后序遍历的第一个结点，先从根节点开始沿左孩子走到底，若其没有右孩子，则为第一个结点；若有右孩子，则第一个结点在其右子树中，同样的方法寻找。

- 根据二叉树前序遍历和中序遍历的递归算法种递归工作栈的状态变化得出：**前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序**。 所以根据给定的先序序列 abcd，可以确定的中序序列有 $\frac{1}{n+1} C_{2n}^{n}$种，即$\frac{1}{5}C_{8}^{4} = 14$种，又由于根据先序序列和中序序列可以确定一棵二叉树，所以先序序列为abcd的二叉树有 14种。

### 2.6、线索二叉树

#### 	定义

​	传统的二叉链表存储仅能体现父子关系（从上到下），**不能直接得到结点在遍历序列中的前驱或后继**，只能从根结点开始进行一次遍历才能确定。将二叉链表中空闲的$\color{red}n+1$个空闲指针域利用起来，将其指向遍历序列中的前驱或后继，方便从一个指定结点出发，找到其前驱、后继，就可以像遍历单链表那样方便地遍历二叉树。

​	**线索，即指向遍历序列中前序或后继的指针。**规定，若无左子树，lchild指向其前驱结点；若无右子树，rchild指向其后继节点。

**二叉树是逻辑结构，线索二叉树是存储结构**

#### 存储结构

```c++
typedef struct ThreadNode {
    Elemtype data;
    struct ThreadNode *lchild, *rchild;
    int ltag,rtag; //左右线索标志，ltag为1时指针为线索，tag为0时，指针指向孩子。初始化时 tag都为0
}ThreadNode, *ThreadTree;
```

手算画出线索二叉树：确定线索二叉树的类型，按照对应的遍历规则确定各结点的访问顺序，并写上编号，再将n+1 个空链域连上前驱和后继。



#### 二叉树的线索化

核心：**对中序、先序、后序遍历算法的改造，当访问一个结点时，建立<u>该结点</u>和<u>其前驱</u>的线索信息。**

易错点：

- 对最后一个结点rchild、rtag的处理

- 先序线索化中转圈的问题，当ltag = 0时才能对左子树进行先序线索化



**中序线索化**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225174818508-2024-12-800:12:51.png" alt="image-20230225174818508" style="zoom:50%;" />

```c++
ThreadNode *pre = NULL;//全局变量 pre，指向当前结点的前驱结点
void CreatInThread(ThreadTree T) {
    pre = NULL;
    if (T != NULL) {
        InThread(T); //中序线索化
        if (pre->rchild == NULL)  //处理遍历的最后一个结点
            pre->rtag = 1;	
    }
}
//中序遍历二叉树，一边遍历一边线索化
void InTread(ThreadTree T) {
    if (T != NULL) {
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

void visit(ThreadNode *q) {
    if (q->lchild == NULL) { //当前结点左子树为空，建立当前结点的前驱线索
        q->lchild = pre;
        q->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) { //建立前驱结点的后继线索
        pre->rchild = q;
        pre->rtag = 1;
    }
    pre = q; //当前结点及其前驱已经处理完，开始准备下一个结点
}
```

**先序线索化**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225175853143-2024-12-723:51:31.png" alt="image-20230225175853143" style="zoom:50%;" />

当q指针指向D，D没有左孩子，建立前驱线索 lchild 指向B，pre指向D；根据先序顺序，接下来该处理其左孩子，但在上步其左孩子已经指向了B，导致q再次指向B，出现了死循环。所以根据tag标志判断访问的是左子树还是前驱

```c++
ThreadNode *pre = NULL;//全局变量 pre，指向当前结点的前驱结点
void CreatPreThread(ThreadTree T) {
	...同上
}
//先序遍历二叉树，一边遍历一边线索化
void preTread(ThreadTree T) {
    if (T != NULL) {
        visit(T);
        if (T->ltag == 0)  //lchid 不是前驱线索
        	InThread(T->lchild);
        InThread(T->rchild);
    }
}

void visit(ThreadNode *q) {
	...同上
}
```

**后序线索化**

​	同中序线索化，将中序遍历改为后序遍历即可。



#### 在线索二叉树中找前后驱

若ltag或rtag为1，则lchild或rchild所指的就是其前驱或后继。

**中序线索二叉树 （LNR）**

- 找p的前驱，若ltag = 0，则必有左孩子，前驱为左孩子中最后一个被访问的结点，即**左子树最右下的结点**

- 找p的后继，若 rtag = 0，则必有右孩子，后继为右子树中第一个被访问的结点，即**右子树中最左下的结点**

**先序线索二叉树 (NLR)**

- 找p的后继，若rtag = 0，则必有右孩子，若也有左孩子，则后继为左孩子；若无左孩子，则后继为右孩子。（有左为左。无右为右）

- 找p的前驱，若ltag = 0 且只有lchild和rchild两个指针域时无法找到其前驱。

  要找到其前驱，需**使用三叉链表，在每个结点中记录父节点信息**

  - 若能找到p的父节点，p是左孩子，则p的父节点就是p的前驱
  - 若能找到p的父节点，p是右孩子且左孩子为空，则p的父节点就是p的前驱
  - 若能找到p的父节点，p是右孩子且左孩子不为空，则<u>其左兄弟最后一个被遍历的结点即是p的前驱</u>。（先沿左兄弟的右孩子指针一直向下到最后一个，若此结点有左孩子，则再沿左孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）
  - 如果p是根结点，则p无前驱。

**后序线索二叉树（LRN）**

- 找p的前驱，若ltag = 0，则必有左孩子，若也有右孩子，则右孩子为其前驱；若没有右孩子，则左孩子为其前驱。（有右为右，无右为左）

- 找p的后继，若rtag = 0,且只有lchild和rchild两个指针域时无法找到其后继。 （**同先序找前驱**）

  要找到其后继，需**使用三叉链表，在每个结点中记录父节点信息**

  - 若能找到p的父节点，p是右孩子，则p的父节点就是p的后继
  - 若能找到p的父节点，p是左孩子且右孩子为空，则p的父节点就是p的后继
  - 若能找到p的父节点，p是左孩子且右孩子不为空，则<u>其右兄弟第一个被遍历的结点即是p的后继</u>。（先沿右兄弟的左孩子指针一直向下到最后一个，若此结点有右孩子，则再沿右孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）
  - 如果p是根结点，则p无后继。

|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| ------ | -------------- | -------------- | -------------- |
| 找前驱 | ✔              | ✘              | ✔              |
| 找后继 | ✔              | ✔              | ✘              |

后序线索二叉树的遍历仍需要栈的支持，后序找后继不一定能直接找到。

## 三、树、森林

### 3.1、树的逻辑结构

**树**是n（n>0）个结点的有限集合，n=0时，称为空树。在任意一棵非空树中应满足：
1）有且仅有一个特定的称为**根**的结点。
2）当n>1时，其余结点可分为m（m>0）个**互不相交的有限集**合T1,T2...Tm，其中每个集合本身又是一棵树，并且称为根结点的**子树**。

- 树是一种递归定义的数据结构

### 3.2、树的存储结构

**双亲表示法（顺序存储）**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225200402386-2024-12-723:58:02.png" alt="image-20230225200402386" style="zoom: 67%;" />

```c++
#define MAX_TREE_SIZE 100
typedef struct {  //树结点的定义
    int data;
    int parent;
}PTNode;
typedef struct { //树的类型定义
    PTNode nodes[MAX_TREE_SIZE]; 
    int n; //结点数
}
```

每个结点中保存指向双亲的“指针”，其实就是使用**静态数组**存储。根节点固定存储在0，-1表示没有双亲。

- 增加元素，将新元素放到数组末尾并保存双亲结点的位置。新增元素时无需按逻辑上的次序存储。
- 删除元素，若删除的是叶节点，可以使用数组最后一个元素覆盖当前结点的内容，并将总结点数减一，保证已存储的均有效，也方便遍历；若删除的是分支结点，则要找到其所有的子孙结点，也将它们全部删除。
- 查询孩子结点，需要从头遍历，判断每个位置的双亲结点和要查询的是否一致，依次找到所有的孩子节点。

优点：查指定结点的双亲很方便；缺点：查指定结点的孩子结点只能从头遍历。



**孩子表示法（顺序+链式）**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225201513725-2024-12-723:58:12.png" alt="image-20230225201513725" style="zoom: 50%;" />

```c++
#define MAX_TREE_SIZE 100
struct CTNode{ //孩子链表结点的定义
    int child; //孩子节点在数组中的位置
    struct CTNode *next; //指向下一个孩子
}
typedef struct { //结点数组元素的定义
    ElemType data;
    struct CTNode *firstChild;
}CTBox;
typedef struct {
    CTBox nodes[MAX_TREE_SIZE];
    int n,r; //结点数和根的位置
}CTree;
```

顺序存储各个结点，每个结点中保存孩子链表的头指针。

该存储结构找孩子方便，找双亲时需要遍历n个结点对应的孩子链表，在里面找是否有指定结点。



**孩子兄弟表示法 （链式存储）**

左孩子右兄弟

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_20-30-40-2024-12-723:58:19.png" alt="Snipaste_2023-02-25_20-30-40" style="zoom: 67%;" />

```c++
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild, *nextsibling; //第一个孩子 和 右兄弟指针
}CSNode, *CSTree;
```

该种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲比较麻烦（可以增设一个parent域指向父节点）。

### 3.3、树、森林和二叉树的转换

森林转换为二叉树：先将每棵树转换为二叉树，因为各个树之间是平级的，所以各个树的根节点可以相互看做兄弟结点，用右指针将各个根节点串联起来即可。

> 森林转换为对应的二叉树，森林中叶子结点的个数对应二叉树中左指针为空的结点个数
>
> 高度为h的满二叉树，对应的森林所含树的个数为 h
>
> 一棵树转换为二叉树，树中每个非叶结点的最后一个孩子没有右孩子,且根结点没有右兄弟，故树中非叶节点个数  + 1 = 二叉树中右指针为空的结点个数
>
> 一个森林转换为二叉树，各个树的根节点可以相互看做兄弟，最后一棵树没有右兄弟，故森林中非叶结点个数  + 1= 二叉树中右指针为空的节点数
>
> 一棵树或森林转化为二叉树，其中叶结点的个数对应二叉树中左指针为空的结点数。
>
> 若树中任意两个叶结点都不存在相同的双亲，则树中的叶子数和其对应的二叉树中的叶子数相等
>
> 一个森林有 $n$个结点，$m$条边，则这个森林有$ n - m$ 棵树。（ 在树中，除了根节点外，每个顶点对应一条边）

### 3.4、树和森林的遍历

| 树       | 森林     | 二叉树   |
| -------- | -------- | -------- |
| 先序遍历 | 先序遍历 | 先序遍历 |
| 后序遍历 | 中序遍历 | 中序遍历 |

## 四、树和二叉树的应用

### 4.1、哈夫曼树和哈夫曼编码

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225211114726-2024-12-723:58:35.png" alt="image-20230225211114726" style="zoom:50%;" />

结点的权：有某种现实含义的数值（如：表示结点的重要性，出现次数等）

结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积

树的带权路径长度：**所有叶结点**的带权路径长度之和  $WPL =  \sum_{i=1}^{n} w_i l_i$

**在含有$n$个带权叶结点的二叉树中，其中带权路径长度（$WPL$）最小的二叉树称为哈夫曼树，也称最优二叉树**



特点：

- 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度就越大。
- 构造过程中一共新建了 $n-1$个结点，因此哈夫曼树的结点总数为 $2n -1$。
- 哈夫曼树中，只有度为2和度为$0$的结点，不存在度为 1 的结点。
- 哈夫曼树不唯一，但 $WPL$必然相同且为最优。

> 度为m的哈夫曼树，其中只有度为 m和度为 $0$的结点。有 n个叶结点时，由于总结点数 = $n_0+n_m=m*n_m+1$，故有 $\lceil \frac{n-1}{m-1}\rceil$个非叶结点。
>

若没有一个编码是另一个编码的前缀，则称这样的编码为**前缀编码**。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225212551153-2024-12-723:58:42.png" alt="image-20230225212551153" style="zoom:50%;" />

由哈夫曼树得到哈夫曼编码。首先将每个出现的字符当做一个独立的结点，其权值为它出现的频度或次数，构造出对应的哈夫曼树。所有的字符都出现在叶结点中。可将字符的编码解释为从根到该字符的路径上边标记的序列，其中边标记为0表示 “转向左孩子”，边标记为1 表示“转向右孩子”。

哈夫曼树不唯一，因此哈夫曼编码不唯一。

> 出现频度高的字符，其哈夫曼编码短；频度低的字符，编码长度更长。

### 4.2、并查集

逻辑结构：元素之间为 “集合”关系。

**基本操作**：

- 初始化 Initial(S)：初始化并查集，将所有数组元素初始化为-1
- Union （S, root1, root2）: **“并”**，把集合S中的子集 root2 并入子集 root1中，**要求 root1 和root2不相交**
- Find (S, x)：**“查”**，查找集合S中单元素x所在的子集合，并返回该子集合的名字。

**存储结构**：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225215722535-2024-12-800:03:19.png" alt="image-20230225215722535" style="zoom: 67%;" />

​	将每个集合组织成一棵树，通常用树（森林）的**双亲表示法**做为并查集的存储结构。通常用数组元素下标代表元素名，用根结点的小标代表子集合名，根结点的双亲结点为负数。

> 并查集（Disjoint Set）是对逻辑结构 --- 集合 的具体实现，只进行 “并” 和 "查"两种基本操作
>
> 并 ：将两个不相交的集合合并为一个， 查：确定一个指定元素所属的集合

其中查操作，通过不断向上寻找，找到所在树的根节点，根节点的数组下标代表该元素所属的集合。

并操作，只需将一个集合的根节点的双亲指针指向另一个集合的根节点即可。



```c++
#define SIZE 13
int UFSets[SIZE];  //集合元素数组

void Initial (int s[]) {
    for (int i = 0; i < SIZE; i++) 
        s[i] = -1;
}

int Find (int s[],int x) {
    while (s[x] >0) 
        x = s[x];  
    return x;
}

void Union (int s[], int root1, int root2) {
    if (root1 == root2) return;  //要求两个集合不同
    s[root2] = root1; //将根root1 连接在另一根 root2下
}

```

其中Find操作的最坏时间复杂度为$O(n)$，最坏时间复杂度和树的高度有关。Union操作的时间复杂度为 $O(1)$.



**并查集的优化**

​		为了降低Find的时间复杂度，需要在每次Union操作构建树的时候，尽可能让树不长高。用根结点的**绝对值**表示树的结点总数，每次Union操作时都让小树合并到大树。

​	压缩路径—-Find操作，先找到根节点，再将查找路径上所有结点都挂到根结点下。可使树的高度不超过$O(α(n))$。$α(n)$是一个增长很缓慢的函数，对于常见的n值，通常$α(n) ≤ 4$，因此优化后并查集的Find、Union操作时间开销都很低

​	![Snipaste_2023-02-25_22-28-33](https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_22-28-33-2024-12-800:03:31.png)

```c++
#define SIZE 13
int UFSets[SIZE];  //集合元素数组

void Initial (int s[]) {
    for (int i = 0; i < SIZE; i++) 
        s[i] = -1;
}

int Find (int s[],int x) {
	int root = x;
    while (s[root] > 0) root = s[root];  //循环找到根
    //压缩路径
    while (x != root) {
        int t = s[x];
        s[x] = root;
        x = t;
    }
    return root;
}

void Union (int s[], int root1, int root2) {
    if (root1 == root2) return;  //要求两个集合不同
    if (s[root2] > s[root1]) { //root2结点更少，将root2合并到root1
        s[root2] = root1;
        s[root1] += s[root2];
    } else {
        s[root1] = root2;
        s[root2] += s[root1];
    }
        
}

```