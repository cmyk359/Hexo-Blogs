---
title: 六、图
tags:
  - 图
  - 广度优先遍历
  - 深度优先遍历
  - 最小生成树
  - 最短路径
  - 拓扑排序
  - 关键路径
math: true
categories:
  - 数据结构
abbrlink: ce993eeb
date: 2024-12-08 09:54:45
---

<meta name = "referrer", content = "no-referrer"/>
数据结构目录：

[一、绪论](https://catpaws.top/bfab103e/)

[二、线性表](https://catpaws.top/7682ef9a/)

[三、栈和队列](https://catpaws.top/d403458d/)

[四、串](https://catpaws.top/dac6dce7/)

[五、树和二叉树](https://catpaws.top/453281de/)

[六、图](https://catpaws.top/ce993eeb/)

[七、查找](https://catpaws.top/24d4ba7c/)

[八、排序](https://catpaws.top/978a1655/)

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316183420877-2024-12-810:00:23.png" alt="image-20230316183420877" style="zoom:80%;" />

## 一、图的定义

​	图G由顶点集V和边集E组成，记为G = (V,E)，其中V(G)表示图G中顶点的有限**非空**集,E(G)表示图G中顶点之间关系（边）的集合。用 |V|表示图G中顶点的个数，也称图的阶；|E|表示图G中边的条数。 **图不能为空图，边集E可以为空，但顶点集V不能为空。**

无向图（无向边/边），有向图（有向边/**弧**）

顶点的度

**点到点的关系**：

- **路径**（两点之间的顶点序列）、**回路**（第一个顶点和最后一个顶点相同的路径）、**简单路径**（顶点不重复出现的路径）、**简单回路**（除第一个和最后一个顶点相同外，其余顶点不重复出现的回路）
- **路径长度**（路径上边的数目）
- 点到点的距离（两点之间的最短距离）
- 无向图顶点的**连通性**（两顶点间有路径存在）、**连通图**（任意两个顶点间都是连通的）
- 有向图顶点的**强连通性**（从顶点$w$到$v$和从$v$到$w$都有<u>**路径**</u>）、**强连通图**（任一对顶点都是强连通的）

**图的局部**

- 子图（首先是图）、生成子图（包含原图的所有结点，可以不包含所有边）
- 连通分量---极大连通子图：无向图中，子图必须连通，且包含尽可能多的顶点和边。
  - 连通图本身就是自己的连通分量，而非连通图的各个子部分均为其连通分量
- 强连通分量---极大强连通子图：有向图中，子图是强连通的，且包含尽可能多的顶点和边。
- 连通无向图的生成树：包含全部顶点的极小连通子图（子图既要连通，又要边数最少），**不唯一**
- 非连通图的生成森林：各个连通分量的生成树

**几种特殊形态的图**

- 完全图
  - 无向完全图：对于无向图，任意两个顶点之间都存在边。有$C_n^2$条边。
  - 有向完全图：对于有向图，任意两个顶点之间都存在方向相反的两条<u>**弧**</u>（对比强连通图）。有$2C_n^2$条边。
- 稠密图、稀疏图
- 树、森林、有向树

**常见考点**

对有$n$个顶点的无向图G

- 所有顶点的度之和为 $2|E|$（每条边贡献两个度）
- 若G是连通图，则最少有 $n-1$条边（若$|E|> n-1$，则必有回路）最多有$C_n^2$条边,为无向图完全图
- 若G是非连通图，则最少有 0条边，最多有 $C_{n-1}^2$条边（取其中$n-1$个顶点，两两相连构成完全图，共 $C_{n-1}^2$条边，若剩下的一个顶点与完全图中任意一个相连就整体连通了，故最多为 $C_{n-1}^2$条边）
- 无向完全图共 $C_n^2$条边
- 无向完全图一定是连通图，但连通图不一定是完全图
- 要保证$n$个顶点的无向图，**在任何条件下都是连通的，即确保其是连通的，而不是其可以是连通的**，即$n$个顶点的非连通图的最大边数加一。需要先由其中$n-1$个顶点构成完全图，再用剩下的一个顶点和完全图中某个顶点相连，则必然是连通的，故需要$C_{n-1}^2+1$条边。

对有$n$个顶点的有向图G

- 所有顶点的度之和为 $2|E|$
- 所有顶点的入度之和 = 出度之和  = $|E|$
- 若G是强连通图，则最少有$n$条边（构成一个简单回路）。**最简单的强连通图就是一个环。**
- 有向完全图共 有$2C_n^2$条边。
- 有向完全图一定是强连通图，但强连通图不一定是有向完全图
  - 强连通有向图的任何顶点到其他顶点都有路径
  - 有向完全图的任何顶点到其他顶点都有弧
- 要<u>**保证**</u>n个顶点的有向图是连通的，至少需要$2(C_{n-1}^2 + 1) $条边。

具有$n$个顶点的环，有$n$棵生成树。（每去掉一条边就形成一棵生成树）

$n$个顶点的图，最少有一个连通分量，最多有$n$个。

若无向图满足 $n$个顶点 $n-1$条边的无向连通图，则它是树

有回路的图一定不存在拓扑序列。拓扑序列相当于工程的安排顺序，而回路的存在相当于死锁。

求有向图中强连通分量的个数：

- 在有向图中，当一个顶点只有入度没有出度，或者只有出度没有入度时，它无法和其他顶点构成强图连通分量，它自身就是一个强连通分量。从图中删除该顶点和其相连的边后继续判断。

> i. 顶点数-边数=1时，刚好<u>**可以做**</u>到连通且无环（并不是一定连通且无环，也可能是不连通但有环），相对于此临界点，若顶点数偏多则必不连通；相对于此临界点，若边数偏多则必有环。
>
> ii. n个顶点的无向图，当边数至少为$C_{n-1}^2 + 1$时，才能**保证**该图是连通的。
>
> iii. n个顶点的无向图，至少需要$2(C_{n-1}^2 + 1) $条边，才能**保证**该图是连通的。其需要的边数是有	向图的2倍，因为需要添加一条指向n-1个结点构成的有向完全图的弧，也要再添加一条从有向	完全图指向该结点的弧。



## 二、图的存储结构

### 2.1、邻接矩阵法

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303171403732-2024-12-810:10:59.png" alt="image-20230303171403732" style="zoom:67%;" />	用一个一维数组存储图中的顶点信息，用一个二维数组存储图中边的信息。该二维数组称为邻接矩阵。

当两个顶点间有边相连时，矩阵中对应的值为1，否则为0；当为带权图时，矩阵中对应值保存权值信息。

在无向图的邻接矩阵中，第$i$个顶点的度 = 第 $i$行（或第$i$列）的非零元素个数。边的信息会被保存两次，所以是一个对称矩阵。在有向图的邻接矩阵中，第$i$个顶点的**出度** = 第$i$**行**非零元素的个数，第$i$个元素的**入度** = 第$i$**列**非零元素的个数。求一个顶点的度的时间复杂度为$O(|V|)$。

邻接矩阵法的空间复杂度 为$ O(|V| + |V|^2) = O(|V|^2) $，**只与图中顶点数有关，和实际边数无关，**故其适合存储稠密图。

一个图的邻接矩阵表示是唯一的。

> i. 设图G的邻接矩阵为 A（矩阵元素为$1/0$）,则 $A^n$的元素 $A^n[i][j]$等于由顶点 $i$ 到顶点 $j$ 长度为	n的路径数目。
>
> <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303172900327-2024-12-810:11:11.png" alt="image-20230303172900327" style="zoom: 50%;" />
>
> ​	如 $A^2[1][4] = a_{11}a_{14} + a_{12} a_{24}+a_{13}a_{34}+a_{14}a_{44}$  ,其中$a_{12} = 1$表示存在边(A,B)，$a_{24} =1$	表示存在边(B,D),则 $a_{12}a_{24} = 1$表示存在一条A到B，再从B到D的路径；而$a_{13}a_{34}=0$表示不	存在从A到C，再从C到D的路径。 
>
> ii. 对无权图，表示两点间没有直接相连，邻接矩阵对应位置用 0 表示
>
> ​	对带权图，表示两点间没有直接相连，邻接矩阵对应位置用 $\infty$表示



### 2.2、邻接表法

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303173953520-2024-12-810:11:16.png" alt="image-20230303173953520" style="zoom: 67%;" />

对图G中的每个顶点$v_i$建立一个单链表，第$i$个单链表中的结点表示依附于顶点$v_i$的边（对有向图则表示以$v_i$为尾的弧），这个单链表就称为顶点$v_i$的边表。边表的头指针和顶点的数据信息采用顺序存储。

特点：

- 对有向图而言，每个结点邻接表中所含结点数即为该节点的出度。

- 若G为无向图，则所需的存储空间为 $O(|V|+2|E|)$；若是有向图，则所需存储空间为$O(|V|+|E|)$
- 稀疏表适合用邻接表表示
- 在有向图的邻接表中，求一个顶点的出度只需计算其边表中结点的个数，但要求其入度时需要遍历整个邻接表。
- 图的邻接表表示并不唯一。由于每个顶点的边表中结点的次序是任意的

### 2.3、十字链表法（表示有向图）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303175648773-2024-12-810:11:22.png" alt="image-20230303175648773" style="zoom:67%;" />

其空间复杂度为$O(|V|+|E|)$

找一个顶点的出边，沿着tlink向下找；找一个顶点的入边，沿着rlink向下找。

顶点之间是顺序存储的。图的十字链表表示是不唯一的，但一个十字链表表示确定的一个图。



### 2.4、邻接多重表法（存储无向图）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303175800794-2024-12-810:11:26.png" alt="image-20230303175800794" style="zoom:67%;" />

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。

对无向图而已，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。

空间复杂度为 $O(|V|+|E|)$，每条边之对应一份数据，删除边和结点的操作都很方便。

![image-20230615205554582](https://gitee.com/cmyk359/img/raw/master/img/image-20230615205554582-2024-12-810:15:48.png)

- AOV网：用顶点表示活动，用有向边表示活动之间的顺序关系的图，称为用顶点表示活动的网络，记为AOV网。
- AOE网 ：用顶点表示事件，用有向边表示活动，以边上的权值表示完成该活动的开销，称为用边表示活动的网络，简称AOE网。

AOV网和AOE网都是有向无环图（DAG图），不同之处在于它们顶点和边所代表的含义不同，AOE网中的边有权值，而AOV网中的边无权值，仅表示

> 若有向图的邻接矩阵的对角线以下元素均为$0$，则该图的拓扑序列必定存在。（对角线以下元素均为 $0$,必不存在环，即拓扑序列一定存在，但并不能说明拓扑序列唯一）

## 三、图的基本操作

![image-20241208102024920](https://gitee.com/cmyk359/img/raw/master/img/image-20241208102024920-2024-12-810:20:28.png)

## 四、图的遍历

​	图的遍历是指从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。

​	图和树相比，树不存在回路，搜索相邻结点时，不可能找到已经访问过的结点；而图中的任一顶点都可能和其余顶点相邻接，搜索相邻顶点时，有可能找到已经访问过的顶点。为避免同一顶点被访问多次，在遍历图的过程中，设置一个辅助数组 visited[]，来标记顶点是否被访问过。

### 4.1、图的广度优先遍历

**广度优先搜素（BFS）类似于树的层序遍历**。广度优先搜索遍历图的过程是以 $v$为起点，由近至远依次访问和 $v$有路径相通且路径长度为$1,2,...$的顶点。搜索过程和二叉树的层序遍历完全一致，是一种分层的查找过程，不是一个递归算法，需要设置辅助队列。

空间复杂度：$O(|V|)$，主要是辅助队列的空间

时间复杂度：主要开销在于**访问各个顶点**和**探索各条边**。

- 对于邻接矩阵存储的图，$O(|V|+O(|V|^2)) = O(|V|^2)$
- 对于邻接表存储的图，$O(|V|)+O(|E|) = O(|V|+|E|)$

对于一个非连通图，需要多次调用BFS才能将图中所有顶点访问一次，调用次数 = 连通分量个数。

在对一个<u>连通图</u>的广度遍历的过程中，可以得到一棵遍历树，称为**广度优先生成树**；对于一个<u>非连通图</u>，可以得到**广度优先森林。**

> 当各边的权值**相等**时，广度优先算法可以用来解决单源最短路径问题。
>
> 从某一顶点开始进行广度优先遍历，得到的广度优先生成树<u>一定是以该顶点为根的，高度最小的生成树</u>

### 4.2、图的深度优先遍历

**深度优先搜素（DFS）类似于树的先序遍历。**其搜索策略时尽可能“深”地搜索一个图。

基本思想：首先访问图中某一起始顶点$v$，然后从$v$出发，访问与$v$邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2......$重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有顶点未被访问过，则从该顶点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。

```c++
bool visited[vertexNum]; //记录顶点是否被访问过
void  DFSTraverse(Graph G) {
    for (int i = 0; i < G.verxNum; i++)
        visited[i] = false;
    for (int i = 0; i < G.verxNum; i++) //非连通图要在执行多次DFS
        if (!visited[i])
            DFS(G, i);
}

void DFS(Graph G, int v) {
    visit(v);             //访问顶点v
    visited[v] = true;    //标记该顶点v已访问
    for (int w = G.firstNeighbor_martrix(v); w >= 0; w = G.nextNeighbor_martrix(v,w)) {
        if (!visited[w]) { //w与v邻接且没被访问过
            DFS(G, w);
        }       
    }
}
```



DFS算法是一个递归算法，需要借助一个递归工作栈。

空间复杂度：$O(|V|)$,主要是递归工作栈的空间。

时间复杂度：主要开销在于访问各个顶点和探索各条边。

- 对于邻接矩阵存储的图，$O(|V|+O(|V|^2)) = O(|V|^2)$
- 对于邻接表存储的图，$O(|V|)+O(|E|) = O(|V|+|E|)$

与广度优先搜索一样，深度优先搜索也会产生一棵**深度优先生成树**。对于非连通图，产生的是**深度优先森林**。

对于一个图，使用<u>邻接矩阵</u>存储时是唯一的，由此得到的广度/深度优先遍历序列是唯一的，故广度/深度优先生成树/森林也是唯一的；而当使用<u>邻接表</u>存储时是不唯一的，由此得到的遍历序列和生成树都是不唯一的。

> 判断有向图中是否有回路，除了用拓扑排序外，还可以利用深度优先遍历算法
>
> 图的广度优先生成树的树高和深度优先生成树的树高相比 **小或相等**

### 4.3、图的遍历与图的连通性

对一个**无向图**，进行广度/深度优先遍历，<u>调用BFS/DFS函数的次数 = 连通分量的个数</u>。对于一个连通图只需一次遍历，而若是非连通的，每次遍历只能访问到该顶点所在连通分量中的所有顶点。

对一个**有向图**，进行广度/深度优先遍历，调用BFS/DFS函数的次数要具体分析。

- 若从一顶点到其他顶点都有路径，则只需调用一次。
- 一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量。对于强连通图，只需一次；对于非强连通分量，一次调用BFS/DFS无法访问到该连通分量的所有顶点。



## 五、图的应用

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307214411951-2024-12-810:26:16.png" alt="image-20230307214411951" style="zoom:67%;" />

### 5.1、最小生成树

**连通图**的生成树是包含所有顶点的极小连通子图。

对一个**带权 连通 无向图**G，G的所有生成树中，<u>权值之和最小的生成树</u>称为G的最小生成树（MST）.

性质：

- **最小生成树不是唯一的**，但边的权值之和总是唯一且<u>是所有生成树中最小的。</u>
- <u>当图G中的各边权值互不相等时，G的最小生成树是唯一的</u>；若G本身就是一棵树，则G的最小生成树就是其本身。
- **最小生成树的边数 = 顶点数 - 1**。砍掉一条则不连通，增加一条边则会出现回路。

> 最小生成树中的n-1条边并不能保证是图中权值最小的n-1条边，因为权值最小的n-1条边并不一定能使图连通，某条边的权值可能超过未选边的权值。

#### prim算法

**从某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。**

prim算法的代码实现思路：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307205707722-2024-12-810:49:44.png" alt="image-20230307205707722" style="zoom:67%;" />

从$v_0$开始，首先初始化 isJoin[]和lowCast[]数组。

1. 循环遍历所有顶点，找到其中未加入生成树且lowCast值最小的顶点$v_i$，将其加入生成树。
2. 再次循环遍历，更新还没加入的各个顶点的lowCast值。
   - **由于树中加入了新的顶点$v_i$，其他未加入的顶点可能通过$v_i$加入树的代价比原来的要小**，此时要更新lowCast。即<u>若未加入的顶点和$v_i$之间有边，且边的权值比对应的lowCast值小，则更新lowCast值为权值</u>。
3. 重复 1,2直至所以顶点都加入树中。

从$v_0$开始进行了$n-1$轮处理，每轮处理中既要遍历isJoin找到未加入且lowCast最低的顶点，又要更新还未加入的各个顶点的lowCast值，每轮时间复杂度为 $O(2n)$，故总体时间复杂度为$O(n^2)$，即$O(|V|^2)$

时间复杂度：$\color{red} O(|V|^2)$，适合用于**边稠密图**

> 当构造生成树过程中，每条边的选取都是唯一的，每条边不存在其他可替代的选择，此时构造的MST是唯一的。
>
> 当带权图中所有边的权值互不相同时，其MST是唯一的。（一个充分条件）

#### Kruskal算法

**每次选择权值最小的边，使这条边的两头连通（原本已经连通的就不选），直到所有顶点都连通。**

Kruskal算法的代码实现思路：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307212551551-2024-12-810:49:36.png" alt="image-20230307212551551" style="zoom:67%;" />

初始时，将每条边按权值排序，每个顶点都还未加入到生成树中，互相看做独立的|V|个集合。

按权值递增的顺序遍历各个边。处理一条边时，判断这条边连接的两个顶点是否属于一个集合，如果不属于同一集合，则选择该边，使两个顶点连通。已连通的顶点属于同一集合。如果属于同一集合，则跳过该边。

使用并查集来判断两顶点是否属于同一集合。共执行|E|轮，每轮判断两顶点是否属于同一集合，需要$O(log_2{|E|})$，总时间复杂度为$O(|E|log_{2}{|E|})$。

时间复杂度：$\color{red} O(|E|log_{2}{|E|})$，适合用于边稀疏图

> 补充：破圈法求最小生成树
>
> 基本思想：在给定图中任意找出一个环路，删除该环路中权值最大的边，然后在余下的图中再找出任意一个回路，再删去这个新找出的回路中权值最大的边......，一直重复上述过程，知道剩余的图中没有回路，剩余图便是最小生成树。

### 5.2、最短路径

#### BFS求无权图的单源最短路径问题

无权图可以看做一种特殊的带权图，只是权值都为1。

广度优先搜索总是按照距离的从近到远来遍历图中每个顶点的。利用这一特性，修改BFS算法，在visit一个顶点时，修改其最短路径长度d[],并在path[]记录前驱顶点。

设置两个辅助数组

- d[]：记录从源点$v0$到其他各顶点当前的最短路径长度
- path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215844825-2024-12-810:49:26.png" alt="image-20230307215844825" style="zoom:50%;" />

初始状态：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215910638-2024-12-810:49:21.png" alt="image-20230307215910638" style="zoom: 50%;" /> <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215937053-2024-12-810:49:15.png" alt="image-20230307215937053" style="zoom: 67%;" />

```c++
//求顶点u到其他顶点的最短路径
void BFS_MIN_Distance(Graph G, int u) {
    //初始化
    for (int i = 0; i < G.vexnum; i++) {
        d[i] = INT_MAX; //初始化路径长度
        path[i] = -1; //最短路径从哪个顶点过来的
    }
    d[u] = 0; //到自身路径长度为0
    visited[u] = true;
    EnQueue(Q,u);
    while (! IsEmpty(Q)) {
        DeQueue(Q,u); //队头元素出队
        for (w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w)) {
            if (!visited[w]) { //w为u尚未访问过的邻接顶点
                d[w] = d[u] + 1; //路径长度加1
                path[w] = u; //最短路径从 u 到 w
                EnQueue(Q, w); //w入队
                visited[w] = true; //设置w已访问标记
            }//if
        }//for
    }//while
}
```

如从2号顶点开始，求解到其他顶点的最短路径长度和最短路径。与2相邻还没被访问过的顶点有1、6，修改d[1] = d[2]+1; path[1] = 2，将1入队；修改d[6] = d[2]+1; path[6] = 2，将6入队；1出队，与1相邻还没被访问过的顶点有 5，修改d[5] = d[1]+1; path[5] = 1，5入队；6出队，与6相邻还没被访问过的顶点有3,7......，得到最终的d[]和path[]

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307222559788-2024-12-810:49:08.png" alt="image-20230307222559788" style="zoom:67%;" />

从2号到8号的最短路径长度为d[8] = 3，最短路径为 8←7←6←2



#### Dijkstra算法求单源最短路径问题

Dijkstra算法设置一个集合S记录已求得最短路径的顶点，初始时把源点$v_0$放入S，集合S每并入一个新顶点$v_i$，都要修改源点$v_0$到集合 V-S中顶点当前最短路径长度值。**当加入一个顶点$v_i$时，源点到未加入集合的顶点的距离可能通过$v_i$作为中转点时，距离可能会更短，故每次加入时都要更新。**

设置三个辅助数组

- final[]（或s[]）：标记各顶点是否已经找到最短路径，初始时均为false
- dist[] (或d[])：源点到各顶点当前的最短路径长度，初始时均为无穷
- path[]：最短路径上的前驱，初始时均为-1

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307224800913-2024-12-810:49:00.png" alt="image-20230307224800913" style="zoom:67%;" />

初始时，若从$v_0$开始，令final[$0$] = true; dist[$0$] = $0$; 其余顶点$v_k$，dist[k] = arcs[$0$] [k]，path[k]= (arcs[$0$] [k] == ∞) ? -1 :$0$.

进行n-1轮处理：循环遍历所有顶点，找到还未确定最短路径，且dist值最小的顶点$v_i$，令final[i] = true,将其加入最短路径中。并检查所有邻接自$v_i$的顶点，若其final值为false，则更新其dist和path信息。若通过$v_i$到达这些顶点比原来找到的路径更短，即dist[i] + arcs[i] [j] < dist[j]，则更新dist[j]的值，并修改path[j] = i;（ arcs[i] [j] 表示$v_i$到$v_j$的弧的权值）

时间复杂度：$O(|V|^2)$

对比prim算法：prim算法中的lowCast数组和 Dijkstra算法中的dist数组作用和类似。**lowCast数组记录的是一个 顶点加入到生成树中的最小代价；dist数组记录的是从当前顶点到达指定顶点的最短路径的值**。与Prim算法一样，Dijkstra算法也是基于贪心策略的

> Dijkstra算法不适用于带负权值的带权图



例题：利用Dijkstra算法求解从a到其他顶点的最短路径和最短路径长度

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230310174311557-2024-12-810:48:52.png" alt="image-20230310174311557" style="zoom:50%;" />

|        | i = 1                   | i = 2                               | i = 3                                               | i = 4                                             | i = 5                                                        |
| ------ | ----------------------- | ----------------------------------- | --------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| b      | 2   $$a \rightarrow b$$ |                                     |                                                     |                                                   |                                                              |
| c      | 5   $$a\rightarrow c$$  | 3  $$a\rightarrow b \rightarrow c$$ |                                                     |                                                   |                                                              |
| d      | ∞                       | 5 $$a \rightarrow b \rightarrow d$$ | 5 $$a \rightarrow b \rightarrow d$$                 | 5 $$a \rightarrow b \rightarrow d$$               |                                                              |
| e      | ∞                       | ∞                                   | 7   $$a \rightarrow b \rightarrow c \rightarrow e$$ | 7 $$a \rightarrow b \rightarrow c \rightarrow e$$ | 6 $$a \rightarrow b \rightarrow c \rightarrow d \rightarrow e$$ |
| f      | ∞                       | ∞                                   | 4 $$a \rightarrow b \rightarrow c \rightarrow f$$   |                                                   |                                                              |
| $v_j$  | b                       | c                                   | f                                                   | d                                                 | e                                                            |
| 集合 S | {a,b}                   | {a,b,c}                             | {a,b,c,f}                                           | {a,b,c,f,d}                                       | {a,b,c,f,d,e}                                                |
| d[]    | d[1] =2                 | d[2] = 3                            | d[3] = 4                                            | d[4] = 5                                          | d[5] = 6                                                     |

分析：以第一轮为例，选出路径最小值 2，并将顶点b并入集合S，即已经找到从a到b的最短路径。当b加入S后，从a到 V-S中可达顶点的最短路径长度可能会发生变化，因此更新其他未加入S的顶点的路径长度。第五轮结束后，所有顶点都已经包含在S中。S中的顶点序列是找到最短路径目标顶点的序列，即先找a到b的最短路径，再是a到c的最短路径.......

> 每次判断初始点通过新加入的顶点到达其他尚未确定最短路径的点的距离会不会更短。
>

#### Floyd算法求各顶点之间最短路径问题

Floyd算法使用了动态规划的思想。

对n个顶点的图，当想求任意一对顶点 $v_i  $ →$v_j$之间的最短距离，将问题分为如下几个阶段：

- 初始时，从 $v_i  $ 到$v_j$不允许在其他顶点处中转，此时最短路径是多少
- 若允许在$v_0$处中转，最短路径是否会进一步优化，此时最短路径是多少
- 若允许在$v_0$，$v_1$处中转，最短路径是否会进一步优化，此时最短路径是多少
- ......
- 若允许在$v_0$,$v_1$,.....$v_{n-1}$处中转，最短路径是否会进一步优化，此时最短路径是多少

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307233700044-2024-12-810:48:40.png" alt="image-20230307233700044" style="zoom:50%;" />

在有向图G中，$A^{(-1)}$记录原始图的信息，$path^{(-1)}$初始值均为-1。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307233745551-2024-12-810:48:45.png" alt="image-20230307233745551" style="zoom: 67%;" />

依次加入 $v_0$,$v_1$,...$v_{n-1}$作为中转点，若路径更短，则更新A和path。

即若 $A^{(k-1)}[i][j] < A^{(k-1)}[i][k] + A^{(k-1)}[k][j]$,

则 $A^{(k)}[i][j] =A^{(k-1)}[i][k] + A^{(k-1)}[k][j]$，$path^{(k)}[i][j] = k$

否则 $A^{(k)}$和$path^{(k)}$保持不变

```c++
for (int k = 0; k < n; k++) { // 允许以vk作为中转点
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) { //遍历各个顶点
            if(A[i][j] < A[i][k] + A [k][j]) {//若以vk为中转点的路径更短
                A[i][j] = A[i][k] + A [k][j];//更新最短路径长度
                path[i][j] = k;//记录中转点k
            }
    }
}
```

时间复杂度 ：$O(|V|^3)$

> Floyd算法允许图中带有负权值的边，但不允许有包含带负权值边组成的回路



### 5.3、有向无环图描述表达式

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308145226726-2024-12-810:51:36.png" alt="image-20230308145226726" style="zoom:50%;" />

利用DAG图可以解决部分表达式在二叉树中重复出现的情况，实现对子式的共享，从而节省存储空间。

处理步骤如下：

1. 将各个操作数**不重复地**排成一排。（让最终顶点中不可能出现重复的操作数）
2. 标出各个运算符生效的顺序。（顺序不同，最后的DAG图的形状可能不同，但其中结点数相同）
3. 按顺序加入运算符，**注意分层**。当某个运算符要用到其他运算符的结果时，其位于更上一层。
4. 从底向上检查**同层**运算符是否可以合体。若同一层中，两个运算符相同，左右操作数也相同，就可以合体，舍弃另一个。若一层中只有一个操作符，就用于考虑合体。

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-08_14-58-57-2024-12-810:51:42.png" alt="Snipaste_2023-03-08_14-58-57" style="zoom: 45%;" />

### 6.4.4、拓扑排序

**AOV网**：用DAG图表示一个工程，顶点表示活动，有向边表示活动之间的顺序关系的图，称为用顶点表示活动的网络，记为AOV网。（用顶点**V**ertex表示活动**A**ctivity）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308162229163-2024-12-810:51:54.png" alt="image-20230308162229163" style="zoom:50%;" />

**拓扑排序**：即找到做事的先后顺序

在图论中，有一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序

- 每个顶点出现且只出现一次。
- 若顶点A排在顶点B的前面，则在图中不存在从顶点B到顶点A的<u>**路径**</u>。

或定义为：拓扑排序是对<u>有向无环图</u>顶点的一种排序，它使得若存在一条从顶点A顶点B的路径，则在排序序列中顶点B出现在顶点A的后面。

**每个AOV网都有一个或多个拓扑排序序列**。若一个顶点有多个直接后继，则拓扑排序结果不唯一。若有向图的拓扑序列唯一，则图中必定只有一个顶点的入度为$0$，只有一个顶的出度为$0$。

> 对一个有向图来说，若其邻接矩阵为三角矩阵，则存在拓扑序列，但不一定唯一。
>
> 有向无环图的拓扑序列唯一，并不能唯一确定该图



拓扑排序的实现思路：

1. 从AOV网中选择一个没有前驱的顶点（入度为$0$）并输出。
2. 从AOV网中删除该顶点和所有以它为起点的有向边。
3. 重复1,2知道AOV网为空 或 当前网中不存在无前驱的顶点为止

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308153335979-2024-12-811:05:27.png" alt="image-20230308153335979" style="zoom:55%;" />

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308154206648-2024-12-811:05:29.png" alt="image-20230308154206648" style="zoom:55%;" />

使用邻接表存储该有向图，用indegree[]存储各个顶点的入度，用print[]数组记录拓扑序列，用栈s保存当前入度为$0$的顶点，使用count记录已输出顶点的个数，若最终count等于顶点数，则拓扑排序完成，否则说明有环。

拓扑排序中的顶点之间不存在祖先或子孙关系，它们在拓扑序列中的关系是任意的，保存入度为$0$的顶点使用栈、队列或者数组都可以，暂存的都是入度为$0$的顶点，此时入度为$0$的所有结点之间没有关系。

```c++
bool TopologicalSort(Graph G) {
    InitStack(S);
    int indegree[G.vexnum] = {0};
    //扫描领接表，计算各顶点的入度
    for (int i = 0; i < G.vexnum; i++)
        for (p = G.vertices[i].firstarc; p ;p = p->nextarc)
            Indegree[p->adjvex]++;
    
    //保存图中入度为0的顶点
    for (int i = 0; i < G.vexnum; i++) 
        if (indegree[i] == 0)
            push(S,i);
    int count = 0; //记录已经输入的顶点数
    while (! IsEmpty(S)) { //栈不为空，说明有度为0的顶点
        pop(S,i); 
        print[count++] = i; //输出栈顶元素，count++
        //将所i指向的顶点入度减一，并且将入度减为0的顶点压入栈中
        for (p = G.vertices[i].firstarc; p; p = p->nextarc) {
            v = p->adjvex; //边表结点对应的顶点编号
            if (!(--indegree[v]))
                push(S,v);//此时v的入度为0，压入栈中
        }//for
    }//while
    if(count < G.vexnum) // **拓扑排序失败，图中有回路**
        return false;
    else
        return true; //拓扑排序成功
}
```

由于要访问各个顶点和每条边，在用邻接表存储时，时间复杂度为$O(|V|+|E|)$；用邻接矩阵存储时，时间复杂度为 $O(|V|^2)$



**逆拓扑排序**

对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：

1. 从AOV网中选择一个没有后继（出度为$0$）的顶点并输出。
2. 从网中删除该顶点和所有以它为终点的有向边
3. 重复1,2直到当前的AOV网为空

实现逆拓扑排序：

- 按照定义实现
- 利用DFS算法实现逆拓扑排序。由深度优先遍历的顶点出栈顺序得到的就是逆拓扑序列。在DFS中，每次当前结点没有指向下一结点的边时出栈，因此出栈的一定是出度为$0$的顶点。

### 6.4.5、关键路径

**AOE网**：在带权有向图中，以顶点表示事件，以有向边表示活动，以边的权值表示完成活动的开销，称之为用边表示活动的网络，简称AOE网。(用边**E**dge表示活动**A**ctivity) （**事件的发生是瞬间的，而活动需要持续一段时间**）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308162144446-2024-12-811:05:37.png" alt="image-20230308162144446" style="zoom:50%;" />

性质：

- 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
- 只有在进入某顶点的各有向边代表的活动都结束时，该顶点所代表的事件才能发生。有些活动是可以并行的

在AOE网中仅有一个入度为$0$的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为$0$的顶点，称为结束顶点（汇点），它表示整个工程的结束。

从源点到汇点的路径可能有多条，所有路径中<u>具有最大路径长度的路径</u>称为**关键路径**，关键路径上的活动称为**关键活动**。完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长



**寻找关键路径**

相关概念：

- 事件$v_k$的最早发生时间 $ve(k)$：决定了所有从$v_k$开始的活动能开工的最早时间
- **活动$a_i$的最早开始时间 $e(i)$：该活动弧的起点表示的事件发生的最早时间***
- 事件$v_k$的最迟发生时间 $vl(k)$：指不推迟整个工程完成的前提下，该事件最迟必须发生的时间
- **活动$a_i$的最迟发生时间 $l(i)$：指该活动弧的终点表示的事件的最迟发生时间和该活动所需时间之差**
- 活动$a_i$的时间余量 $d(i) = l(i) - e(i)$，表示在不增加整个工程完成总时间的情况下，活动$a_i$可以拖延的时间

若有一个活动的时间余量为$0$，则说明该活动必须如期完成。$d(i) = 0$,即$l(i) = e(i)$的活动为关键活动。

关键活动组成的路径为关键路径。

求关键路径的方法：

1. 求所有事件的最早发生时间

   按照**拓扑排序序列**，依次求各个顶点的 $ve(k)$。$ve(源点) = 0$。 

   $ve(k) = max \{ve(j)+weight<v_j,v_k>\}$，即<u>前驱加权值的最大值</u>，$v_j$是$v_k$的任意前驱

2. 求所有事件的最迟发生时间

   按**逆拓扑排序序列**，依次求各个顶点的 $vl(k)$。 $vl(汇点) = ve(汇点)$

   $vl(k) = min\{vl(j)-weight<v_K,v_j>\}$ ，即<u>后继减权值的最小值</u>，$v_j$是$v_k$的任意后继

3. 求所有活动的最早发生时间

   若边$<v_k,v_j>$表示活动 $a_i$，则 $e(i) = ve(k)$，即弧起点的最早发生时间

4. 求所有活动的最迟发生时间

   若边$<v_k,v_j>$表示活动 $a_i$，则$l(i) = l(j) - weight<v_k,v_j>$，即弧终点的最迟发生时间-权值

5. 求时间余量

   $d(i) = l(i) - e(i)$。$d(i) = 0$的活动就是关键活动，由关键活动可得关键路径。



特性：

- 若关键活动的时间增加，则整个工程的工期将延长
- 缩短关键活动的时间，可以缩短整个工程的工期。当关键活动时间缩短到一定程度时，关键活动可能会变为非关键活动。
- 当有多条关键路径时，只有加快那些包含在所有关键路径上的关键活动才能缩短整个工期（**同时加快每条关键路径才能缩短工期**）
  - 错误说法：任何一个关键活动提前完成，将使整个工程提前完成。（其他的关键活动可能延期）
  - 正确说法：任何一个关键活动不按期完成，将会影响整个工程的完成时间。所有关键活动提前完成，那么整个工程将会提前完成。