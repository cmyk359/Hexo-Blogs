---
title: 八、排序
tags:
  - 排序
  - 直接插入排序
  - 希尔排序
  - 冒泡排序
  - 快速排序
  - 简单选择排序
  - 堆排序
  - 归并排序
  - 基数排序
categories:
  - 数据结构
abbrlink: 978a1655
date: 2024-12-08 16:01:26
math: true
---

<meta name="referrer" content="no-referrer" />

## 一、排序的基本概念

排序：就是重新排列表中元素，使表中的元素满足按关键字有序的过程。

> 拓扑排序不满足排序的定义，虽然也是在内存中进行的，但不属于内部排序的范畴

​	算法的稳定性：待排序表中**关键字相同的元素**，排序后保持原顺序中**相对位置不变**。算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。

​	在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序和外部排序

​	一般情况下，内部排序算法执行过程中都有进行两种操作：**比较**和**移动**。并非所有的内部排序算法都要基于比较操作，如基数排序就不基于比较。

​	内部排序算法的性能取决于其时间复杂度和空间复杂度，而**时间复杂度一般是由比较和移动次数决定的**

> 1、对任意n个关键字基于比较的排序，关键字比较次数至少为 $\lceil log_2{(n!)} \rceil$
>
> 2、在基于比较的排序方法中，每次比较两个关键字大小之后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的 n个<u>关键字随机分布时</u>，任何借助“比较”的排序算法，至少需要 $O(nlog_2n)$的时间

## 二、内部排序

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241208160558500-2024-12-816:06:01.png" alt="image-20241208160558500" style="zoom:80%;" />

### 2.1、插入排序

​	思想：**每次将一个待排序的记录按其关键字的大小插入到前面已经排好序的序列中，直到全部记录插入完成。**

> **插入排序每趟插入元素的位置，不一定是该元素的最终位置。**

#### 直接插入排序

​	使用**顺序查找**的方式，在前面有序的序列中找到当前记录的插入位置（将大于当前记录的元素都往后移，最后将该记录插入即可）

适用于<u>顺序表、链表</u>

在直接插入排序过程中，会将待排序序列分为**有序**和**无序**两部分。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230403154509387-2024-12-817:06:51.png" alt="image-20230403154509387" style="zoom: 70%;" />

空间复杂度：$O(1)$

时间复杂度：主要来源于关键字对比、移动元素。若有n个元素，则需n-1趟处理。

- 最好情况：所有元素顺序排列时，n-1趟处理，每趟只需对比关键字1次，不用移动元素。最好时间复杂度为 $O(n)$

- 最坏情况：所有元素逆序排列时，n-1趟处理，需 $1+2+...+(n-1) = \frac{n(n-1)}{2}$次比较，$3+4+...+(n+1) = \frac{(n-1)(n+4)}{2}$次移动，故最坏时间复杂度为 $O(n^2)$
- 平均时间复杂度：$O(n^2)$ 

算法稳定性：**稳定**

> 在待排序的元素序列**基本有序**的情况下，效率最高的是<u>直接插入排序</u>，但希尔排序比直接插入排序更快



```c++
//直接插入排序
void InsertSort(int A[], int n) {
	int i, j, temp;
    for (i = 1; i < n; i++) { //将第一个元素看做已经排好序的子序列，将A[1]~A[n]插入其中
        if (A[i] < A[i-1]) {//若A[i]小于前驱，将其插入有序表
          temp = A[i];
          for (j = i - 1; j >= 0 && A[j] > temp; j--) {
              A[j + 1] = A[j]; //依次后移 
          } 
          A[j + 1] = temp;  //最后执行了一次 j--，插入位置应在 j+1。
    }
        
    // 带哨兵方式
    for (i = 2; i <= n; i++) { //A[0]存放哨兵，记录从A[1]开始
        if (A[i] < A[i - 1]) {
            A[0] = A[i]; //复制为哨兵
            for (j = i - 1; A[j] > A[0]; j--) {
                A[j + 1] = A[j];
            }
            A[j + 1] = A[0];
        }
    }
}

```

补充：单链表的插入排序

```c++
// 带头结点的单链表L,将其中元素按递增方式就地排序
void  InsertSort(LinkList L) {
    //q用于遍历有序链表寻找插入位置；pre是q的前驱；p指向要插入的结点，u是临时变量
    LinkList p, q, pre, u;
    p = L->next;
    L->next = NULL;
    while (p != NULL) {
        pre = L;
        q = L->next;
        //寻找插入位置，最终将p插入在q的前面
        while (q != NULL && q->data <= p->data) {
            pre = q;
            q = q->next;
        }
        u = p->next; //保存待比较的下一个结点
        pre->next = p; //插入节点
        p->next = q;
        p = u; //p指向下一个待比较结点
    }
}
```



#### 折半插入排序

先用折半查找找到应该插入的位置，再移动元素。

使用带哨兵的方式：

- 当 A[mid]  = A[$0$]时，为了保证算法稳定性，<u>折半查找不会停止</u>，继续在mid所指位置右边寻找插入位置。

- <u>当low>high时折半查找停止</u>，此时[low, i-1]内的元素都比 A[i]大，将[low, i-1]内的元素全部右移，再将A[i]复制到low所指位置。

相比于直接插入排序，**比较关键字的次数减少，但移动元素的次数没变**，整体来看时间复杂度仍是$O(n^2)$

算法稳定性：**稳定**

```C++
void insertSort (int A[], int n) {
    int i, j, low, high, mid;
    for (i = 2; i <= n; i++) {
        if (A[i] < A[i - 1]) {
        	A[0] = A[i];
        	low = 1; high = i - 1;
        	while (low <= high) {
            	mid = (low + high) / 2;
            	if (A[mid] > A[0])
                	high = mid - 1;
            	else   // 在 A[mid] = A[0]和 A[mid] < A[0]时，都在mid右边继续寻找
                	low = mid + 1;
        	}
        	for (j = i - 1; j >= low; j--) 
            	A[j + 1] = A[j];
        	A[low] = A[0];   
        	}
    }
}
```

#### 希尔排序

​	若初始时待排序序列**已经基本有序**，则直接插入排序也能有很好的执行效率。故先追求表中元素部分有序，再逐渐逼近全局有序。

​	思路：先将待排序表分割成若干形如 $L[i,i+d,i+2d,...,i+kd]$的特殊子表，对各个子表分别进行**<u>直接插入排序</u>**。不断缩小增量$d$的值，直至$d=1$为止。 （推荐：d1 = n/2 ，此后每次将增量缩小一半）

​	空间复杂度：$O(1)$

​	时间复杂度：和增量序列的选择有关，目前无法用数学手段证明确切的时间复杂度。但当d1 = 1时，退化为直接插入排序，其最坏时间复杂度为 $O(n^2)$;当n在某个范围内时，可达$O(n^{1.3})$

算法稳定性：**不稳定**

由于要根据增量d随机访问数组元素，故希尔排序<u>只适用于顺序表，不适用于链表</u>。

```c++
void ShellSort(int A[], int n) {
	int i, j, d;
	for (d = n / 2; d >= 1; d = d / 2) { //步长变化
	//从当前子表的第二个元素开始处理，即1+d，从下标1开始存放元素
//每次循环结束后 i++，这会切换到另一个子表中继续执行，而不是一次将一个子表处理完再处理下一个子表
		// A[0]只是暂存单元，不是哨兵
		for (i = d + 1; i <= n; i++) { 
			if (A[i] < A[i - d]) { //A[i]小于子表中的前驱
				A[0] = A[i];
				for (j = i - d; j > 0 && A[j] > A[0]; j -= d) {
					A[j + d] = A[j]; //后移步长d个单位
				}
				A[j + d] = A[0];
			}
		}
	}
}
```



### 2.2、交换排序

基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

> **交换排序每趟处理将一个元素放到了序列的最终位置。**

#### 冒泡排序

​	思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样的过程为一趟冒泡，其结果确定了一个元素在序列中的最终位置。<u>下一趟冒泡时，已经确定位置的元素不再参与比较。</u> 若有一趟冒泡没有发生交换，则说明表已经有序。

空间复杂度：$O(1)$

时间复杂度：主要来源于比较、移动元素。

- 最好时间复杂度：当元素**顺序排列**时，比较次数 = n - 1；交换次数 = $0$，故最好时间复杂度为$O(n)$
- 最坏时间复杂度：当元素**逆序排列**时，<u>比较次数  = 交换次数</u> （调用swap函数次数，不是**移动元素次数**，每次swap移动元素3次）= $(n-1)+(n-2)+...+1 = \frac{n(n-1)}{2}$，故最坏时间复杂度为$O(n^2)$
- 平均时间复杂度： $O(n^2)$

算法稳定性：**稳定**

<u>适用于顺序表和链表</u>

```c++
void bubbleSort(int A[], int n) {
    int i, j;
    bool flag; //表示本趟冒泡是否发生交换
    for (i = 0; i < n; i++) {
        flag = false;
        for (j = n - 1; j > i; j--) { // j > i;表示已经确定位置的元素不再参与比较 
            if (A[j] < A[j - 1]) { //只有 A[j-1] > A[j]时才交换，所有算法是稳定的
                swap(A[j], A[j - 1]);
                flag = true;
            }
        }
        if (flag == false) 
            return;    //本趟冒泡没有发生交换，说明表已有序
    }
}
```



#### 快速排序

​	快速排序的基本思想是基于分治法的

​	算法思想：在待排序表 $L[1...n]$中任取一个元素pivot作为枢纽（或基准，通常取首元素），通过一趟排序将待排序表**划分**为独立的两部分 $L[1...{k-1}]$和$L[k+1,...,n]$，使得$L[1...{k-1}]$中元素都比pivot小，$L[k+1,...,n]$中元素都比pivot大，则pivot放在了其最终位置$L[k]$上。这个过程称为一次“划分”。然后递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。

​	由于快排是递归地进行，排序过程类似于树形结构，所以<u>递归的深度和树的高度相同</u>。而n个结点的二叉树最小高度为 $\lfloor log_2n\rfloor+1$，最大高度为 n。

![image-20230615211549474](https://gitee.com/cmyk359/img/raw/master/img/image-20230615211549474-2024-12-817:07:10.png)



空间复杂度：$O(递归层数)$

- 最好空间复杂度为 $O(log_2n)$，最坏空间复杂度为 $O(n)$

时间复杂度：$O(n*递归层数)$

- 最好时间复杂度为 $O(nlog_2n)$：若每次选中的“枢纽”能将待排序列划分为均匀的两部分，则递归深度最小，算法效率最高。
- 最坏时间复杂度为 $O(n^2)$：即每次划分的两个部分很不均匀，算法效率最差。当初始序列**有序或逆序**，则快排性能最差（每次选择的都是最靠边的元素）
- 平均时间复杂度：$O(nlog_2n)$

   

​	快排优化思路：快排的关键在于划分，故尽量选择能把数据均分的枢纽元素，如选头、中、尾三个位置元素，取中间值作为枢纽元素；随机选取一个元素作为枢纽等。

​	算法稳定性：**不稳定**



> 1、快速排序是所有内部排序算法中平均性能最优的排序算法
>
> 2、在快排中，并不产生有序子序列，但每趟排序后都会将枢纽元素放到其最终位置上。
>
> 3、为减少快排的**递归深度**，<u>应每次优先处理长度较短的那部分</u>。如果按长的优先递归的话，每次都会将短的部分存入栈中，使栈的深度越来越大，直至长的处理完。
>
> 4、快排的**递归次数**与各元素的<u>初始排列顺序有关，与分区处理顺序无关</u>。若每次划分后分区较平衡，则递归次数少；若分区不平衡，则递归次数多。
>
> 5、排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一"趟"。第一趟，确定一个枢轴的位置，将待排序表分成左右两个子表；第二趟，对左右子表分别进行一次快排，分别确定两个子表枢轴的位置。第二趟如果只对一个子表进行了快排，而未处理另一个子表，就不能算是完整的一趟。**只有当一个枢轴最终位置在边界时，两趟快排只会确定两个元素的最终位置。**

```c++
void quickSort(int A[], int low, int high) {
    if (low < high) {
        int pivotPosition = partition(A, low, high); //划分
        //递归地处理两个子表
        quickSort(A, low, pivotPosition - 1);
        quickSort(A, pivotPosition + 1, high);
    }
}

int partition(int A[], int low, int high) {
    int pivot = A[low]; //取表中第一个元素做枢纽
    while (low < high) {
        while (low < high && A[high] >= pivot)  high--;
        //此时 A[high] < pivot，将小的元素放在low位置
        A[low] = A[high];

        while (low < high && A[low] <= pivot)   low++;
        //此时 A[low] > pivot，大的元素放在high位置
        A[high] = A[low];
    }
    //此时low和high指向同一位置，已经将其余元素都扫描了一遍
    A[low] = pivot;
    return low;
}
```



### 2.3、选择排序

思想：每一趟在<u>待排序元素中</u>选取关键字最小的元素加入有序子序列。

#### 简单选择排序

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404152332750-2024-12-817:07:17.png" alt="image-20230404152332750" style="zoom: 60%;" />

​	n个元素的简单选择排序需要n-1趟处理，每趟从后面选择一个最小的元素A[min]和A[i]互换，每一趟可以确定一个元素的最终位置（对比插入排序），经过n-1趟排序就可使得整个排序表有序。

```c++
void selectSort(int A[], int n) {
	int i, j, min_index;
	for (i = 0; i < n - 1; i++) { //进行n-1趟
//		for (j = i + 1; j < n; j++)
//			if (A[j] < A[i]) {
//				swap(A[j], A[i]);
//			}
        for (j = i + 1; j < n; j++) {
            if (A[i] < A[j])
                swap(A[j],A[i]); //这种方法会多做几次交换
        }
	}
}
```

空间复杂度：$O(1)$

时间复杂度：$O(n^2)$，主要来源于关键字对比次数和移动元素次数。

- 每趟处理都要确定一个元素的最终位置，都要交换元素一次，使用swap函数，移动关键字3次，故最多交换元素(n-1)次，移动元素3(n-1)次。元素间的比较次数和序列的初始状态无关，无论有序、逆序还是乱序都需要n-1趟处理，共需对比关键字$(n-1)+(n-2)+...+1=\frac{(n-1)n}{2}$次。故时间复杂度为$O(n^2)$

算法稳定性：不稳定

​	适用于<u>顺序表和链表</u>。

#### 堆排序

堆：若n个关键字序列$L[1,...,n]$满足下面某条特性，则称为堆(Heap)

- 若满足 $L[i] \ge L[2i]$且$L[i]\ge L[2i+1]$  $(1\le i\le n/2)$，称为大根堆，即根 $\ge$左、右
- 若满足 $L[i] \le L[2i]$且$L[i]\le L[2i+1]$  $(1\le i\le n/2)$，称为小根堆，即根 $\le$左、右



​	堆，相当于**顺序存储的“完全二叉树”**（<u>逻辑上是一棵完全二叉树，但它不是完全二叉树而是顺序表）。</u>结点i的左孩子是2i，右孩子是2i+1，父节点是$\lfloor i/2\rfloor$。编号$\le \lfloor n/2\rfloor$的都是分支结点。

​	堆排序是选择排序的一种，每次要从待排序列中选取最大或最小的元素。若能将待排序列整合为堆的形式，则**每次只需选择堆顶元素即可**，便于进行选择排序。



算法思想：以大根堆为例

1. 建堆：将初始待排序列组成为大根堆的形式，把所有**非终端结点**（编号$i\le \lfloor n/2\rfloor$）**自底向上**都检查一遍，判断是否满足大根堆的要求：根 $\ge$左、右。若不满足，将当前结点与更大的一个孩子互换（**左右孩子相同时，优先换<u>左孩子</u>**）。若互换破坏了下一级的堆，则采用相同的方法继续往下调整。（**小元素不断下坠**）
2. 排序：进行n-1趟选择排序，每一趟将堆顶元素加入有序子序列。将堆顶元素与**待排序序列**中的最后一个元素互换（<u>此时堆顶元素的最终位置已经确定，不再属于待排序序列</u>），并将待排序列再次调整为大根堆（小元素不断下坠）。

基于**大根堆**的堆排序得到的是**递增序列**，基于小根堆的堆排序得到的是递减序列。



算法效率分析：

- 时间复杂度：$O(nlog_2n)$

​	建堆和排序主要依靠堆调整函数headAdjust，其中一个结点下坠一层，<u>最多</u>比较关键字2次（先左右孩子对比，更大的再和根对比）。若树高为h，某结点在第i层，则最多下坠h-i层，关键字对比最多2(h-i)次。n个结点的完全二叉树树高 $h =\lfloor log_2n\rfloor+1$，第i层最多有 $2^{i-1}$个结点，且只有[1,h-1]层的结点才需要下坠。故**将整棵树调整为大根堆，关键字比较次数不超过4n ，其时间复杂度为**$O(n)$ 

$$1*2(h-1)+2^1*2(h-2)+...+2^{h-2}*2 =$$<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404165743943-2024-12-817:07:31.png" alt="image-20230404165743943" style="zoom: 67%;" />

​	将初始待排元素建堆后，进行n-1趟处理，每趟处理堆顶元素和堆底元素交换后，都需要将<u>根结点</u>进行下坠调整。根结点最多下坠h-1层，每次下坠最多比较两次，故每趟排序时间复杂度不超过$O(h)= O(log_2n)$，共n-1趟，所以总的**时间复杂度为 $O(nlog_2n)$**

$\therefore$  堆排序时间复杂度 = $O(n)$ +$O(nlog_2n)$ = $O(nlog_2n)$

- 空间复杂度：$O(1)$

算法稳定性： **不稳定**



> 1、堆排序适合处理关键字较多的情况（如n>1000）。通**常，取一大堆数据中的k个最大（最小）的元素时，都优先采用堆排序。**例如，在1亿个数中选出前100个最小的数，首先使用一个大小为100的数组，读入前100个数，建立**大根堆**（得到递增的序列--大根堆），而后依次读入余下的数，若大于堆顶元素则舍弃，否则用该数替代堆顶元素并重新调整堆，待数据读取完毕，堆中100个数即为所求。 实现见下。
>
> 2、一个小根堆值最大的（大根堆最小的）元素只可能在叶子结点
>
> 3、堆是一个顺序存储的无序表。用于查找时效率很低。想



堆排序

```c++
//将以k为根的子树调整的大根堆
void heapAdjust(int A[], int k, int len) {
	A[0] = A[k]; //A[0]暂存该子树的根节点
	for (int i = 2 * k; i <= len; i = i * 2) { //i *= 2 直接指向下一轮根节点的左孩子
		//比较左右孩子谁大，优先换左孩子；i < len 保证有右孩子
        if (i < len && A[i] < A[i + 1]) 
			i++;
		if (A[0] >= A[i]) break; //满足大根堆要求
		else {
			A[k] = A[i];  //将更大的孩子与双亲结点互换			
			k = i;		 //修改k值，继续向下判断A[k]放在i位置是否也满足大根堆要求	
		}
	}
	//k是最终存放A[0]的位置,将A[0]放在k位置满足大根堆要求
	A[k] = A[0];
}
//建立大根堆
void bulidMaxHeap(int A[], int len) {
	for (int i = len / 2; i > 0; i--) //从第一个非终端结点开始，从后往前调整所有非终端结点
		heapAdjust(A, i, len);
}
//堆排序
void heapSort(int A[], int len) {
	//建堆
	bulidMaxHeap(A, len);
	//进行n-1趟选择排序
	for (int i = len; i > 1; i--) {
		swap(A[i], A[1]); //堆顶元素存放在A[1]，和堆底元素互换
        //重新调整为大根堆，此时调整[1,i-1]内的元素即可，i位置的元素位置已确定
		heapAdjust(A, 1, i - 1 ); 
	}
}
```



​	补充：**使用最小堆，在N个整数中找出最大的K个数**（N>K）。首先，用前K个数构造容量为K的最小堆。然后将后N-K个数依次与堆顶元素比较，若比堆顶元素大，则替换堆顶元素并调整最小堆结构；若比堆顶元素小，则继续比较下一个元素。最终，最小堆存储的就是最大的K个数，堆顶元素是最大的K个数中最小的一个。

```c++
void heapAdjust(int* heap, int beginIndex, int endIndex) {
	heap[0] = heap[beginIndex];
	for (int i = 2 * beginIndex; i <= endIndex; i *= 2) {
		if (i < endIndex && heap[i] > heap[i + 1])
			i++;
		if (heap[0] <= heap[i]) break;  //满足小根堆的定义
		else {
			heap[beginIndex] = heap[i];
			beginIndex = i;
		}
	}
	heap[beginIndex] = heap[0];
}

void buildHeap(int* heap, int k) {
	for (int i = k / 2; i > 0; i--)
		heapAdjust(heap, i, k);
}

void getMaxK(int* heap, int K, int N) {
	int i;
	buildHeap(heap, K); //建立容量为K的小根堆
	for (i = K + 1; i <= N; i++) {
		if (heap[i] > heap[1]) { 
			heap[1] = heap[i];
			heapAdjust(heap, 1, K);
		}
	}
        cout << "最大的K个数如下：" << endl;
    for (i = 1; i <= K; i++) {
        cout << heap[i] << " ";
    }
}
```



**堆的插入和删除**

- 插入：将新元素放到表尾（堆底），根据大/小根堆的要求，新元素不断上升，直到无法上升为止，时间复杂度为$O(log_2n)$。
  - 每次上升调整只需对比关键字1次，**注意最后一次上升时，上升失败，这次比较也要算上。**
- 删除：被删除元素用表尾（堆底）元素替代，根据大/小根堆的要求，替代元素不断下坠，直到无法下坠为止，时间复杂度为$O(log_2n)$。
  - 每次下坠调整，可能要对比关键字2次，也可能对比1次（看当前子树有几个孩子）。**注意最后一次下降时，下降失败，这次比较也要算上。**





### 2.4、归并排序

​	归并的含义：将两个或两个以上的<u>有序表</u>组合成一个新的有序表。

​	2路归并：假定待排序表含有n个记录，则可将其视为n个有序子表，每个子表长度为1，然后两两归并，得到 $\lceil n/2\rceil$个长度为2或1的有序表；继续两两归并.....如此重复，直到合并成一个长度为n的有序表为止。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404183815830-2024-12-817:07:47.png" alt="image-20230404183815830" style="zoom:40%;" />

​	归并过程类似一棵倒立的二叉树，称为2路归并的归并树

​	其核心操作是把数组内两个**相邻的有序表**合并为一个。设有两段有序表A[low...mid]和 A[mid+1...high],放在同一顺序表的相邻位置，先将他们复制到辅助数组B中。每次从B中的两个段中取出一个记录进行关键字的比较，将较小的放入A中。当数组B中有一段的下标超出其对应的表长（即该段所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A中。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404184021817-2024-12-817:07:52.png" alt="image-20230404184021817" style="zoom:40%;" />



时间复杂度：$O(nlog_2n)$

​	对于二路归并的归并树，所有待排序元素在第h层，总共进行h-1趟排序。二叉树的第h层有$2^{h-1}$个结点，故 $n \le 2^{h-1}$，$h-1=\lceil log_2n\rceil$，所以归并趟数为 $\lceil log_2n\rceil$ 。每趟归并时间复杂度为 $O(n)$,则算法时间复杂度为 $O(nlog_2n)$

> n个元素进行 k路归并排序时，归并趟数 =  $\lceil log_kn\rceil$
>
> 一个有序表有m个元素，另一个有序表有n个元素，**n>m**，将两个有序表合并成一个有序表，最少比较m次，最多比较n+m-1次。
>
> 时间复杂度为$O(log_2n)$且稳定的排序算法 是归并排序算法

空间复杂度：$O(n)$，主要来自于辅助数组B，递归栈的空间不超出$O(h)$

算法稳定性：**稳定**

```c++
//归并左右相邻的两个有序表
void merge(int A[], int low, int mid, int high) {
    int* B = new int[n]; //  int *B = (int *)malloc(sizeof(int)*n);
    int i, j, k;
    for (i = 0; i < n; i++) {  //将A中的所有元素复制到B中
        B[i] = A[i];
    }
    i = low, j = mid + 1, k = i;
    while (i <= mid && j <= high) {
        //比较B的左右两段中的元素，将较小的复制到A中
        if (B[i] <= B[j]) //两个值相等时，优先让左边的归并，保证算法的稳定性
            A[k++] = B[i++];
        else
            A[k++] = B[j++];   
    }
    while (i <= mid) A[k++] = B[i++]; //若第一个表未检测完，复制
    while (j <= high) A[k++] = B[j++];//若第二个表未检测完，复制
}
//归并排序
void mergeSort(int A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        mergeSort(A, low, mid);       //对左侧子序列进行递归排序
        mergeSort(A, mid + 1, high);  //对右侧子序列进行递归排序
        merge(A, low, mid, high); //归并
    }
}
```

### 2.5、基数排序

​	基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。为实现多关键字排序，通常有两种方法：<u>最高位优先法</u>和<u>最低位优先法</u>。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404213454918-2024-12-817:07:59.png" alt="image-20230404213454918" style="zoom: 67%;" />

**由于要得到递减的序列，先从权重高的队列开始收集；要得到递增的序列，则需从权重低的队列开始收集。只是<u>收集时</u>顺序不同而已**

​	例如：初始序列是有n = 11个结点的线性表，每个结点的关键字可以分为 d = 3元组，分别表示个、十、百位，该元组中每个关键字 $\in[0,r-1]$ ,基数r = 10。(有n个关键字，把每个关键字拆成d部分，每部分取得r个值)

得到递减序列的过程如下：

第一趟：按个位进行分配收集，得到按个位递减排序的序列。

![image-20230615211642124](https://gitee.com/cmyk359/img/raw/master/img/image-20230615211642124-2024-12-816:49:28.png)



第二趟：按十位进行分配收集，得到按“十位”递减排序的序列，“十位”相同的按“个位”递减排序

![image-20230615211710210](https://gitee.com/cmyk359/img/raw/master/img/image-20230615211710210-2024-12-816:48:28.png)

第三趟：第三趟按“百位”分配、收集：得到一个按“百位”递减排列的序列，若“百位”相同则按“十位”递减排列，若“十位”还相同则按“个位”递减排列。

![image-20230615211733092](https://gitee.com/cmyk359/img/raw/master/img/image-20230615211733092-2024-12-816:50:28.png)

算法性能分析：

- 空间复杂度：需要r个辅助队列，空间复杂度= $O(r)$

- 空间复杂度：$O(d(n+r))$

  一趟分配时间复杂度为$O(n)$，一趟收集时间复杂度为$O(r)$，总共d趟分配、收集。收集每个队列时，只需让链表最后一个结点的next指向队列的对头即可，时间开销为$O(1)$，共要收集r个队列，所以一趟收集的时间复杂度为$O(r)$

算法稳定性：稳定（基你太稳） 

基数排序通常基于**链式**存储实现。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404215549092-2024-12-817:08:26.png" alt="image-20230404215549092" style="zoom: 67%;" />

​	在该例中，每个关键字可以被拆成三部分：年、月、日，并且每部分的基数并不相同，每一趟分配收集时设置的辅助队列也不同。使用基数排序处理该问题，比其他内部排序的效率都要高。

适合用基数排序处理的情况：

- 数据元素的关键字可以方便的拆分为的组，且d较小。
- 每组关键字的取值范围不大，即r较小。
- 数据元素个数n较大。





### 2.6、各种内部排序算法的比较

基于三个因素进行对比：时间复杂度、空间复杂度、算法的过程特征

- 时间复杂度和空间复杂度

| 排序方法     |              | 时间复杂度   |              | 空间复杂度             | 稳定性 | 实现          |
| ------------ | ------------ | ------------ | ------------ | ---------------------- | ------ | ------------- |
|              | 最好情况     | 平均情况     | 最坏情况     | 平均情况               |        |               |
| 直接插入排序 | $O(n)$       | $O(n^2)$     | $O(n^2)$     | $O(1)$                 | 稳定   | 顺序表、 链表 |
| 希尔排序     |              |              |              | $O(1)$                 | 不稳定 | 顺序表        |
| 冒泡排序     | $O(n)$       | $O(n^2)$     | $O(n^2)$     | $O(1)$                 | 稳定   | 顺序表、链表  |
| 快速排序     | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n^2)$     | $O(log_2n)$ 最坏$O(n)$ | 不稳定 | 顺序表        |
| 简单选择排序 | $O(n^2)$     | $O(n^2)$     | $O(n^2)$     | $O(1)$                 | 不稳定 | 顺序表、链表  |
| 堆排序       | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(1)$                 | 不稳定 | 顺序表        |
| 2路归并排序  | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n)$                 | 稳定   | 顺序表、链表  |
| 基数排序     | $O(d(n+r))$  | $O(d(n+r))$  | $O(d(n+r))$  | $O(r)$                 | 稳定   | 链表          |

算法过程特征

- 选择、交换排序每趟都可以确定一个元素的最终位置，但插入、归并、基数排序不行。故给出一趟排序后的结果，观察这趟排序有没有确定某个元素的最终位置，从而判断是否为选择和交换排序。
- 给出某种算法两趟排序后的结果：插入排序（直接和折半）2趟排序后前三个元素有序；选择排序和冒泡排序2趟排序后，最值和次值的最终位置已经确定；快速排序2趟排序后，产生两个（有一个枢轴最终位置在边界）或三个分界线，界内可以无序，但界间有序（可以和最终序列对比找到这些界）

- 排序趟数与初始状态**有关**的：交换类排序（冒泡、快排）
- 元素总比较次数与初始状态无关的：选择排序、基数排序
- 元素总移动次数与初始状态无关的：归并排序、基数排序

## 三、外部排序

​	外部排序是指待排序文件较大，内存中放不下，需存放在外存的文件的排序。

​	文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。外部排序通常采用归并排序法，包括两个过程：

1. 生成初始归并段

   根据内存缓冲区的大小，将外存中的文件块读入内存并利用内部排序算法对其进行排序，并将排序后得到的有序块重新写回外存，得到初始归并段。

2. 对归并段进行归并排序

   对这些归并段进行逐趟归并排序，使归并段由小到大，直至整个文件有序为止。

​    所以，外部排序的时间 = <u>内部排序的时间</u>（过程1所需） + <u>外存信息读写时间 + 内部归并所需时间</u>（过程2所需）。

​	外存信息的读写时间和读写磁盘的次数成正比，远远大于内部排序和内部归并的时间，因此应着力减少磁盘读写次数。

​	若文件有m个块，则总的读写次数 = 2m + 2m * 归并趟数。 **只能通过<u>减少归并趟数</u>来优化外部排序。**

如何减少归并趟数？

​	对r个初始归并段做k路归并，则归并树可以用k叉树表示。因为各归并段处于叶结点位置，若树高为h，则归并趟数= h-1=**$\lceil log_kr\rceil$**。故可**通过增大归并路数k，减少归并段数量r**来减少归并趟数。

- 增大归并路数k。k不能太大，k路归并需要在内存中开辟k个输入缓冲区，内存开销增大；同时每条选一个最小的关键字需要k-1次对比，内部归并开销增大（**可通过败者树解决**）。
- 减少归并段数量r。生成初始归并段的工作区越大，初始归并段越长，归并段数量越少。但会增加内存开销（**可通过置换选择排序解决**）。



​	补：k路平衡归并：1、最多只能有k个归并段归并为一个。2、每趟归并中，若有m个归并段参与归并，则经过这趟处理得到$\lceil \frac{m}{k}\rceil$个新的归并段。如图，在这个4路归并排序中，第一趟排序有8个归并段参与，最后生成了3个新的归并段，故不是4路平衡归并排序。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408222741513-2024-12-817:08:38.png" alt="image-20230408222741513" style="zoom: 40%;" />

**败者树**

​	败者树是树形选择排序的一种变体，可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部节点用来记忆左右子树中的失败者（只保存其所在归并段的编号），而让胜者往上继续比较，一直到根结点。若比较两个数，大的为失败者，小的为胜者，则根结点指向的数为最小数。

其中，这些叶子结点是虚拟的，只用长度为5的数组保存败者树中失败者和冠军的编号。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408214935590-2024-12-817:08:41.png" alt="image-20230408214935590" style="zoom:67%;" /><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408215030596-2024-12-817:19:51.png" alt="image-20230408215030596" style="zoom:50%;" />

​	第一次生成败者树后，从冠军处得到最小元素是3号归并段当前参与比较的元素6。选择下一个最小元素时，从3号归并段选取下一个元素参与比较，一直比到根结点为止，选出下一个冠军，即最小的元素。依次进行下去完成这趟归并。

对于k路归并，第一次构造败者树需要对比关键字k-1次。有了败者树，选出最小的元素只需$\lceil log_2k\rceil$次。

​	使用败者树后，每次选择一个最小元素的比较次数为败者树树高$\lceil log_2k\rceil$，每趟归并n个元素需要做$(n-1)\lceil log_2k\rceil$对比，则总的比较次数为 $\lceil log_kr\rceil (n-1)\lceil log_2k\rceil = (n-1) \lceil log_2r \rceil$。

​	可见，使用败者树后，<u>内部归并的比较次数</u>与k无关了。但外部排序的效率仍与k有关，k并不是越大越好。



**置换选择排序**

​	输入文件FI，输出文件FO，工作区WA，WA可容纳w个记录，算法步骤如下：

1. 从FI中读取w个元素到工作区WA中
2. 从WA中选取关键字最小的记录k，即为 MiniMax = k
3. 将MiniMax输入到FO中
4. 若FI不空，则从FI中读取下一个记录到WA中
5. 从WA中 大于MiniMax的元素中 选取最小的，记为新的MiniMax
6. 重复 3~5，直到在WA中找不出新的MiniMax为止，由此得到一个初始归并段。
7. 重复 2~6，直到WA为空，由此得到全部的初始归并段。

   通过置换选择排序得到的初始归并段的长度不是等长的，其平均长度为传统归并段长度的2倍，从而减少初始归并段数量。

**最佳归并树**

​	文件经过置换选择排序后，得到的是长度不等的初始归并段，如何对长度不等的初始归并段进行归并排序，使得I/O次数最少？

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408223526244-2024-12-817:08:49.png" alt="image-20230408223526244" style="zoom:67%;" />

​	对r个初始归并段进行k路平衡归并后得到一棵k路归并树（如图），以归并段的长度 表示该结点的权值，树的带权路径长度WPL = $2*1+（5+1+6+2）*3 = 44$ = 读磁盘的次数 = 写磁盘的次数。

​	故，**归并过程中磁盘I/O次数 = 归并树WPL * 2**。要让磁盘I/O次数最少，就要让归并树WPL最小。将**哈夫曼树**的思想推广到k叉树，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树。

​	对k叉归并，若初始归并段不足以构成严格k叉归并树，需添加一些**长度为$0$**的“虚段”，再进行k叉哈夫曼树的构造。对严格k叉树，只有度为$0$和度为k的结点，由总结点数 =  $n_0 + n_k = k *n_k + 1$ , 故 $n_k = \frac{n_0-1}{k-1}$是一个整数。

- 若 $(n_0 - 1) \% (k-1) = 0$，则可以构成严格k叉树，不需要添加虚段
- 若 $(n_0 - 1) \% (k-1) = u$，则不能构成严格k叉树，需要添加 $(k-1) - u$个长度为$0$的虚段。

## 四、补充：索引

### 4.1、索引

索引、索引项：
	一般将某个字段设置为索引，索引是将关键码与他对应的记录相关联的过程，一个索引隶属于某一文件，它由若干索引项构成；
每一个索引项至少包含关键码、和关键码对应的记录在存储器中的位置等信息。

​	索引并不需要重新排列记录在文件中的顺序，一个文件可能由多个相关的索引，每个索引往往支持一个关键码，并且通过改索引实现对文件中记录的快速访问。


特点简介：

索引文件比数据文件小，可以有效地装载到内存。通过对内存索引文件的查找定位到记录，然后通过一次磁盘对象读取操作就可以获取到需要搜索的对象。



静态索引：是指在文件创建时生成索引结构，一旦生成就固定下来，只有当文件在组织是才发生变化；
动态索引：是指文件创建时生成的索引结构，在文件执行插入、删除等操作时，索引结构本身随之发生变化；



### 4.2、静态索引结构

1）线性索引 （主键索引）（索引数组存储）

- 稠密索引：

  **一个索引项对应数据表中的一个对象**。当对象在外存中按添加的顺序而不是按关键码有序存放的时候必须采用稠密索引。

- 稀疏索引（索引顺序结构、分块查找）：

  数据对象在外存中按关键码（主键）分块有序存放，每个子块中的对象可以是有序，也可以是无序。（**块间有序，块内有序或无序**）有序的话子块中可以使用折半查找，提高查找速度，但是添加记录也会慢些。对索引顺序结构进行查找时，根据关键码先在索引中定位对象所在的数据子块，然后在子块中定位查找的对象。

 

2）倒排表

​	在许多情况下，在对文件进行查找时，不仅需要对主关键码进行查找，还可能需要对**次关键码**进行查找，如果索引表中只有主关键码索引，则对这样的查找，还需建立一系列的次关键码索引。



​	主键索引能唯一地标识对象，也叫主索引。主键只有一个，日常应用中也需要对其它熟悉列进行搜索，所以，除了主关键码外，也有必要把其它常用的搜索属性设定为**次关键码**，建立次索引表。次索引列因为属性值不是唯一的，所以在次索引中，建立一个所有值的一个列表，对每个取值建立一个具有相同属性值的对象的存放有序或主键有序的顺序链表。次索引中存放对象地址的指针可以用主键来表示，这样在非主键属性列查找中，可以先在次索引中查找到对象主键，然后在主键索引中找到对象的地址。

 

3）m路**静态**搜索树（多级索引）

m路搜索树：

​	当数据量很庞大的时候，索引块也会非常大，一次性无法读入所有的索引块到内存，这个时候就要考虑多级索引，最高一级的索引常驻内存就可以了，每一级中的字索引块有自己最大主关键码值。多级索引中，每个索引块大小一样，**每个索引块最大存放m个索引项，每个索引项给出各子树节点最大关键码和存放地址**，这样形成了m叉树，这种利用m叉树实现的多级索引，就是m路搜索树。m叉树中m意思是每个索引块中最大存放的索引项数目，跟索引级数没有关系。m叉树中叶节点中个索引项给出数据表中对象的关键码和存放地址。

 

4.3、动态索引结构（动态m路搜索树）

​	动态调整的目的一般就是保持搜索树的平衡性。

1）B树

​	定义见上。B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。

 

2）B+树

​	B树的变种。B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

所以 B+树有两种搜索方法：

​	一种是按叶节点自己拉起的链表顺序搜索。

​	一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。B+ 树中，数据对象的插入和删除仅在叶节点上进行。

 

这两种处理索引的数据结构的不同之处：

Ø  B树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。

Ø  因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。

Ø  B树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。

 

### 4.3、hash索引

​	**hash索引只支持精确查找，不支持范围查找**。hash算法函数有可能不能保证哈希值的唯一性，即使是crc32这样的函数。所以可能有<u>哈希碰撞</u>问题（不同的串得到相同的hash值），md5()和sha1()是强加密函数，不会产生哈希碰撞。