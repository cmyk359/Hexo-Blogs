---
title: 三、栈和队列
tags:
  - 栈
  - 队列
  - 循环队列
  - 三元组顺序表
categories:
  - 数据结构
abbrlink: d403458d
date: 2024-12-06 16:09:36
math: true
---

<meta name="referrer" content="no-referrer" />

## 一、栈

定义：只允许在一端进行插入和删除操作的线性表。

其特点是 **后进先出（LIFO）**

其逻辑结构和普通线性表相同，插入和删除操作有区别。

### 1.1、顺序栈

采用顺序存储的栈称为顺序栈。

```c
//结构定义
#define STACK_INIT_SIZE 100
#define STACK_INCRIMENT_SIZE 10;
typedef struct {
    ElemType *base; //栈底指针，构造前和销毁后为空
    ElemTyoe *top; // 栈顶指针,默认指向栈顶元素的下一个位置
    int stackSize; // 当前分配的栈的存储空间个数
}SqStack;
```

**初始化：**

- S.top = 0：规定top指针指向下一个栈顶元素的下一个存储单元，即下一个可以存储的位置。
- S.top = -1：规定top指针指向当前栈顶元素所在的存储单元。

top指针的初始值不同，顺序栈的入栈、出栈、判满操作会有差异

- 当S.top = 0 时：
  - 入栈：S.data[S.top ++] = x;  或*top++ = x;
  - 出栈：x = S.data[-- S.top];  或 x = *--top; 
  - 取栈顶元素： x = S.data[S.top - 1];或 x = *(top -1)
  - 栈满：S.top == S.base; 
- 当S.top = -1时：
  - 入栈：S.data[++ S.top] = x;或 *++top =x ;
  - 出栈：x = S.data[S.top --]; 或 x = *top--
  - 取栈顶元素：x = S.data[S.top];或 x = *(top)
  - 栈满：S.top == S.base

元素插入栈顶时，和顺序表一样，要判断是否栈满 `S.top - S.base == S.stackSize`。若满了，则扩容后插入。

### 1.2、共享栈

顺序栈的大小在声明后不可变，可以在一开始就申请较大的存储空间。**为了提高内存的利用率，**使用**共享栈**。



两个顺序栈共享一个一维数组，将两个栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025163530823-2024-12-616:22:53.png" alt="image-20221025163530823" style="zoom:80%;" />

**仅当两个栈顶指针相邻（top1 - top0 = 1）时，判定为栈满。**

**共享栈是为了更有效地利用存储空间，对存取效率没有什么影响。**

### 1.3、链栈

采用链式存储的栈称为链栈。通常采用单链表实现。

链栈的操作和链表类似，出栈和入栈的操作都在链表表头进行。



## 二、队列

定义：队列是只在一端进行插入，在另一端进行删除的线性表。

其特点是 **先进先出（FIFO）**

### 2.1、队列的顺序存储结构

用静态数组存放数据元素，设置队头指针front和队尾指针rear。

```c++
#define Maxsize 10 //定义队列中最大存放元素的个数
typedef struct {
    ElemType data[Maxsize];
    int front, rear;
}SqQueue;
```

初始状态：Q.front = Q.rear = 0 （判空条件）

入队：队列不满时，先送值到队尾元素，再将队尾指针加一。

出队：队列不空时，先取队头元素，再将队头指针加一。

不能用 Q.rear == maxsize作为队列满的条件，这是一种**假溢出**。 



**循环队列**

用**模运算**将静态数组的存储空间变成一个**环状。**

循环队列是队列的一种顺序存储结构，引入循环队列时为了**克服假溢出时大量移动元素**。

> 循环队列也存在空间溢出问题，循环队列解决的是“假溢出”问题，但仍然会出现真正的溢出问题。假溢出是下标溢出，真溢出是空间溢出。



根据`Q.front和Q.rear`的初始值的不同，对循环链表相同操作的代码有所不同。主要有以下三种初始情况，第一种是严蔚敏教材的初始情况，第二种是西电教材中有关循环队列的规定，第三种也较为常见。





**1、初始时 Q.front =0，  Q.rear = 0 ，此时尾指针指向队尾元素的下一个存放位置，头指针指向队首元素**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025173320423-2024-12-616_36_34-2024-12-617:00:19.png" alt="image-20221025173320423" style="zoom: 50%;" />

- 元素入队： Q.data[Q.rear] = x;  Q.rear = (Q.rear + 1) % maxsize; 

- 元素出队： x = Q.data[Q.front];  Q.front = (Q.front + 1) % maxsize;

- 队列长度： (Q.rear  - Q.front + maxsize) % maxsize;   

- 判空： Q.front = Q.rear

- 判满

  - **牺牲一个存储空间<放弃的是rear指向的位置>，来区分队空和队满**，**当rear的下一个位置为front时队满**，即 （Q.rear + 1) % maxsize == Q.front

  - **增加size变量记录当前队列长度**，初始化时size = 0， 入队时size++ ，出队时 size--。

    此时队空的条件为 Q.size == 0;队满的条件为 Q.size == maxsize

  - 只有出队才会导致队列为空，只有入队才会导致队列变满。通过区分 导致 Q.front == Q.rear 的最近一次操作时入队还是出队，来判断当前队列为空还是满。

    **增加tag 标志等于0或1，用于标记最近的一次操作时出队还是入队。**执行出队操作时，Q.tag = 0; 执行入队操作时，Q.tag = 1

    因此判空条件为：Q.front == Q.rear && Q.tag == 0;  判满条件为： Q.front == Q.rear && Q.tag == 1;





**2、初始时 Q.front = Q.rear = maxsize - 1 ，此时尾指针指向队尾元素，头指针指向队首元素的前一个位置**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025173320423-2024-12-616:57:08.png" alt="image-20221025173320423" style="zoom: 50%;" />

- 入队：rear = (rear + 1) % maxsize， Q.data[rear] = x
- 出队：front = (front + 1) % maxsize, x = Q.data[front]
- 判空：front == rear
- 判满：front == (rear + 1) % maxsize
- 元素个数：(rear - front + maxsize) % maxsize



**3、初始时 Q.front = 0 ,Q.rear = maxsize - 1 , 此时队尾指针指向队尾元素，队友指针指向队头元素**

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2022-10-25_17-46-22-2024-12-617:37:58.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 50%;" />

- 元素入队：Q.rear = (Q.rear + 1) % maxsize; Q.data[Q.rear] = x;

- 元素出队：x = Q.data[Q.front];  Q.front = (Q.front + 1) % maxsize;

- 判空：（Q.rear + 1 ) % maxsize == Q.front

- 判满

  - **牺牲一个存储空间 <放弃的是rear的下一个位置>，来区分空和满，** 判断条件为 (Q.rear + 2) % maxsize == Q.front

  - 增加辅助变量size，记录当前队列中的元素个数

  - 使用tag标志。入队时，tag为1；出队时，tag为0；

    判空条件为 ：(Q.rear + 1) % maxsize == Q.front && Q.tag == 0

    判满条件为：（Q.rear + 1）%maxsize == Q.front && Q.tag == 1

- 元素个数：(Q.rear  - Q.front + 1+ maxsize) % maxsize;   

### 2.2、队列的链式存储结构

队列的链式表示称为**链队列。**它实际上就是一个同时带有队头指针和队尾指针的单链表。

<img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_17-51-34-2024-12-617:51:49.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 60%;">

```c++
typedef struct {
    ElemType data;
    struct LinkNode *next;
}LinkNode;

typedef struct {
    LinkNode *front, *rear;
}LinkQueue;
```

**带头结点的链队列**：为了统一在第一个位置和其余位置插入和删除操作，一般采用带头结点的单链表

- 初始化：`Q.front = Q.rear = (LinkNode*) malloc (sizeof(LinkNode)); Q.front->next == NULL;`

- 元素入队：申请一个LinkNode 结点s，` s->next = null; Q.rear -> next = s; Q.rear = s`;

- 元素出队：当队列不为空时，删除队头结点  `p = Q.front->next; Q.front->next = p->next; free(p);`

  			**在释放结点p之前需要判断  `Q.rear == p`，若p就是最后一个结点 需要单独处理 `Q.rear = Q.front**

- 判空：`Q.front == Q.rear`

**不带头结点的链队列**：

- 初始化：`Q.front = NULL; Q.rear = NULL;`
- 元素入队： 在插入第一个元素结点 s 时，需要单独处理 `Q.front = s; Q.rear = s;`
-  元素出队：最后一个结点出队时要单独处理，将 front和rear都指向NULL；
- 判空：`Q.front == NULL`

### 2.3、双端队列

双端队列是指允许两端都可以进项入队和出队操作的队列。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025214902241-2024-12-617:54:33.png" alt="image-20221025214902241" style="zoom: 67%;" />

- 输入受限的双端队列：只允许在一端插入，两端删除的队列
- 输出受限的双端队列：只允许从两端插入，一端删除的队列



在以某一顺序输入若干元素，判断输出是否合法时：

- **关键：在输出序列中的某个元素，在该元素之前的所有元素都已经输入**
- 在输入受限的双端队列中，**只需验证能否利用两侧的出队操作拼凑出目标输出序列**
- 在输出受限的双端队列中，由于只能从一端出队，所以目标输出序列在队列中的相对位置已知，**只需验证能否通过两端的输入操作得到目标输出序列**。

在栈中合法的输出序列，在双端队列中也必定合法。

## 三、栈和队列的应用

### 3.1、栈在括号匹配中的应用

思路：依次扫描所有字符，遇到左括号则入栈，遇到右括号则弹出栈顶元素检查是否匹配

匹配失败的情况：

1. 扫描到右括号且栈空，右括号单身。
2. 扫描完所有字符后，栈非空，左括号单身。
3. 左右括号不匹配

### 3.2、栈在表达式求值中的应用

三种表达式：

- 中缀表达：运算符位于两操作数之间
- 前缀表达式：运算符位于两操作数之前（波兰表达式）
- 后缀表达式：运算算符位于两操作数之后（逆波兰表达式）

#### 中缀转后缀（手算）

1. 确定中缀表达式中各个运算符的运算顺序，采用**左优先原则**：只要左边的运算符能先计算就优先让左边的计算。（此时的手算结果与计算机处理结果一致）
2. 选择下一个运算符，按照【左操作数，右操作数，运算符】的方式组成一个新的操作数
3. 如果还有运算符未被处理，继续步骤 2

<img src = "https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_18-15-07-2024-12-618:15:22.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 50%;">

> 中缀转前缀的手算方法与以上过程类似，在确定哥哥运算符的运算顺序是采用 “右优先”原则，并按照【运算符，左操作数，右操作数】的方式组合成新的操作数



#### 中缀转后缀（机算）{#custom-id}

初始化一个栈，用于保存还不确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：

- 遇到操作数：直接加入后缀表达式
- 遇到界限符：遇到  `(` 直接入栈，遇到 `)` 则一次弹出栈内运算符并加入后缀表达式，直到弹出 `(` 为止。注意，`)`不用入栈。
- 遇到运算符：一次弹出栈中优先级**高于或等于**当前运算符的所有运算符，并加入后缀表达式，若遇到 `(` 或栈空则停止，之后再把当前运算符入栈。

按上述规则处理完所有字符后，将栈中剩余运算符依次弹出并加入后缀表达式。

#### 计算后缀表达式（手算）

从左往右扫描，每遇到一个运算符，就让其前面最近的两个操作数执行相应的运算，合体为一个操作数。

#### 计算后缀表达式（机算）

初始化一个栈，用于存储扫描到的操作数

1. **从左往右**扫描下一个元素，直到处理完所有元素。
2. 若扫描到操作数则入栈，并回到 1；否则执行 3
3. 扫描到操作符，则弹出两个栈顶元素进行相应的运算（**注：此时先出栈的是右操作数**），运算结果压回栈顶，回到 1

若表达式合法，则最后栈中只会留下一个元素，就是最终结果

> 用栈实现前缀表达式的方法同上，不同之处在于：i. 从右向左扫描前缀表达式 ii.执行运算时，先出栈的是左操作数

#### 利用栈实现中缀表达式的计算

思想：中缀转后缀 + 后缀表达式求值。

思路：初始化两个栈，操作数栈和操作符栈，从左向右扫描中缀表达式

- 若扫描到操作数，则压入操作数栈
- 若扫描到操作符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈。期间也会弹出运算符，每弹出一个运算符时，就需要弹出两个操作数栈顶元素来执行相应的运算，运算结果压回操作数栈。

### 3.3、栈在递归中的应用

### 3.4、栈在数制转换中的应用

### 3.5、队列在层序遍历中的应用

## 四、特殊矩阵的压缩存储

[参考](https://blog.csdn.net/erthrerg/article/details/137921762)

关键：计算给定元素是顺序存储的第几个元素

计算给定数组元素的地址：<u>起始位置+**前面元素的个数** * 每个元素所占空间</u>

- 一维：$A[0...{n-1}]$,则$LOC(a_i) = LOC(a_0) + i * L$,其中$L$为每个数组元素所占的存储单元个数
- 二维 $A[0...h_1][0...h_2]$,则$LOC(a_{ij}) = LOC(a_{00}) + (i * (h_2 + 1)+j)*L$





### 4.1、利用三元组顺序表对稀疏矩阵进行压缩存储

```c++
#define maxsize 10000
typedef int datatype;

typedef struct {
    int i, j;
    datatype v;//非零元素所在行列为i，j，值为v
}triple; //三元组（i,j,v）

typedef struct {
    triple data[maxsize];
    int m, n, len;//矩阵的行、列、非零元素个数
}tripleTable; //三元组顺序表
```



<img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_19-42-51-2024-12-619:43:15.png">

**三元组顺序表的转置**

1. 简单转置方法

   分两步：

    i.将三元组顺序表中的i和j互换，互换后其中的i并不是有序的

    ii.按 i 进行非递减排序，是指变成像之前一样有序的状态。

   其中涉及排序需要采用双重循环时间复杂度高

2. 快速转置法

   **用空间换时间**，设置两个辅助数组 `num` 和 `pos`

   num[]：用来记录每一列**非零元素个数**

   pos[]：用来存放每一列的第一个非零元素在转置后在三元组中存放的位置。

   > 初始时保存的是第一个非零元素的位置，在遍历过程中随着每次读取pos[k]后其值加一，保存该列下一个非零元素的存放位置

   ```c++
   //求num[]
   for (int i = 0; i < souce.n; i++)
       num[i] = 0; //共有souce.n列，每列非零元素个数初始化为0
   for (int k = 0; k < souce.len; k++) 
       num[souce.data[k].j]++;  //列号相同则对应的num值加一
   ```

   

   ```c++
   //求pos[]
   pos[0] = 0; //第1列第一个非零元素肯定存放在三元组的第一个位置
   for (int k = 1; k < souce.n; k++) 
       //当前列第一个非零元素的位置 = 上一列的第一个非零元素的位置 + 上一列非零元素的个数
       pos[k] = pos[k - 1] + num[k - 1]; 
   ```

   <img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_23-09-21-2024-12-623:09:42.png" alt="PixPin_2024-12-06_23-09-21" style="zoom: 67%;" />

   求出`num[]`和`pos[]`后，遍历三元组顺序表，每遍历一个元素`souce.data[k]`，交换它的行和列，再查询`pos[souce.data[k].j]`得到转置后它的位置，移动它到指定位置。再执行`pos[souce.data[k].j] ++`，以便同列的下一个非零元素能放在它的后面	

   

   