---
title: 四、串
tags:
  - 串
  - 串的模式匹配
  - 朴素模式匹配
  - KMP算法
  - next数组
categories:
  - 数据结构
abbrlink: dac6dce7
date: 2024-12-07 09:42:13
math: true
---

<meta name="referrer" content="no-referrer" />

数据结构目录：

[一、绪论](https://catpaws.top/bfab103e/)

[二、线性表](https://catpaws.top/7682ef9a/)

[三、栈和队列](https://catpaws.top/d403458d/)

[四、串](https://catpaws.top/dac6dce7/)

[五、树和二叉树](https://catpaws.top/453281de/)

[六、图](https://catpaws.top/ce993eeb/)

[七、查找](https://catpaws.top/24d4ba7c/)

[八、排序](https://catpaws.top/978a1655/)

## 一、定义

**串** : 即字符串(string)，是由零个或多个<u>字符</u>组成的有限序列。长度为0称为空串。

**子串**：串中任意个<u>连续的字符</u>组成的子序列成为该串的字串，选取时一定要<u>保证连续</u>。

> 区别：子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。
>
> 如S=‘Hello World’中，'He'、'Hello'等是子串，而'HW'是子序列。

**主串**：包含子串的串。

- 字符在串中的位置：字符在串中的序号， 即**位序**，是从1开始的。

- 子串在主串中的位置：子串的第一个字符在主串中的位置。

前缀：除最后一个字符外，字符串的**所有头部子串**。

后缀：除第一个字符外，字符串的**所有尾部子串**。

> 例如 "abad"的前缀为 {"a", "ab", "aba"}，后缀为{"d", "ad", "bad"}



串和线性表的关系：

- 串是一种特殊的线性表，数据元素之间呈线性关系。

- 串的数据元素限定为字符（如中英文字符，数字，标点字符等），而一般线性表中所存储的数据元素类型不限。

  > 串是内容受限的线性表

- 串的基本操作如增删改查等通常以子串为对象，而一般线性表的基本操作时针对其中某个单独元素的。

补：

- 串的长度是指串中所含字符的个数

- 长度为n的主串有 n-m+1 个长度为m的子串
- 空串是任意串的子串，任意串是其自身的子串
- 长度为n的主串有  n(n+1)/2 + 1个子串，（长度为n的子串有1个，长度为n-1的子串有2个，依次类推是等差数列）
- 非平凡子串：即子串既不为空也不是本身，长度为n的串，有2+3+...+n = (n-1) (n-2) /2个

## 二、串的存储结构

### 2.1、顺序存储

类似线性表中的顺序存储，使用一组地址连续的存储单元存储串值的字符序列

定长顺序存储，使用静态数组

```c++
#define MAXLEN 255
typedef struct {
    char ch[MAXLEN];
    int length;
}SString;
```

堆分配存储

```c++
typedef struct {
    char *ch;
    int length;
}HString;
HString S;
S.ch = (char *)malloc (MAXLEN * sizeof(char));
S.length = 0;
```

串的顺序存储的优缺点和顺序表的类似。

顺序存储有不同的实现方案：

- 使用变量length记录当前串长，缺点：字符在串中的位序和在数组中的下标相差一

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171011324-2024-12-709:57:46.png" alt="image-20230209171011324" style="zoom:80%;" />

- ch[0]充当length，优点是字符的位序和数组下标相同，但由于一个字符为1B，所能表示的最大数字为255，能记录的范围有限

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171115033-2024-12-709:58:14.png" alt="image-20230209171115033" style="zoom:80%;" />

- 不设置length变量，以字符'\0'表示结尾，缺点：想知道当前串长需要从头遍历。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171152346-2024-12-709:58:42.png" alt="image-20230209171152346" style="zoom:80%;" />

- 舍弃ch[0]不用，让字符位序和数组下标保持一致，同时设置length变量记录串长。<推荐>

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171240955-2024-12-709:59:03.png" alt="image-20230209171240955" style="zoom:80%;" />

### 2.2、串的链式存储

类似于线性表的链式存储结构，其中每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构

## 三、串的基本操作

串赋值 StrAssign、串比较 StrCompare、 求串长 StrLength、串连接 Concat 及求子串SubString，这五种操作构成串类型的最小操作集，其他串操作均可在该最小操作集上实现。

```c++
//清空子串,S.length = 0;
ClearString(&S); 

//求子串，用sub返回S的第pos个字符起长度为len的子串
bool SubString(SString &sub, SString s, int pos, int len) {
    if (pos + len - 1 > s.length) return false; //子串范围越界
    for (int i = pos; i < pos + len; i++)
        sub[i - pos + 1] = s[i];
    sub.length = len;
    retrun true;
}

//串比较。S>T,返回值>0;S<T,返回值<0;S=T,返回值=0;
int StrCompare(SString S, SString T) {
    for (int i = 1; i <= S.length && i < T.length; i++) 
        if (S[i] != T[i])
            return S[i] - T[i];
    return S.length - T.length;
}

//子串定位，若串S中存在与串T值相同的子串，返回该子串在串S中第一次出现的位置。
//结合取子串和串比较，每次从S中取出和T长度相同的子串，和T比较
int index(SString S, SString T) {
    int i = 1, n = S.length, m = T.length;
    SString Sub;
    while (i < n - m + 1) {
        SubString(sub,S,i,m);
        if (StrCompare(sub, T) != 0)
            i++;
        else 
            retrun i;      
    }
    retrun 0; //不存在该子串
}
```

## 四、串的模式匹配

一些概念

- 主串
- 子串,  <一定是主串中存在的才叫子串>
- 模式串, <想尝试在主串中找的串，未必存在>

**串的模式匹配：在主串中找到与模式串相同的子串，并返回位置。即子串的定位操作。**

### 4.1、朴素模式匹配算法

思想：依次从主串中找出一个和模式串长度相同的子串，对所取子串和模式串中的元素依次比较，直到找到一个完全匹配的子串，或所有子串都不匹配为止。

算法分析：若模式串长度为m，主串长度为n。

- 匹配成功的最好时间复杂度：*O*(m)，主串的第一个长度为m的子串就和模式串完全匹配。

- 匹配失败的最好情况：每个子串的第一个字符不匹配，其时间复杂度为 *O*(n-m+1)≈*O*(n)

  > 长度为m的子串有n-m+1个，故时间复杂度为*O*(n-m+1)

- 最坏时间复杂度：*O*(mn)
  - 最坏情况是，对主串的n-m+1个长度为m的子串，每次对比时前m-1个字符都匹配，但第m个字符不匹配，其中共对比 m* (n-m+1)次，时间复杂度为 *O*(mn)
  - 此时主串指针每次都要发生回溯

### 4.2、KMP算法

   由于朴素模式匹配算法在某些子串和模式串只能部分匹配时，主串的扫描指针i经常发生回溯，导致时间开销增加，其最坏时间复杂度为*O*(mn)。

​	KMP算法要利用之前部分成功匹配的信息（动态规划的思想），**当子串和模式串不能匹配时，主串的扫描指针不回溯，只移动模式串的扫描指针j到一个"合适的位置"后，再次开始比较**，其中模式串指针应跳到的位置保存在**next数组**中，算法平均时间复杂度为*O*(m+n)，其中计算next数组为O(m)，匹配需要O(n)。

***

首先介绍”**前缀表**“的概念，前缀表是 KMP 算法的核心数据结构，**<u>用于记录下标j（包括j）之前的字符串最长相等前后缀的长度</u>**。前缀表是用来回退的，它记录了模式串与主串不匹配的时候，模式串应该从哪里开始重新匹配的信息。

对于模式串 `pattern`，前缀表 `prefix[i]` 表示子串 `pattern[0:i]` 的最长相等前后缀的长度。以模式串 "ababc" 为例，它的前缀表为 [0, 0, 1, 2, 0]。单个字符"a"它没有前缀也没有后缀，所以对应的值为0，因此前缀表的第一个值总是为0。

next 数组是一个前缀表，或者说是前缀表的某种变形。两种常见的next数组定义方式：

- **直接使用前缀表**

  直接将前缀表作为 next 数组使用

  next[j] 表示子串 pattern[0:j] 的最长相等前后缀长度（包括j）。

  当匹配失败时，回退到 next[j-1]。

- **前缀表右移一位**

  将前缀表整体右移一位，并在开头添加 -1，形成 next 数组。

  next[0] = -1, next[j]表示子串 pattern[0:j-1] 的最长相等前后缀长度（不包括j）

  当匹配失败时，直接回退到 next[j]

两种方式的区别主要在于**索引含义**和**回退操作**，但它们在算法逻辑上是等价的。严蔚敏教材中采用的是第二种next数组构建方式，后面采用第二种next数组。

{%note info%}

第二种next数组中没有保存整个模式串的最长相等前后缀长度，而一些问题中可能需要用到。此时可以多申请一个空间，将其保存在next[n]中。(<span style="color:red">重要</span>)

这个next[n]在kmp搜索过程中用不到，后面使用nextval数组优化时也不用管，不影响kmp算法的运行。

{%endnote%}

***

next数组原理分析：例如，在主串"aabaabaafa"中查找是否出现过模式串"aabaaf"，模式串的前缀表是[0,1,0,1,2,0]，对应的next数组是[-1,0,1,0,1,2,0]。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250904222758526-2025-9-422:28:03.png" style="zoom:80%;" />

当主串i位置的字符与模式串j位置的字符匹配失败时，此时应在模式串中，找前面子串[0:j-1]（即aabaa）的最长相等前后缀。有什么作用呢？**当前匹配失败的位置是后缀的后一个字符，只需找到与其相同的前缀，从它的下一个字符重新进行匹配即可。**在该例中，由next[j] = 2知，"aabaa"最长相等前后缀长度是2。由于字符串是从索引0位置开始的，对应前缀的下一个位置就是next[j]。因此匹配失败时模式串指针j回退到next[j]继续比较，而不用回溯主串的指针。（直接使用前缀表作为next数组时，前面子串[0:j-1]（即aabaa）的最长相等前后缀长度保存在next[j-1]处，所以要回退到next[j-1]）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250904222944666-2025-9-422:29:45.png" style="zoom:80%;" />

当next[j]位置的字符还不匹配时，就回退到next[next[j]]，就这样一直回退下去直至找到与主串i位置匹配的字符或者到达模式串第一个字符重新开始匹配。



注意，此处的字符串是从下标0开始存储的，符合大多数编程语言的习惯。而严蔚敏教材中采用之前定义的SString存储字符串，是从下标1开始存储的，因此匹配失败时要跳转的位置就变成了next[j]+1。对应的next数组手算方法：当模式串中第j个字符匹配失败时，假设由模式串前j-1个字符组成的串为S，则 **next[j] = S的最长相等前后缀 + 1**

KMP算法只有子串和模式串有很多部分成功匹配时才显得比朴素模式匹配算法快。

### 4.3、KMP算法优化：nextval数组

优化：当子串和模式串不匹配时，j = nextval[j]。

若模式串第j个位置的字符和子串匹配失败时，根据KMP算法，让j = next[j] 继续比较。但当next[j]位置所指的字符和第j个位置的字符相同，那么比较必然失败，这次比较就没有意义。

求nextval数组：

- 求next数组
- nextval[1] = 0,从左向右依次求：
  - 若next[j]位置的字符和当前字符相同，则nextval数组对应的值也相同，即 nextval[j]  = nextval[ next[j] ]
  - 若next[j]位置的字符和当前字符不同，则保持不变，即 nextval[j] = next[j]

```java
public int[] computeNextval(String pattern) {
    int n = pattern.length();
    if (n == 0) return new int[0];

    int[] next = computeNext(pattern); //计算next数组
    int[] nextval = new int[n];
    nextval[0] = -1;

    for (int i = 1; i < n; i++) {
        if (pattern.charAt(i) == pattern.charAt(next[i])) {
            // 如果回退后的字符与当前字符相同，则进一步回退
            nextval[i] = nextval[next[i]];
        } else {
            // 否则使用标准的next值
            nextval[i] = next[i];
        }
    }

    return nextval;
}
```

***

Nextval 数组优化在以下情况下特别有效：

1. 模式串中有大量重复字符
2. 模式串中有周期性模式
3. 主串与模式串的匹配失败频繁发生

在最坏情况下，Nextval 优化的 KMP 算法与标准 KMP 算法的时间复杂度相同，都是 O(n+m)。但在实际应用中，尤其是对于具有特定模式的情况，Nextval 优化可以显著减少比较次数，提高搜索速度。

### 4.4、KMP算法实现

使用双指针构建next数组：

- i指向当前子串的最后一个字符
- j指向前缀的最后一个字符，同时j+1也表示当前最大相等前后缀长度

初始化： j = -1, next[0] = j, i = 0。

实际上，在构建这个next数组的过程中，我们并没有先构建一个完整的前缀表然后进行右移操作，而是通过调整索引的赋值方式直接得到右移后的数组。右移的操作是通过**先递增索引再赋值**来实现的，当`pattern[i] == patter[j]`时，j++得到子串patter[0:i]的最长相等前后缀长度，再`next[++i] = j`，将它保存在next数组的下一位置，就实现了右移。 

在kmp算法中，主串的遍历指针i不回溯。当字符匹配时，主串指针i和模式串指针j一起向后移动，比较下一位置；当模式串在位置j处与主串不匹配时，回退模式串指针到next[j]处继续比较。若在此过程中j移动到了模式串末尾，说明匹配成功，返回第一次匹配的位置。完整实现如下：

```java
/**
* 构建KMP算法的next数组（第二种方式：前缀表右移一位，开头填充-1）
* @param pattern 模式串
* @return next数组
*/
public int[] computeNext(String pattern) {
    int n = pattern.length();
    if (n == 0) return new int[0];

    //多申请一个空间，用next[n]保存整个模式串的最长相等前后缀长度
    int[] next = new int[n + 1];
    next[0] = -1; // 第一个位置固定为-1

    int j = -1; // 指向前缀的末尾位置
    int i = 0;  // 指向后缀的末尾位置

    //先递增索引i再赋值，故i的范围为[0,n-1]
    while (i < n) {
        // j == -1 表示需要从头开始匹配
        // pattern.charAt(i) == pattern.charAt(j) 表示匹配成功
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
            //先递增索引i再赋值，实现右移
            //next[i]保存着子串pattern[0:i-1]的最长相等前后缀长度
            next[i] = j; 
        } else {
            // 匹配失败，回溯到前一个可能匹配的位置，直到两字符匹配或到达初始条件为止
            j = next[j];
        }
    }

    return next;
}



/**
* 使用构建的next数组进行KMP匹配，返回第一次匹配到的位置
* @param text 文本串
* @param pattern 模式串
* @return 匹配的起始位置，未找到返回-1
*/
public int kmpSearch(String text, String pattern) {
    if (pattern.isEmpty()) return 0;

    int[] next = computeNext(pattern);
    int i = 0; // 文本串指针
    int j = 0; // 模式串指针
    int n = text.length();
    int m = pattern.length();

    while (i < n && j < m) {
        // j == -1 表示模式串需要从头开始匹配
        if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
        } else {
            // 不匹配时，根据next数组回溯模式串指针
            j = next[j];
        }
    }

    // 如果模式串指针走到末尾，说明匹配成功
    if (j == m) {
        return i - j;
    }

    return -1;
}
```



当我们寻找所有匹配位置时，有两种情况：重叠匹配和不重叠匹配。

- 重叠匹配：当模式串匹配成功后，模式串的指针会根据`next`数组的值滑动到特定位置继续匹配，匹配结果之间存在重叠部分。
- 不重叠匹配：当模式串匹配成功后，模式串的指针重置为0重新开始匹配。这种方式确保每次匹配结果之间无重叠‌。

例如，对于主串“AAAA”，模式串“AA”，重叠匹配的结果是[0, 1, 2]，不重叠匹配的结果是[0, 2]。

关键区别在于匹配成功后的指针处理逻辑：不重叠匹配强制重置模式串指针，而重叠匹配利用`next`数组优化滑动距离‌。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250905105135577-2025-9-510:52:08.png" style="zoom:80%;" />

```java
/**
* 构建KMP算法的next数组（第二种方式：前缀表右移一位，开头填充-1）
* @param pattern 模式串
* @return next数组
*/
public int[] computeNext(String pattern) {...} //同上

/**
* 使用构建的next数组进行KMP匹配，返回模式串出现的所有位置
* @param text 文本串
* @param pattern 模式串
* @return 匹配的所有位置，未找到返回空列表
*/
public  List<Integer> kmpFindAll(String text, String pattern) {
    List<Integer> positions = new ArrayList<>();
	
    //处理模式串为空的情况，按理说空串应该是任何字符串的子串，应该返回所有位置，但这通常这不是有意义的操作
    //有的题目中规定空串在模式串中没有出现，具体看题目要求
    if (pattern.isEmpty()) {
        //for (int i = 0; i <= text.length(); i++) {
        //    positions.add(i);
        //}
        return positions;
    }


    int[] next = computeNext(pattern);

    // 使用扩展的next数组进行匹配
    int i = 0; // 文本串指针
    int j = 0; // 模式串指针
    int n = pattern.length();
    while (i < text.length()) {
        if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;

            if (j == n) {
                positions.add(i - j);
                j = next[j]; // 重叠匹配，跳转到当前整个模式串的最长前缀的下一个字符串重新匹配
                //j = 0; //不重叠匹配，从模式串首部开始重新匹配
            }
        } else {
            j = next[j];
        }
    }
    return positions;
}
```



将前缀表右移一位后作为next数组能够带来很大方便：

- 不需要单独处理第一个字符不匹配的情况。如果直接使用前缀表作为next数组，在发生不匹配时，需要回退到next[j-1]，当j=0（即第一个字符就不匹配）的情况需要单独处理，否则i-1 会索引越界。这增加了一个if 判断分支（具体见另一种方式的实现）
- **统一回退操作**：无论何时发生不匹配，都使用 `j = next[j]` 这一条语句

***

补充：直接使用前缀表作为next数组，字符串索引从0开始。

```java
public  int[] computeNext(String pattern) {
    int n = pattern.length();
    if (n == 0) return new int[0];

    int[] next = new int[n];
    next[0] = 0;
    int i = 1, j = 0;
	
    //先赋值再递增索引，i的范围是[0,n-1]
    while(i < n) {
        if (pattern.charAt(i) == pattern.charAt(j)){
            j++;
            //先赋值再递增索引，直接使用前缀表作为next数组
            //next[i]保存着子串pattern[0:i]的最长相等前后缀长度
            next[i] = j;
            i++;
        } else {
            //额外的判断：已经到达第一个字符，没有相等前后缀了，子串[0,i]的最长相等前后缀字符串长度就是0
            if (j == 0) { 
                next[i] = j;
                i++;//继续计算下一位置
            } else {
                j = next[j - 1]; //回退
            }
        }
    }
    return next;
}

public  int kmpSearch(String text, String pattern) {
    if (needle.isEmpty())
        return 0;

    int[] next = computeNext(needle);
    int i = 0; // 文本串指针
    int j = 0; // 模式串指针
    int n = haystack.length();
    int m = needle.length();

    while (i < n && j < m) {
        if (haystack.charAt(i) == needle.charAt(j)) {
            i++;
            j++;
        } else {
            //额外的判断：模式串的第一个字符就不匹配，那么直接移动主串指针即可
            if (j == 0) {  
                i++;
            }else{
                j = next[j - 1]; //回退指针
            }
        }
    }

    if (j == m) {
        return i - j;
    }
    return -1;
}
```



### 4.5、KMP算法的应用

KMP的应用远不止于简单的字符串匹配，其核心思想——利用`next`数组避免重复比较——可以解决一系列与字符串周期、重复性相关的问题。

1. **精确字符串匹配**
   - **场景描述**：这是KMP最直接的应用。在一个主文本（如文档、数据库、基因组序列）中快速查找一个模式（关键词、特定序列）的所有出现位置。
   - **特点**：主串和模式串都可能非常长，需要高效的算法。KMP保证了最坏情况下的线性时间复杂度。
2. **字符串周期性问题 / 重复子串判断**
   - **场景描述**：判断一个字符串是否可以由它的一个子串重复多次构成。例如，`"ababab"` 可以由 `"ab"` 重复3次构成。
   - **实现原理**：计算字符串`s`的`next`数组（通常是长度为`n+1`的数组）。如果 `n % (n - next[n]) == 0` 且 `next[n] > 0`，那么这个字符串就是周期性的，其最小重复单元的长度是 `n - next[n]`。
   - **举例**：`s = "ababab", n=6, next[6]=4`。`6 % (6-4) = 6 % 2 = 0`，成立。最小周期长度是2，即`"ab"`。
3. **求字符串的最长前后缀**
   - **场景描述**：这本身就是`next`数组的定义。`next[i]`表示子串`s[0:i]`的最长的、相等的前缀和后缀的长度。
   - **应用**：这是解决许多高级字符串问题的基础构件。
4. **单模式匹配的变种问题**
   - **场景描述**：一些问题虽然不是直接问匹配位置，但其核心需要用到KMP的匹配思想或`next`数组的计算过程。例如，在匹配过程中增加一些通配符规则，或者需要基于匹配过程进行动态规划等。



### 4.6、补充：RK算法

Rabin-Karp 算法是一种基于哈希的字符串搜索算法，由 Richard M. Karp 和 Michael O. Rabin 于 1987 年提出。该算法使用哈希技术来快速比较模式串和文本中的子串，从而在平均情况下实现高效的字符串匹配。

核心思想：RK算法维护一个与模式串大小相同的滑动窗口，每次向后滑动一个字符获得下一个可能匹配的子串。计算并比较模式串与滑动窗口中子串的哈希值：哈希值不同，则两者一定不匹配；由于哈希冲突的存在，不同的字符串可能得到相同的哈希值，故只有哈希值相等时才进行实际的字符比较。

RK 算法的关键在于使用合适的哈希函数，为了高效地计算滑动窗口的哈希值，通常使用多项式滚动哈希。

多项式滚动哈希将字符串视为一个多项式，其中每个字符是多项式的系数。对于一个字符串s，其哈希值计算为：

$$Hash(s) = (s[0] * r^{m-1} + s[1]*r^{m-2}+...+s[m-1]*r^0) \bmod p$$

其中：

- m是模式串长度。

- r 是基数，r 的选择通常基于字符集的大小。扩展 ASCII 有 256 个字符，因此可选择 256 作为基数，这样可以确保每个字符都能被唯一表示。
- p 是模数，通常取大素数以避免哈希碰撞。整个多项式的和可能非常大，无法用现有的数据类型存储，通过取模运算来避免溢出，这也带来了哈希冲突的可能。

多项式滚动哈希的真正威力在于其"滚动"特性。当窗口滑动时，不需要重新计算整个窗口的哈希值，通过对旧哈希值的简单数学运算就可以得到新的哈希值：将最左侧字符哈希值减去再加上新加入字符的哈希值即可。
$$newHash = ( (oldHash - s[i]* r^{m-1} ) * r + s[i+m] ) \bmod p$$

为了进一步减少哈希冲突，可以使用双重哈希技术，即使用两个不同的 BASE 和 MOD 对，只有当两个哈希值都匹配时，才进行详细的字符比较。

***

算法实现步骤：

1. 预处理：
   - 计算模式串的哈希值
   - 计算第一个文本子串的哈希值
2. 匹配过程：
   - 比较模式串哈希值和当前文本子串哈希值
   - 如果哈希值匹配，进行详细的字符比较
   - 使用滚动哈希计算下一个文本子串的哈希值
   - 重复直到文本结束

```java
public class RabinKarp {

    // 基数和模数，用于哈希计算
    private static final int BASE = 256;
    private static final int MOD = 101;

    /**
     * Rabin-Karp 算法实现
     * @param text 文本串
     * @param pattern 模式串
     * @return 所有匹配的起始位置列表
     */
    public static List<Integer> search(String text, String pattern) {
        List<Integer> matches = new ArrayList<>();

        int n = text.length();
        int m = pattern.length();
        if (n < m) return matches;

        // 计算 BASE^(m-1) mod MOD
        int h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }

        // 计算模式串和第一个文本窗口的哈希值
        int patternHash = 0;
        int textHash = 0;
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash * BASE + pattern.charAt(i)) % MOD;
            textHash = (textHash * BASE + text.charAt(i)) % MOD;
        }

        // 滑动窗口
        for (int i = 0; i <= n - m; i++) {
            // 检查哈希值是否匹配
            if (patternHash == textHash) {
                // 哈希值匹配，检查实际字符是否匹配
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    matches.add(i);
                }
            }

            // 计算下一个窗口的哈希值
            if (i < n - m) {
                textHash = (BASE * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;

                // 确保哈希值为正数
                //textHash经过取余已经是一个小于等于MOD的数了，做减法后可能为负数。
                if (textHash < 0) {
                    textHash += MOD;
                }
            }
        }

        return matches;
    }

    /**
     * 处理多个模式串的 Rabin-Karp 算法
     * @param text 文本串
     * @param patterns 模式串数组
     * @return 每个模式串的匹配位置映射
     */
    public static java.util.Map<String, List<Integer>> searchMultiple(String text, String[] patterns) {
        java.util.Map<String, List<Integer>> results = new java.util.HashMap<>();

        for (String pattern : patterns) {
            results.put(pattern, search(text, pattern));
        }

        return results;
    }
}
```



时间复杂度分析：计算模式串和第一个滑动窗口中子串的哈希值花费时间为O(m)；滑动窗口的移动次数为n - m + 1（ n 是文本长度），比较和更新哈希值时间复杂度都是O(1)，因此匹配阶段基础时间复杂度是O(n)；

当哈希值匹配时，需要进行实际的字符比较来验证是否真正匹配：

- **最佳情况**：没有哈希冲突，不需要实际比较或很少比较
- **最坏情况**：每次哈希比较都冲突，需要完整的字符比较

因此：

- 最佳情况时间复杂度为O(n + m)。没有哈希冲突或很少冲突，只需要进行哈希比较，不需要或很少需要实际字符比较。当模数 q 选择得当时，这种情况在实际应用中很常见。
- 最坏情况时间复杂度为O(n × m)。所有子串都与模式串发生哈希冲突每次都需要进行完整的字符比较 ，总共需要进行 (n - m + 1) 次比较。
- 平均情况时间复杂度为O(n + m)

## 五、广义表

### 5.1、定义

广义表是线性表的推广，一般记作$LS = (a_1,a_2\;...\;a_n), n\geq 0$。$LS$是广义表$(a_1,a_2\;...\;a_n)$的名称，n是其长度。

$a_i$可以是单元素（<u>原子</u>），也可以是广义表（<u>子表</u>），广义表的定义是递归的。





任何非空广义表$LS = (a_1,a_2\;...\;a_n)$均可分解为**表头**和**表尾**两部分：

- 表头(Head)：第一个元素，$Head(LS) = a_1$。
- 表尾(Tail)：出第一个元素外，<u>其余元素构成的表</u>，$Tail(LS) = (a_2,a_3\;...\;a_n)$。

例如：

- $D=(E,F) = (a,(b,c),F)$，$Head(D) = E$，$Head(E) = a$，$Tail(E) = ((b, c))$
- $Head((b,c)) = b$，$Tail((b,c)) = (c)$
- $Head(((b,c))) = (b,c)$，$Tail(((b,c))) = ()$
- $C = (a,(b,c,d))$，$Head(C) = a$，$Tail(C) = ((b,c,d))$

### 5.2、特点

1. 广义表中元素有相对次序。
2. 广义表的**长度**定义为表中元素的个数。
3. 广义表的**深度**定义为表的嵌套层数。
4. 广义表可以改共享，即一个广义表可以作为其他表的子表。
5. 广义表是一个递归的表。

> 注：
>
> 1. 原子的深度为0，空表的深度为1。
> 2. 递归表的长度是有限值，深度是无穷值。

例如：

- $A=()$，A是一个空表，长度为0，深度为1
- $B=(e)$，B只有一个原子，长度为1，深度为1
- $C=(a,(b,c,d))$，C有一个原子和一个子表，长度为2，深度为2
- $D=(A,B,C)$，D有三个子表，长度为3，深度为3
- $E=(a,E)$，E是一个递归的表，长度为2，深度为无穷大

### 5.3、广义表的存储结构

通常采用链式存储结构，常用的有两种：头尾链表的存储结构 和 扩展线性链表的存储结构。

- 头尾链表的存储结构

  表结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207114745445-2024-12-711:47:46.png" alt="image-20241207114745445" style="zoom: 67%;" />
  - hp所指的或为表结点，或为原子结点
  - 除非表尾为空，则tp指针为空，<u>否则必指向表节点</u>

  原子结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207115109332-2024-12-711:51:10.png" alt="image-20241207115109332" style="zoom: 67%;" />

  例如：

  - $C=(a,(b,c,d))$

    <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120403971-2024-12-712:04:05.png" alt="image-20241207120403971" style="zoom:67%;" />

  - $E=(a,E)$

    <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120731172-2024-12-712:07:32.png" alt="image-20241207120731172" style="zoom:67%;" />

  - $B=(e)$

    <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120909735-2024-12-712:09:10.png" alt="image-20241207120909735" style="zoom:67%;" />

  

- 扩展线性表的存储结构

  无论是表结点还是原子结点均由三个域构成

  表结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121209271-2024-12-712:12:10.png" alt="image-20241207121209271" style="zoom:67%;" />

  原子结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121236230-2024-12-712:12:37.png" alt="image-20241207121236230" style="zoom:67%;" />

例如：$C=(a,(b,c,d))$

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121652380-2024-12-712:16:53.png" alt="image-20241207121652380" style="zoom:67%;" />