---
title: 一、绪论
tags:
  - 数据结构
  - 算法基本概念
  - 时间复杂度
  - 空间复杂度
categories:
  - 数据结构
math: true
abbrlink: bfab103e
date: 2024-12-06 09:58:54
index_img: https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/article-bg.jpg
---

<!--请求图片资源时，隐藏自己的来源信息，防止出现403错误导致图床图片不显示-->

<meta name="referrer" content="no-referrer" />

## 一、数据结构的基本概念

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902165335043-2024-12-610:07:40.png" alt="image-20220902165335043" style="zoom:80%;" />

### 1.1、基本概念

用数据库中的相关概念来理解，数据相当于一个数据库，数据对象相当于一个表，数据元素相当于表中的一条记录，数据项相当于一条记录的诸多属性。

- 数据

  画家，用画笔来描述世界；音乐家，用音符来描述世界；计算机专业人员，用**数据**来描述世界。

  数据是**信息的载体**，是描述客观事物属性的数、字符及所有能输入到计算机中并**被计算机程序识别和处理**的符号的集合。数据是计算机程序加工的原料。

- 数据元素  数据项

  数据元素：是数据的<u>**基本单位**</u>，通常作为一个整体来考虑和处理。

  数据项：一个数据元素可由若干个数据项组成，数据项是构成数据元素**不可分割的最小单位**

- 数据对象  数据结构  （都是描述**数据元素之间**的关系）

  数据对象：是**具有相同性质**的数据元素的集合，是数据的一个子集。（强调数据元素具有相同性质）

  数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。（强调数据元素之间有什么关系---> 数据结构三要素）。不同的数据元素可以组成相同的数据结构，相同的数据元素也可以组成不同的数据结构。

- 数据类型  抽象数据类型

  数据类型：是一个值的集合和定义在此集合上的一组操作的总称。如：bool类型，其值的集合为 true和false，可以进行的操作有与、或、非......

  - 原子类型：其值不可再分的数据类型。如int、bool等。
  - 结构类型：其值可以在分解成若干成分的数据类型。如struct类型。

  抽象数据类型：ADT，描述了数据的逻辑结构和抽象运算，通常用 **< 数据对象，数据关系，基本操作集 >**这样的三元组来表示，从而构成了一个完整的数据结构定义。只用数学化的语言定义数据的<u>逻辑结构和运算</u>，与具体的实现无关，只有当用实际的计算机实现时，才考虑其存储结构，如栈、队列。

**讨论一种数据结构时，先定义其抽象数据类型，即先定义逻辑结构和运算，最后决定用什么存储结构来实现。**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902172218218-2024-12-610:13:11.png" alt="image-20220902172218218" style="zoom:80%;" />



### 1.2、数据结构三要素

- **逻辑结构**：数据元素之间的逻辑关系是什么

  - 集合：各元素同属一个集合，别无其他关系
  - 线性结构：一对一的关系
  - 树状结构：一对多的关系
  - 图状结构：多对多的关系

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902172832557-2024-12-610:14:26.png" alt="image-20220902172832557" style="zoom:80%;" />

  > 补充：
  >
  > 1. 数组：是线性表的推广，它的数据元素是一个线性表，每个数据元素结构相同
  >
  >    广义表：是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素或者线性表。
  >
  >    严格来讲，数组（二维）和广义表不属于线性结构
  >
  > 2. 栈和队列是操作受限的线性表，而串是内容受限的线性表

- **存储结构**：如何用计算机表示数据元素之间的逻辑关系

  - 顺序存储：把逻辑结构上相邻的元素存储在物理位置也相邻的存储单元中。
  - 链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助**指针**表示其逻辑关系
  - 索引存储：需要建立附加的索引表
  - 散列存储：根据元素的关键字直接计算出该元素的存储地址

- **数据的运算**

  施加在数据上的运算包括**运算的定义和实现**。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。



> 注：
>
> 1、数据的逻辑结构独立与其存储结构，而数据的存储结构是逻辑结构在计算机中的映射，不能独立于逻辑结构而存在。
>
> 2、存储数据时，不仅要存储各数据元素的值，而且要存储他们之间的关系。
>
> 3、两个不同的数据结构，他们的逻辑结构和存储结构有可能完全相同，数据运算也是数据结构的一个重要方面。如：二叉树和二叉排序树，链栈和链队列。
>
> 4、堆是数据元素的序列，存储在一维数组中，可以看成**线性结构**
>
> 5、**多型数据类型**，栈、队列、树、图都是多型数据类型，其数据元素既可以是‘单型’（原子类型，如整数，布尔类型等），也可以是结构类型。
>
> 6、有序表是指关键字有序的线性表，仅描述数据间的逻辑关系，它可以链式存储也可以顺序存储，故属于逻辑结构。
>
> 7、算法代表对问题求解步骤的描述，而程序则是算法在计算机上的特定实现。程序不一定满足有穷性，如死循环。
>
> 8、数据结构的形式定义为一个二元组，Data-Struct =  <D, R>，其中D是数据元素的有限集，R是D上关系的有限集；
>
> ​      数据类型表示为 ： Data-Type = <D, R, P>； 抽象数据类型表示为  ADT = <D, R, P>。其中D和R同上，P为定义的一组操作。

## 二、算法和算法的评价

### 2.1、算法

**算法（Algorithm）是对特定问题求解步骤的一般描述**，它是指令的有限序列，其中的每条指令表示一个或多个操作。

**程序  = 数据结构 + 算法**，其中数据结构是要处理的信息，算法是处理信息的步骤。

### 2.2、算法的五个特性 

不满足以上五个特性就不能称为算法。

- 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
- 确定性：算法中的每条指令必须有明确的含义，对于相同的输入只能得到相同的输出
- 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次数来实现
- 输入：一个算法有零个或多个输入
- 输出：一个算法有一个或多个输出 （必须要有输出）

### 2.3、好的算法的特质 

算法的设计目标，从这几方面评价一个算法

- 正确性
- 可读性
- 健壮性
- 高效率：算法的执行时间（用**时间复杂度**来刻画）
- 低存储量：算法执行过程中所需要的最大存储空间（用**空间复杂度**来刻画）正确性可读性健壮性高效率：算法的执行时间（用**时间复杂度**来刻画）低存储量：算法执行过程中所需要的最大存储空间（用**空间复杂度**来刻画）

### 2.4、时间复杂度

一个语句的频度是指该语句在算法中被执行的次数，算法中所有语句的频度之和记为 *T(n)*,它是该算法**问题规模n**的函数，**时间复杂度主要分析*T(n)*的数量级**。采用**事前分析估计的方法**分析时间开销 T(n)与问题规模n的关系。

​	算法中基本运算（最深层循环内部的语句）的频度 *f(n)*和 *T(n)* 同数量级，因此通常采用算法中基本运算的频度来分析算法时间复杂度，记为 *T(n) = O ( f(n) )*，其中 O 表示同数量级，其严格的数学定义为：T(n)和f(n)为定义在正整数集合上的两个函数，则存在正常数C和n0，使得n>n0时，都满足   **0 < T(n) <= C f(n)**。

​	**算法的时间复杂度不仅依赖于问题的规模n，也取决于输入数据的性质**，  如在一个一维数组中查找给定值k。因此，有**最好时间复杂度**，**最坏时间复杂度**，**平均时间复杂度**（所有可能输入等概率出现的情况下，算法的期望运行时间）。

在分析一个算法时间复杂度时，频度f(n)中可能含有多项相加或相乘，有加法和乘法规则：

​		加法规则：多项相加只保留最高阶的项，且系数变为1

​		乘法规则：多项相乘结果为最终保留

> 注：1、顺序执行的代码只会影响常数项，可以忽略
>
> ​	  2、只挑最深层循环中的一个基本语句分析它的执行次数与问题规模n的关系即可
>
> ​	  3、 如果有多层循环，只需关注最深层循环中基本语句的执行次数

### 2.5、空间复杂度

算法的空间复杂度 *S(n)* 定义为该算法所耗费的存储空间，它是问题规模n的函数， 记为  *S(n) = O( g(n) )*

- 只需关注问题规模**n相关的变量**所耗费的存储空间
- 函数递归调用带来的内存开销，其空间复杂度 = 递归调用的深度。有的算法各层调用时所需存储空间与n有关，所以不同。
- 算法原地工作是指算法所需的**辅助空间为常量**，即*O(1)*



### 2.6、注意点

1、算法优于算法，是一个宏观上的问题，比如飞机比火车快，程序执行时间的特例不构成反例。故在相同规模n下，时间复杂度为 O(n)的算法在时间上总是优于时间复杂度为O(2^n)的算法。时间复杂度为$O(1)$的算法是效率最高的算法。

2、对于多层循环嵌套的代码，其时间复杂度主要考察最深层代码频度的数量级。

- 内层和外层没有联系

  ```c++
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
          x++;
      }
  }
  ```

  执行次数 = 外层循环次数 * 内层循环次数  = n * m

- 内层和外层有联系

  ```c++
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= 2*i; j++) {
          x++;
      }
  }
  ```

  执行次数计算方法：从内存向外层加和 ,即 
  
  $$ \sum_{i=1}^n \sum_{j=1}^{2i} 1=  \sum_{i=1}^n 2i=  2 * \frac{n(n+1)}{2} =  n(n+1)$$

- 对于递归函数的时间复杂度

  分析每次递归调用是参数的变化规律，是每次规模减一（n-1），还是规模减半（$\frac{n}{2}$）等，再寻找递归出口所规定的规模，得出递归的次数。通常时间复杂度度与地柜的调用次数相关。
  ​

  一个算法所需时间由下述递归方程表示，求该算法的时间复杂度
$$
T(n) = \begin{cases} \ 1,n=1\\ \ 2T(\frac{n}{2})+n, n>1\end{cases}
$$
​		解：$T(n) = 2T(\frac{n}{2})+n = 2(2T(\frac{n}{4})+\frac{n}{2})+n = 4T(\frac{n}{4})+2n$

​					 	 $$= 2^k T(\frac{n}{2^k})+ k n$$

​				$$当  \frac{n}{2^k} = 1时为止，所以   = \log_2n,将k代入T(n)可得$$

​				$$T(n)=n*T(1) +n * \log_2n = n + n\log_2n$$

​				故：该递归函数的时间复杂的为 $O(n\log_2n)$

