---
title: 七、查找
categories:
  - 数据结构
abbrlink: 24d4ba7c
date: 2024-12-08 11:10:57
math: true
tags:
  - 查找
  - 二分查找
  - 分块查找
  - 二叉排序树
  - 平衡二叉树
  - 红黑树
  - B树
  - 散列表
---

<meta name="referrer" content="no-referrer" />



<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316184247777-2024-12-811:15:42.png" alt="image-20230316184247777" style="zoom: 60%;" />

## 一、查找的基本概念

**查找表**：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。

- 静态查找表：只进行查找操作，无须动态地修改的查找表称为静态查找表。
  - 适合静态查找表的查找方法：顺序查找、折半查找、散列查找等
- 动态查找表：不仅要进行查找，还需要动态地插入或删除的查找表称为动态查找表。
  - 特点：表结构本身是在查找过程中动态生成的，即对于给定的key，若表中存在关键字等于key的记录，则查找成功；否则插入关键字为key的记录。
  - 数个动态查找表的查找方法：二叉排序树的查找、散列查找、<u>二叉平衡树、B树、B+树</u>（其都是二叉排序树的改进）等。

**关键字**：**唯一标识**数据元素的数据项。



查找算法的效率评价：

​	**平均查找长度是衡量查找算法效率最主要的指标，其数量级反映了算法的时间复杂度。**

​	平均查找长度 （**ASL**）：在查找过程中，一次查找长度是指需要比较的关键字次数，而平均查找长度是指所有查找过程中进行关键字的比较次数的平均值，记为 $ASL = \sum_{i=1}^{n} P_iC_i$。
- n是查找表的长度
- $P_i$是查找第$i$个元素的概率。一般认为每个数据元素的查找概率相等，即$P_i = \frac{1}{n}$ 
- $C_i$是找到第$i$个元素所要进行比较的次数。

通常考虑查找成功和查找失败两种情况下的ASL（$ASL_{成功}$和 $ASL_{失败}$）

## 二、线性结构查找方法

### 2.1、顺序查找

顺序查找又称线性查找，分为对一般的无序线性表的顺序查找和对关键字有序的顺序表的查找

**一般线性表的查找**

```c++
typedef struct { //查找表
    ElemType *elem; //元素存储空间基址
    int TableLen; //表的长度
}SSTable;

int search_Seq(SSTable ST, ElemType key) {
    ST.elem[0] = key; // 哨兵
    for (int i = ST.TableLen; ST.elem[i] != key; --i); //从后往前找
    return i; //若i = 0 表示查找失败
}
```

对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需要进行n-i+1次比较，当每个元素的查找概率相等时，$ASL_{成功}$ = $\frac{1+2+3+...+n}{n} =  \frac{n+1}{2}$, $ASL_{失败} = n+1$ 。其时间复杂度为$O(n)$



**有序表的顺序查找**

若查找表中的关键字是有序的，则查找失败时可以不用再比较到表的另一端，就能返回查找失败的信息，从而**降低查找失败时的平均查找长度$ASL_{失败}$**，$ASL_{成功}$和查找表无序时相同。

如在查找表 (10,20,30,40)中查找25，该**查找判定树**如下：

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-16_21-18-09-2024-12-811:16:15.png" alt="Snipaste_2023-03-16_21-18-09" style="zoom: 45%;" />

由判定树可得： $ASL_{失败} = \frac{1+2+..+n+n}{n+1} = \frac{n}{2}+\frac{n}{n+1}$（西电课件上：$ASL_{失败}  = \frac{n}{2}+1$）



在一棵查找判定树中：

- n个元素，有 n+1种查找失败的情况（对应n+1个空链域）
- **一个成功结点的查找长度 = 自身所在的层数**  (在折半查找中也是一样)
- **一个失败结点的查找长度 = 其父节点所在的层数** (在折半查找中也是一样)

### 2.2、折半查找

折半查找仅适用于<u>**有序的顺序表**</u>。

思想：默认顺序表为升序

- 初始时，low = $0$, high = len-1，mid。
- 当 low <= high时,  mid = $\lfloor (low + high)/2\rfloor$
  - 若 elem[mid]  = key, 则已找到指定元素，返回key
  - 若 elem[mid] < key，则key在mid的右侧， **low = mid + 1**，继续查找
  - 若elem[mid] > key， 则key在mid的左侧，**high = mid -1**，继续查找
- 当 low > high 时，查找失败。

```c++
int Binary_Search(SeqList L, ElemType key) {
    int low = 0, high = L.TableLen - 1, mid;
    while (low <= high) {
        mid = （low + high) / 2;
        if (L.elem[mid] == key)
            return mid;
        else if (L.elem[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;  //查找失败返回-1
}
//递归形式
...
```

对在查找表(7,10,13,16,19,29,32,33,37,41,43)中查找值为 11和值为32的过程，可以用其判定树来描述。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316213850597-2024-12-811:19:51.png" alt="image-20230316213850597" style="zoom:80%;" />

对于11个成功的结点,当每个结点的查找概率相同，$ASL_{成功} = (1*1+2*2+3*4+4*4)/11 = 3$

对于12个查找失败的结点，假设每个结点的查找概率相同，$ASL_{失败} = (3*4+4*8)/12 = \frac{11}{3}$ 

该判定树只有最下层是不满的，高度和完全二叉树相同，故折半查找判定树的树高 $h = \lceil log_{2}{(n+1)}\rceil$（**不包含失败结点**），所以折半查找的时间复杂度为 $O(log_2n)$



折半查找的判定树

- 当 mid = $\lfloor (low + high)/2\rfloor$时

  - 若共有奇数个元素，mid分割后 左右子树元素个数相等
  - 若有偶数个元素，mid分割后右子树比比左子树多一个元素

  在该判定树中，若 mid = $\lfloor (low + high)/2\rfloor$，则对任何一个结点，必有：<u>右子树结点数- 左子树结点数 = $0$或$1$。</u>

- 当mid = $\lceil (low + high)/2\rceil$时，在折半查找的判定树中，对任何一个结点，必有：<u>左子树结点数 - 右子树结点数= $0$或$1$</u>

- 折半查找的判定树一定是**<u>平衡二叉树</u>**

- 在该判定树中，只有最后一层是不满的， 树高 h= $\lceil log_2{(n+1)}\rceil$或 $\lfloor log_2n\rfloor +  1$。

- 判定树中的关键字，左<中<右，满足<u>二叉排序树</u>的定义。

- 失败结点的个数为 $n+1$，即空链域的个数。



**构造查找判定树**（构造n个结点的平衡二叉树）

-  mid = $\lfloor (low + high)/2\rfloor$时，右子树结点数- 左子树结点数 = $0$或$1$。每次先在右子树上插入，之后再在左子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。

- mid = $\lceil (low + high)/2\rceil$时，左子树结点数 - 右子树结点数= $0或1$。每次先在左子树上插入，之后再在右子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。

给定n个元素，构造其查找判定树时，先按某个mid取值方法，构造出n个结点的判定树的形状，再按**中序遍历**填入各个元素。（**记得加上失败节点**）



> 1、折半查找平均情况下比顺序查找的效率高，但折半查找并不一定比顺序查找快
>
> 2、由于该判定树只有最下层是不满的，失败结点最早出现在第 $h-1$层结点的左右子树中，最迟出现在叶子结点的左右子树中，故使用二分查找算法查找一个不存在的元素，比较次数至少为 $h-1$,至多为 $h$
>
> 3、折半查找失败时，low > high, 此时low所指的是大于key的最小值，即第一个大于key的元素，low之后的元素都大于key；high所指的是小于key的最大值，即第一个小于key的值，high之前的元素都小于key。

在n个关键字的有序的顺序表中，使用折半查找时，$ASL_{成功}$和$ASL_{失败}$

1. n个关键字，其判定树树高 $h = \lceil log_2(n+1)\rceil$ ，叶子结点个数 $K = n - (2^{h-1}-1)$

   故 $ASL_{成功} = \frac{1*1+2*2+2^2*3+...+2^{h-2}*(h-1)+K*h}{n}$

   $ASL_{失败} = \frac{(h-1)*(2^{h-1}-K)+h*2K}{n+1}$

2.  构造n个关键字的查找判定树，根据判定树确定$ASL_{成功}$和$ASL_{失败}$。

   不论mid取值的方法如何，选用一种进行判定树的构造，对计算平均查找长度没有影响。

### 2.3、分块查找

分块查找又称 **索引顺序查找**。

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-16_22-19-50-2024-12-811:32:47.png" alt="Snipaste_2023-03-16_22-19-50" style="zoom:80%;" />



<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241208112949836-2024-12-811:29:56.png" alt="image-20241208112949836" style="zoom:67%;" />

思想：将查找表分为若干子块，**块内元素可以无序，但块间有序**。再建立索引表，索引表中每个元素包括<u>各块中元素的最大值</u>和<u>每个块的第一个元素地址</u>，其中索引表按关键字有序排列。

分块查找的步骤：先查索引表（顺序查找或折半查找），再对分块内进行顺序查找。

**ASL = 查找索引表的查找长度 + 查分块的查找长度**

用折半查找查索引表时，**若待查记录不在索引表中**，折半查找失败，此时low>high，应在**low**所指的块中查找。**此时查索引表的查找长度是折半查找的判定树中该失败结点的父节点所在的层数**，若最终low超出索引表的范围，则查找失败。

> 此时low所指的是大于关键字的最小值，应在该块对应的范围内再寻找。
>
> 而high所指的是小于关键字的最大值，high对应的块其范围内的元素都比关键字小。

若n个元素的查找表被分成b块，每块s个元素，在每个元素查找概率相同的情况下：

- 顺序查找索引表：$ASL_{成功}$= L1 + L2 = $\frac{1+2+...+b}{b}+\frac{1+2+...+s}{s} = {\frac{b+1}{2}+\frac{s+1}{2}} = \frac{s^2+2s+n}{2}$，当 $s = \sqrt{n}$时，$ASL_{成功}$ 取得最小值$ \sqrt{n} +1$。

- 折半查找索引表：$ASL_{成功} = L1+L2 = \lceil log_2(b+1)\rceil + \frac{s+1}{2}$





## 三、树形结构查找方法

### 3.1、二叉排序树（BST）

1、**二叉排序树的定义**

二叉排序树，又称二叉查找树（BST，Binary Search Tree）一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：

- 左子树上所有结点的关键字均小于根结点的关键字；
- 右子树上所有结点的关键字均大于根结点的关键字。
- 左子树和右子树又各是一棵二叉排序树。

根据二叉排序树的定义，左子树结点值 < 根结点值 <右子树结点值，对其进行一次**中序遍历**，可以得到一个递增的有序序列。

> i. 若已知一个二叉排序树的先序/后序/层序遍历序列，可以得到其中序序列，进而可以构造出这棵二叉排序树，其中序序列为递增有序的序列。
>
> ii. 利用二叉排序树进行查找时，要画上失败结点。
>
> iii. 成功和失败查找长度的计算与折半查找判定树中对应查找长度的计算方法相同。

2、**二叉排序树的查找**

二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。

```c++
//非递归算法
BSTNode* search(BiTree T, ElemType key) {
    while (T != NULL && key != T->data) {
        if (key < T->data) 
            T = T->lchild;
        else
            T = T->rchild;
    }
    return T;
}
//递归算法
BSTNode* search(BiTree T, ElemType key){
    if (T == NULL) return NULL;
    if (key == T->data) return T;
    else if (key < T->data)  
        return search(T->lchild, key);
    else 
        return search(T->rchild, key);
}
```

3、二叉排序树的插入

二叉排序树作为一个动态树表，该树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的节点时再进行插入的。

插入过程：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点的值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。

插入的结点一定是一个新添加的**叶结点**，且是查找失败时的查找路径上最后一个结点的左孩子或右孩子。

当插入序列有序时，树的高度最大。

```c++
//非递归算法
int BST_Insert(BiTree T, ElemType key) {
    BSTNode *p = T,*q;//p用于遍历，q保存p的父节点。
    while (p != NULL) { //寻找插入位置
        q = p; //保存父节点
        if (key == p->data)
            return 0; //插入失败
        else if (key < p->data)
            p = p->lchild;
        else
            p = p->rchild;
    }
    //若在树中没有找到key，最终该结点要插在q所指结点的左孩子或右孩子处
    BSTNode* node = (BiTree) malloc(sizeof(BSTNode));
    node->data = key;
    node->lchild = NULL; node->rchild = NULL;
    if (key < q->data) 
        q->lchild = node;
    else
        q->rchild = node;
    return 1; //插入成功
}

//递归算法
int BST_Insert(BiTree &T, ElemType key) {
    if (T == NULL) { //若原树为空，则创建一个新结点插入。最终一定会插入到叶子结点的位置
        T = (BiTree) malloc(sizeof(BSTNode));
        T->data = key;
        T->lchild = NULL; T->rchild = NULL;
        return 1; //返回1，插入成功
    }
    else if (key == T->data) //在树中找到该结点，插入失败
        return 0; 
    else if (key < T->data)  //在左子树中插入
        BST_Insert(T->lchild, key);
    else
        BST_Insert(T->rchild, key);
}

//构造二叉排序树
//从一棵空树出发，依次输入元素，将其插入二叉排序树中合适的位置
void BST_Creat(BiTree &T, ElemType str[], int n) {
    //按照str[]中的关键字序列建立二叉排序树
    T = NULL; //初始时T为空树
    int i = 0;
    while (i < n) {
        BST_Insert(T, str[i]);
        i++;
    }
}
```

4、**二叉排序树的删除**

删除某结点后要保持二叉排序树的特性不变，即 左<根<右。

对于被删除的结点Z，有三种情况

1. Z是叶节点，则直接删除
2. Z只有左子树或右子树，则删除结点Z，并让Z的子树成为Z的父节点的子树，替代Z的位置
3. Z同时有左子树和右子树
   - 方案一：**用左子树中值最大的结点代替Z的位置**。该结点是Z左子树的中序遍历序列的最后一个结点，即用**左子树最右下的结点代替Z**，再删除该结点。而该结点一定没有右子树，对该结点的删除转化为第1.2中情况下的删除。
   
   - 方案二：**用右子树中值最小的结点代替Z的位置。**该结点是Z右子树的中序遍历序列的第一个结点，即用**右子树最左下的结点代替Z**，再删除该结点。而该结点一定没有左子树，对该结点的删除转化为第1.2中情况下的删除。
   
   - 方案三：令*p的左子树为 *f 的左子树（若 \*p 是 \*f 的左孩子），而\*p 的右子树为 \*s 的右子树（\*s 是对 \*p 的左子树进行中序遍历的最后一个结点 ，即让 \*p 的右孩子连接到左子树中最大元素的右孩子处）
   
     或者，令 \*p 的右子树为 \*f的右子树（若 \*p 是 \*f 的右孩子），而\*p 的左子树为 \*s 的左子树（\*s 是对 \*p 的右子树进行中序遍历的第一个结点 ，即让 \*p 的左孩子连接到右子树中最小元素的左孩子上）
   
     ![image-20241208115345730](https://gitee.com/cmyk359/img/raw/master/img/image-20241208115345730-2024-12-811:53:54.png)
   
   

**删除并插入结点v**

- 在<u>二叉排序树</u>中，**删除并插入**某结点时，由于插入位置一定在叶子结点处，所以当被该结点**不是叶子结点**时，删除插入操作完成后二叉排序树结构将发生改变。

- 在<u>二叉平衡树</u> $T_1$中，删除一个结点v后得到新的AVL树$T_2$，再将该结点插回得到新的AVL树$T_3$。
  - v是叶结点：若删除操作没有导致$T_1$失去平衡，不会发生调整，再插入此结点得到的AVL树$T_3$和$T_1$相同。若删除操作后$T_1$失去平衡而发生调整，再插入该结点后得到的$T_3$和$T_1$有**可能不同**。
  - v不是叶结点：$T_1$和$T_3$有可能相同，也有可能不同。

  

5、**二叉排序树的查找效率分析**

二叉排序树查找效率。主要取决于树高。对n个结点的二叉排序树，高度最大为n，最低为 $\lfloor log_2n \rfloor +1$

### 7.3.2、平衡二叉树 （AVL）

平衡二叉树（balanced Binary Tree）简称平衡树(AVL树)，树上任一结点的左子树和右子树的高度之差不超过1

结点的平衡因子 = 左子树高度 - 右子树高度

**平衡二叉树的插入**

平衡二叉树的插入过程前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。每次调整的都是**最小不平衡子树**，即以插入路径上离插入结点最近的平衡因子绝对值大于1的结点作为根的子树。只要将最小不平衡子树调整平衡，则其他祖先结点都会回复平衡。调整的规律如下：

调整最小不平衡子树A

- LL：在A的左孩子的左子树中插入导致不平衡 （**A的左孩子右上旋**）

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230318204512157-2024-12-811:54:28.png" alt="image-20230318204512157" style="zoom:80%;" />

  将A的左孩子B向右旋转代替A成为根结点，A结点向下旋转成为B的右孩子，同时B的原右子树作为A的左子树。

  ```C++
  //若F是A的父节点，A是左孩子，则代码思路为：
  A->lchild = B->rchild;
  F->lchild = B;
  B->rchild = A;
  ```

- RR：在A的右孩子的右子树中插入导致不平衡（**A的右孩子左上旋**）

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230318204722921-2024-12-811:54:46.png" alt="image-20230318204722921" style="zoom:80%;" />

  将A的右孩子B向左旋转代替A成为根结点，A结点向下旋转成为B的左孩子，同时B的原左子树作为A的右子树。

  ```c++
  //若F是A的父节点，A为右孩子，则代码实现为
  A->rchild = B->lchild;
  F->rchild = B;
  B->lchild = A;
  ```

- LR：在A的左孩子的右子树中插入导致不平衡（**A左孩子的右孩子先左上旋再右上旋**）

  ![image-20230318205430184](https://gitee.com/cmyk359/img/raw/master/img/image-20230318205430184-2024-12-811:34:20.png)

  在A左孩子的右子树C中插入结点导致了不平衡，可能插入在C的左子树或右子树上。

  调整：将C左旋加右旋，调整到A的位置。<u>即让C代替A的位置，B做C的左孩子，A做C的右孩子，C的左子树做B的右子树，C的右子树做A的左子树，一步调整完成。</u>

- RL：在A的右孩子的左子树中插入导致不平衡（**A右孩子的左孩子先右上旋再左上旋**）

<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-18_21-01-04-2024-12-811:55:02.png" alt="Snipaste_2023-03-18_21-01-04" style="zoom:80%;" />

同上。

**查找效率分析**

若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过 $O(h)$。

假设以$n_h$表示深度为$h$的平衡树中含有的**最少**结点数，则有$n_0 = 0,n_1 = 1,n_2 = 2$，并且<u>有$n_h = n_{h-1} +n_{h-2}+1$</u>。由下图可知，$T_h = T_{h-1}+T_{h-2}+1$即为递推公式。此时平衡二叉树的结点个数最少，**每个非叶结点的平衡因子都是$1$。**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230323160202508-2024-12-811:55:23.png" alt="image-20230323160202508" style="zoom: 80%;" />

一个平衡二叉树有9个结点，因为$n_4 = 7,n_5 =12$，9<12，所以其最大深度为4。**含有n个结点的平衡二叉树的最大深度为$O(log_2n)$，**所以平衡二叉树的平均查找长度为$O(log_2n)$。





### 7.3.3、红黑树（BRT）

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320161057030-2024-12-811:56:35.png" alt="image-20230320161057030" style="zoom:80%;" />

平衡二叉树和红黑树对比

- 平衡二叉树AVL：插入和删除很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/LR/RR/RL调整。
- 红黑树RBT：插入和删除 很多时候并不会破坏"红黑"特性，无需频繁调整树的形态。即便需要调整也可以在常数级时间内完成。

平衡二叉树适用于以查为主、很少进行插入/删除的场景；红黑树：适用于频繁插入/删除的场景，实用性更强。二者在查找、插入、删除方面的时间复杂度都为$O(log_2n)$。

**定义和性质**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320150715631-2024-12-811:56:43.png" alt="image-20230320150715631" style="zoom: 67%;" />

红黑树是二叉排序树，满足左子树结点值 < 根结点值 < 右子树结点值。和普通BST相比，还需要满足以下特性： **<u>(左根右，根叶黑，不红红，黑路同)</u>**

- 每个结点或是红色的，或是黑色的。
- 根结点是黑色的
- 叶结点 (外部结点、NULL结点、失败节点)均是黑色的。
- 不存在两个相邻的红色结点（不存在父节点是红色，子女结点也是红色的情况）
- 对每一个结点，从该结点到任一叶子结点的简单路径上，所含黑结点的数目相同。如图中，13到所有叶结点的路径上都有两个黑结点。

```c
struct RBNode{ //红黑树结点定义
    int key;
    RBNode* parent;
    RBNode* lChild;
    RBNode* rChild;
    int color;	//结点颜色，如：可以用0/1表示红/黑
};
```



性质：

- 结点的**<u>黑高</u>**：从某结点出发（不包含该结点）到达任一空叶结点的路径上黑结点总数。

- 根结点黑高为h的红黑树，内部关键字最少有$2^h-1$个

  内部结点数最少的情况：所有结点都是黑色，且是高为h的满二叉树时内部结点最少。当所有结点都为黑色时，只有该树是满二叉树时才能保证，所有叶结点在同一层，进而满足<u>黑路同</u>的特性。高度为h的满二叉树中有 $2^h-1$个结点。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320153438409-2024-12-811:56:48.png" alt="image-20230320153438409" style="zoom:50%;" />

- 从根结点到叶结点的<u>最长路径</u>不大于<u>最短路径</u>的2倍

  由于从根结点到任何一个叶结点的路径上黑结点数量相同，而路径上不能连续出现两个红结点，所以最长路径只能是红结点只能穿插在各个黑结点之间。

- 有n个内部节点的红黑树高度 $h \le 2log_2(n+1)$，故红黑树查找操作时间复杂度 = $O(log_2n)$。

  若红黑树总高度为h，则根结点黑高 $\ge h/2$（此时红结点穿插在查找失败路径上各个黑结点之间，根结点黑高最小，路径最长），则内部结点数 $n \ge 2^{h/2}-1$，进而得 $h \le 2log_2(n+1)$。

**红黑树的查找**

​	和二叉排序树的查找相同。

**红黑树的插入**

1. 先查找，确定插入位置，插入新结点（和二叉排序树相同）

   - 新结点是 **根** -- 染为**黑色**
   - 新结点 **非根** -- 染为**红色 **（保证黑路同的特性）

2. 若插入新结点后依然满足红黑树的定义，则插入结束。

3. 若插入新结点后不满足红黑树的定义，需要<u>**调整**</u>，使其重新满足红黑树的定义。

   对于插入的<u>非根</u>结点，被染成红色，此时**只可能**会破坏红黑树特性中的**<u>不红红</u>**，其他几个都没有影响

   调整策略有新插入结点的叔叔结点的颜色决定。（**<u>看其叔叔的脸色行事</u>**）

   - 黑叔：**旋转+染色**（旋转操作和平衡二叉树的调整方法完全相同）

     - LL型：右单旋，父换爷+染色

       LL型即新结点插在了爷结点左孩子的左边；父换爷+染色，即<u>右单旋后</u>，其效果为父节点和爷结点位置互换，同时要将两者颜色变为与原来相反，红变黑，黑变红。

     - RR型：左单旋，父换爷+染色

     - LR型：左、右双旋，儿换爷+染色

     - RL型：右、左双旋，儿换爷+染色

   - 红叔：**染色+变新**

     - 叔父爷染色，爷变为新结点。（爷成为新结点后，回到第一步，若是根节点则染为黑色，若是非根结点染为红色，再看是否破坏了红黑树定义，继续处理）

### 7.3.4、B树

**定义**

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320174149811-2024-12-811:57:00.png" alt="image-20230320174149811" style="zoom:80%;" />

B树，又称多路平衡查找树（所有结点的平衡因子都为$0$，**绝对平衡**），B树中所有结点的孩子个数的最大值称为B树的阶。

一棵m阶B树或为空树，或为满足如下特性的m叉树：

- 树中每个结点至多有m棵子树，即至多含有m-1个关键字

- 若根节点不是终端节点，则至少有两棵子树。（保证所有结点都绝对平衡）

- 除根结点外（树中可能就只有1个结点，达不到$\lceil m/2\rceil$的要求），所有非叶结点至少有$\lceil m/2\rceil$棵子树，即至少含有$\lceil m/2\rceil-1$个关键字（保证查找效率）

- 所有非叶结点结构如下：

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320164537682-2024-12-811:57:04.png" alt="image-20230320164537682" style="zoom: 45%;" />

  其中$K_i$为关键字，$P_i$为指向子树的指针。**非叶节点内关键字有序**，即$K_1<K_2<...<K_n$。$K_i$左侧指针$P_{i-1}$所指子树中所有结点的关键字都比 $K_i$小，右边的都比$K_i$大

- 所有叶结点都出现在最后一层，并且不带信息。（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。

  <u>n个关键字的m阶B树，必定有n+1个叶子结点。</u>（相当于n个关键字将负无穷到正无穷分成了n+1个区间，每个区间对应一个失败结点，即叶子结点）

> 对一棵5阶B树，除根结点外，只要其结点内的关键字个数在 [2,4]之间，都满足5阶B树的定义。

**m阶B树的核心特性**：

- **根结点**的子树个数 $\in[2,m]$，关键字个数 $\in[1,m-1]$;

  **其他结点**的子树个数$\in[\lceil m/2\rceil,m]$，关键字个数个数$\in[\lceil m/2\rceil-1,m-1]$

- 对任一结点，其所有子树高度都相同，绝对平衡。
- 关键字的值：子树0<关键字1<子树1<关键字2<子树2...（  类比二叉查找树左<中<右）

**B树的高度**

含有n个关键字的m阶B树的最大高度和最小高度：（不包含叶子结点）

- 最小高度：$log_m(n+1)$

  要让高度最小，须让每个结点尽可能地满，每个结点有m-1个关键字，则$n \le (m-1)(1+m+m^2+...+m^{h-1})=m^h-1$，故$h\ge log_m(n+1)$

- 最大高度：$log_{\lceil m/2 \rceil}(\frac{n+1}{2})+1$

  要让高度最大，让各层的分叉尽可能少。根节点有两个分叉，其余结点有$\lceil m/2\rceil$个分叉。第一层有1个结点，第二层有2个结点，第三层有$2\lceil m/2\rceil$个结点，第四层有$2\lceil m/2\rceil^2$,第h层有$2\lceil m/2\rceil^{h-2}$。

  - 第h+1层共有叶结点(失败节点)$2\lceil m/2\rceil^{h-1}$个，而有n个关键字的m阶B树必定有n+1个叶结点，所以 $n+1 \ge 2\lceil m/2\rceil^{h-1}$,即 $h \le log_{\lceil m/2 \rceil}(\frac{n+1}{2})+1$

  - 记$k=\lceil m/2\rceil$，h层的m阶B树至少包含关键字总数$1+2(k-1)(k^0+k^1+...+k^{h-1}) =1+2(k^{h-1}-1)$,若关键字总数少于这个值，则高度一定小于h，故$n \ge 1+2(k^{h-1}-1)=2k^{h-1} -1$ ，所以 $h \le log_k(\frac{n+1}{2})+1$



<img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-20_17-41-10-2024-12-811:57:10.png" alt="Snipaste_2023-03-20_17-41-10" style="zoom:80%;" />

**B树的插入**

新元素一定是插入到最底层“终端节点”中，用查找来确定插入位置。

在插入key后，若导致原结点关键字超出上限，则从中间位置 ($\lceil m/2\rceil$)处将其中的关键字**分为两部分**，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置 ($\lceil m/2\rceil$)的关键字插入原结点的父节点中。若此时导致父节点中关键字个数也超过上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致B树高度增加1。

**B树的删除**

- 若被删除的关键字在<u>终端节点</u>，删除该关键字。

  - 若删除后结点内的关键字个数未低于下限，无需任何处理。
  - 若低于下限
    - 若左兄弟够借，则用当前关键字的前驱和前驱的前驱依次顶替空缺
    - 若右兄弟够借，则用当前关键字的后继和后继的后继依次顶替空缺
    - 若左右兄弟都不够借时，则将关键字删除后与左兄弟（或右兄弟）结点及双亲结点中的关键字合并。在合并过程中，双亲结点中的关键字会减1。若双亲结点是根结点且关键字个数减少为$0$，则直接将根结点删除，合并后的新结点成为根。若双亲结点不是根结点且其关键字个数减少到低于下限，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树要求为止。

- 若被删除的关键字在<u>非终端结点</u>，则直接用直接前驱或直接后继来替代被删除的关键字
  - 直接前驱：当前关键字左侧指针所指子树最右下的元素
  - 直接后继：当前关键字右侧所指子树最左下的元素

  **对非终端结点关键字的删除，就转化为对终端节点中关键字的删除。**

### 7.3.5、B+树

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320180717857-2024-12-811:57:14.png" alt="image-20230320180717857" style="zoom:80%;" />

**定义**

一棵m阶B树需满足下列条件：

- 每个分支结点最多有m棵子树
- <u>非叶根节点</u>至少有两棵子树，其他每个分支结点至少有$\lceil m/2\rceil$棵子树
- **结点的子树个数和关键字个数相等** （与B树不同）
- 所有**叶结点包含所有的关键字**及指向相应记录的指针，**叶结点中将关键字按大小顺序排列**，并且**相邻叶结点按大小顺序相互链接起来**。（叶结点支持顺序查找）
- 所有分支结点中仅包含它的各个子结点中关键字的最大值及指向子结点的指针

![image-20230615210912913](https://gitee.com/cmyk359/img/raw/master/img/image-20230615210912913-2024-12-811:56:30.png)

  相同点   除根结点外，每个结点至少有 $\lceil m/2 \rceil$个分叉；任何一个结点的子树都一样高；

B+树是应文件系统所需而产生的的B树的变形，前者比后者，前者的磁盘代价更低，查询效率更加稳定，更加适用于实际应用中的**操作系统文件索引和数据库索引**。

补：树中的每个结点保存在磁盘中的某个磁盘块中，从根结点开始查询某个关键字，要将该路径上的所有磁盘块读入内存，由于磁盘块大小是固定的，在B+树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。相比较于B树，每个结点中还包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。





## 四、散列表

### 4.1、概念

- 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr
- 冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，这种情况称为冲突
- 同义词：被散列函数映射到同一地址的不同关键字之间互为同义词
- 散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址间的直接映射关系

一方面设计得好的**散列函数**应尽量减少冲突的发生；另一方面，由于冲突不可避免，所以还要设计好**处理冲突的方法**。散列查找是一种用空间换时间的方法。



### 4.2、散列函数的构造方法

常用的散列函数如下

- 直接定址法

  - 直接取关键字的某个线性函数值作为散列地址
  - 散列函数：H(key) = key 或 H(key) = a * key + b
  - 特点：计算最简单且不会发生冲突，适合关键字分布基本连续的情况，若关键字分布不连续，空位较多，会造成存储空间的浪费。

- 除留余数法

  - 假定散列表表长为m，**取一个不大于m但最接近或等于m的质数**，利用其对关键字取余，将关键字转化为散列地址。（用这样的p取余，会使散列地址分布更均匀，冲突更少）
  - 散列函数为：H(key) = key %p
  - 特点：最简单，最常用的方法。关键是选好p。

- 数学分析法

  - 设关键字是r进制数（如十进制数），而**r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些**，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可**选取数码分布较为均匀的若干位作为散列地址**。
  - 特点：这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

- 平方取中法

  - 取关键字的平方的中间几位作为散列地址。具体取多少位要视实际情况而定。**这种方法得到的散列地址与关键字的每位都有关系**，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

    

### 4.3、处理冲突的方法

处理冲突，即为产生冲突的关键字寻找下一个"空"的Hash地址

- 开放定址法

  空闲地址既向它的同义词开放，又向它的非同义词开放。

  数学递推公式为：$H_i = (H(key)+d_i)%m$。其中H(key)为散列函数，m为散列表表长，$d_i$为增量序列

  

  **增量$d_i$的取值方法**

  - 线性探测法（线性探测再散列）
    - $d_i = 0,1,2,...,m-1$，当出现冲突时，就顺序地向下一个单元探测，直到没有单元发生冲突
    
    - 线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就会争夺第i+2个散列元素的地址.....从而导致大量元素在相邻的散列地址上**堆积**，大大降低了查找效率。（在解决冲突时可能会造成新的冲突）
    
    - 查找：首先判断散列地址位置的元素是否为待查元素，若不是则依次向后判断，直到找到该元素，或**遇到空位置**时停止，此时查找失败。当其不在散列表中时，**对空位置的判断也要算一次比较**（冲突的次数应与查找时对比的次数相同)
    
      > 查找不成功时，设散列函数有m个取值，即共有m个查找失败的入口（0~m-1）,注意是散列函数有m个取值，而不是散列表长度为m。对每个入口依次计算，对每种可能，该位置为空（算作比较一次）或不空但不为正确的关键字，则一直向后找，直到找到一个空位置，即可确定查找失败，查找次数为该位置查找失败的查找长度。
    
    - 删除：<u>采用“开放定址法”时</u>，要删除元素，不能简单地将其从散列表中删掉该元素，这会导致该位置为空，将截断在它之后填入元素的查找路径。可以设置一个“删除标记”，**进行逻辑删除**。查找时遇到删除标记，直接跳过向后查找。**遇到删除标记也算一次比较**。
    
    > 线性探测法解决冲突时线性地查找空闲位置，平均查找长度与表的大小m无关，只与所选取的哈希函数H、装填因子有关，$ASL_{成功} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$
  - 平方探测法（二次探测再散列）
    - 当$d_i = 0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2$时，称为平方探测法，又称二次探测法，其中$k \le m/2$。此时<u>散列表长度m，必须是可以表示为$\underline{4j+3}$的素数</u>，这样才能通过平方探测法探测到所有位置。
    - 特点：可以避免出现“堆积”问题。
  - 伪随机序列法（伪随机探测再散列）
    
    - $d_i$是一个伪随机序列

- 再散列法

  ​	除了原始的散列函数H（key）之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。

  > 当增量$d_i = Hash_2(key)$时，称为再散列法。当通过第一个散列函数$H(key)$得到的地址发生冲突时，再利用第二个散列函数 $Hash_2(key) %$计算该关键字的增量，即$H_i=[H(key)+i*Hash_2(key)]\%m$ 。初始探测位置$H_0=H(key)%m$，i 是冲突的次数。在再散列法中，最多经过m-1次探测就会遍历表中所有位置，回到$H_0$

- 拉链法（链地址法）

  - 把所有同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。此时散列表中存放的是指向链表的指针。当链表有序时可以提高查找效率
  - <u>计算查找长度时，和空链域的对比**不计入**查找次数。</u>
  - 拉链法适用于经常进行插入和删除的情况
  
  例如：采用除留余数法，散列函数为：H(key) = key % 13，采用拉链法处理冲突，对应的散列表如下，此时$ASL_{成功} = \frac{1*6+2*4+3*1}{11}$，$ASL_{失败}= \frac{1*2+2*3+3*1}{\color{red}13}$
  
  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320213023659-2024-12-815:42:20.png" alt="image-20230320213023659" />
  
  
  
  > 查找失败时，某位置的查找长度的计算，**按对应处理冲突方法的规则寻找空位置**（并不都是依次向后寻找，这只是线性探测寻找空位置的方法），统计寻找的次数

### 4.4、性能分析

**平均查找长度**仍是其查找效率的度量。

散列表的查找效率取决于三个因素：**<u>散列函数</u>、<u>处理冲突的方法</u>和<u>装填因子</u>**

- 散列表的装填因子α = $\frac{表中记录数n}{散列表长度m}$，其反映了这个表的装满程度。
- **散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于n或m。**α 越大，表示装填的记录越满，发生冲突的可能性越大，反之发生冲突的可能性越小。

> 1. 散列查找不是只能在顺序表上进行，采用拉链法处理冲突时，采用的是顺序存储和链式存储相结合的方式。
>
> 2. 在开放定址法中散列到同一地址而引起的“堆积”问题是由于<u>同义词之间</u>，或<u>非同义词之间</u>发生冲突引起的，造成该问题的原因是处理冲突的方法选择不当，直接影响到的是平均查找长度。
>
> 3. 通过线性探测法解决冲突时，在查找某关键字时，所查找位置上的键值不一定都是同义词
>
> 4. 链地址法处理冲突时将同义词放在一个链表中，不会引起聚集现象
>
> 5. 负数求模运算：在利用平方探测法解决冲突时，在寻找无冲突位置和求查找失败时的平均查找长度时，会出现 “负数 % 正数”的情况。
>
>    计算方法：先将负号提出去，直接求$-(|m| \%n)$，最后再加上$n$ $$例如：(4 - 3^2) \% 11 = -5 \% 11 \quad \rightarrow \quad -(5\%11) = -5 \quad -5+11 = 6 \; \therefore -5 \%11=6$$