---
title: 并发编程模式
abbrlink: 12dbc0cd
categories:
  - JavaSE
date: 2025-02-12 22:25:36
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## 同步模式之保护性暂停

### 1、定义

即 Guarded Suspension，用**在一个线程等待另一个线程的执行结果**。

- 当有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject。
- t1线程在获取 GuardedObject中的response时，若response为空，则wait等待
- t2线程产生所需结果后为response赋值，并通知t1所需结果到达，继续执行。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250301154204249-2025-3-115:42:19.png" style="zoom:80%;" />

补充：

- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）

- JDK 中，join 的实现、Future 的实现，采用的就是此模式

- 因为要等待另一方的结果，因此归类到同步模式
- 该模式中产生结果的线程和使用结果的线程是**一一对应**，成对出现的。而后面的生产者消费者模式，不需要产生结果和消费结果的线程-—对应，具体见后面内容。

### 2、实现一

```java
class GuardedObject {
    private Object response;
    private final Object lock = new Object();

    /**
     * 获取结果，一直等待，直至条件满足被唤醒
     * @return
     */
    public Object get() {
        synchronized (lock) {
            //条件不满足，等待结果
            while (response == null) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return  response;
        }
    }

    /**
     * 获取结果，超时等待timeout（毫秒）后退出
     * @param timeout
     * @return
     */
    public Object get(long timeout) {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        synchronized (lock) {
            //开始时间
            long begin = System.currentTimeMillis();
            //条件不满足，等待结果
            long passedTime = 0; //已等待的时间
            while (response == null) {
                //本轮循环还需等待的时间
                long waitTime = timeout - passedTime;
                if (waitTime <= 0) {
                    System.out.println("等待超时....");
                    break;
                }

                try {
                    lock.wait(waitTime); //等待waitTIme，避免虚假唤醒而增加等待时间
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //本轮循环等待的时间，可能不是waitTIme，因为可能被提前唤醒
                passedTime = System.currentTimeMillis() - begin;
            }
            return  response;
        }
    }

    /**
     * 生产所需结果
     * @param response
     */
    public void complete(Object response) {
        synchronized (lock) {
            //条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }
}
```

***

测试超时等待

```java
public class test5 {
    public static void main(String[] args) {
        GuardedObject guardedObject = new GuardedObject();
        new Thread(()->{
            log.debug("等待结果");
            Object resp = guardedObject.get(3000);//超时等待3秒
            log.debug("结果为：{}", resp);
        },"t1").start();

        new Thread(()->{
            log.debug("计算结果");
            //t2线程计算所需结果
            try {
                Thread.sleep(5000); //模拟计算耗时，共5秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Object resp = new Object();
            guardedObject.complete(resp);
        },"t2").start();
    }
}
```

结果为：

```java
16:08:18.414 [t1] c.test5 - 等待结果
16:08:18.414 [t2] c.test5 - 计算结果
16:08:21.432 [t1] c.test5 - 等待超时....
16:08:21.432 [t1] c.test5 - 结果为：null
```

### 3、实现二--多任务版GuardedObject

​	如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。

​	图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250301170943151-2025-3-117:09:50.png" style="zoom:80%;" />

新增 id 用来标识 Guarded Object

```java
class GuardedObject {
    private int id;
    private Object response;

    public GuardedObject(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    /**
     * 获取结果，一直等待，直至条件满足被唤醒
     * @return
     */
    public Object get() {
        synchronized (this) {
            //条件不满足，等待结果
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return  response;
        }
    }

    /**
     * 获取结果，超时等待timeout（毫秒）后退出
     * @param timeout
     * @return
     */
    public Object get(long timeout) {
        synchronized (this) {
            //开始时间
            long begin = System.currentTimeMillis();
            //条件不满足，等待结果
            long passedTime = 0; //已等待的时间
            while (response == null) {
                //本轮循环还需等待的时间
                long waitTime = timeout - passedTime;
                if (waitTime <= 0) {
                    log.debug("等待超时....");
                    break;
                }

                try {
                    this.wait(waitTime); //等待waitTIme，避免虚假唤醒而增加等待时间
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //本轮循环等待的时间，可能不是waitTIme，因为可能被提前唤醒
                passedTime = System.currentTimeMillis() - begin;
            }
            return  response;
        }
    }

    /**
     * 生产所需结果
     * @param response
     */
    public void complete(Object response) {
        synchronized (this) {
            //条件满足，通知等待线程
            this.response = response;
            this.notifyAll();
        }
    }
}
```



中间解耦类

```java
class Mailboxes{
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();
    private static int id = 1;

    /**
     * 产生唯一id
     * @return GuardedObject的id
     */
    public static synchronized int generateId(){
        return id++;
    }

    /**
     * 获取对应id的GuardedObject，并从boxes中删除它
     * @param id
     * @return
     */
    public static GuardedObject getGuardedObject(int id) {
        return boxes.remove(id);
    }

    /**
     * 创建并添加一个GuardedObject
     * @return
     */
    public static GuardedObject createGuardedObject() {
        GuardedObject go = new GuardedObject(generateId());
        boxes.put(go.getId(), go);
        return go;
    }

    /**
     * 获取正在等待结果的GuardedObject的id
     * @return
     */
    public static Set<Integer> getIds() {
        return boxes.keySet();
    }
}
	
```

模拟业务：`People`类想要请求另一个线程的结果时，在`Mailboxes`中创建一个`GuardedObject`，调用它的`get`方法等待结果返回被唤醒；`Postman`类根据ID获取`Mailboxes`中已存在的`GuardedObject`，产生结果后将其写入并唤醒等待线程。

```java
@Slf4j(topic = "c.people")
class People extends Thread{
    @Override
    public void run() {
        // 收信（等待结果）
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.debug("开始收信 id:{}", guardedObject.getId());
        Object mail = guardedObject.get(5000);
        log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
    }
}
@Slf4j(topic = "c.postman")
class Postman extends Thread {
    private int id;
    private String mail;
    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }
    @Override
    public void run() {
        //送信（产生结果，通知等待的线程）
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.debug("送信 id:{}, 内容:{}", id, mail);
        guardedObject.complete(mail);
    }
}
```

***

测试：

```java
public class test5 {
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 3; i++) {
            new People().start();
        }
        Thread.sleep(1000);
        for (Integer id: Mailboxes.getIds()) {
            new Postman(id, "内容" + id).start();
        }
    }
}
```

结果如下：每个people都收到了对应的结果

```bash
17:27:59.175 [Thread-1] c.people - 开始收信 id:3
17:27:59.175 [Thread-0] c.people - 开始收信 id:1
17:27:59.175 [Thread-2] c.people - 开始收信 id:2
17:28:00.185 [Thread-3] c.postman - 送信 id:3, 内容:内容3
17:28:00.185 [Thread-1] c.people - 收到信 id:3, 内容:内容3
17:28:00.185 [Thread-4] c.postman - 送信 id:2, 内容:内容2
17:28:00.186 [Thread-5] c.postman - 送信 id:1, 内容:内容1
17:28:00.186 [Thread-0] c.people - 收到信 id:1, 内容:内容1
17:28:00.186 [Thread-2] c.people - 收到信 id:2, 内容:内容2
```





### 4、join原理分析

```java
public final synchronized void join(long millis)
    throws InterruptedException { // 声明同步方法，允许指定超时毫秒数，可能抛出中断异常
    long base = System.currentTimeMillis(); // 记录方法调用时的基准时间戳
    long now = 0; // 初始化已等待时间计数器

    if (millis < 0) { // 防御性校验：超时时间不能为负数
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) { // 处理无限等待的特殊情况
        while (isAlive()) { // 持续检查目标线程是否存活
            wait(0); // 释放锁进入无限等待（直到被notify或中断）
        }
    } else { // 处理有限时间等待的常规情况
        //此处与之前GuardedObject中的超时等待方法逻辑相同
        while (isAlive()) { // 循环检查目标线程状态
            long delay = millis - now; // 计算剩余可等待时间
            if (delay <= 0) { // 剩余时间耗尽时跳出循环
                break;
            }
            wait(delay); // 带超时的等待（单位毫秒），会自动释放对象锁
            now = System.currentTimeMillis() - base; // 计算已等待的总时长
        }
    }
}
```



## 同步模式之顺序控制

### 1、固定运行顺序

要求：两个线程执行打印操作，必须先打印2后打印1

***

使用wati-notify实现

```java
public class test7 {
    private static Object lock = new Object();//锁对象
    private static Boolean t2Runned = false; //打印2的线程是否已经执行过了
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                while (!t2Runned) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("1");
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                log.debug("2");
                lock.notify();
                t2Runned = true;
            }
        }, "t2");

        t1.start();
        t2.start();
    }
}
```

> 使用ReentrantLock的 await和signal实现，与之类似

***

使用 park-unpark实现

分析：若t1先执行，则陷入阻塞，当打印完2后，使用unpark唤醒它，再打印1；若t2先执行，打印完2后为t1设置许可，当t1执行park时，已经存在许可，不必阻塞，直接打印1.

```java
public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        LockSupport.park();
        log.debug("1");
    }, "t1");

    Thread t2 = new Thread(() -> {
        log.debug("2");
        LockSupport.unpark(t1);
    }, "t2");

    t1.start();
    t2.start();
}
```



### 2、交替输出

线程 1 输出 a ，线程 2 输出 b，线程 3 输出 c 。

现在要求 先打印a，再打印b，再打印c，循环指定次。如打印 abcabcabcabcabc

***

使用wait-notify实现：

分析：

- 使用一个整数`flag` 标记轮到哪个线程打印，
  - 如线程1对应的flag为1，它要打印的是“a”
  - 线程2对应的flag是2，它要打印的是“b”
  - ...
- 当一个线程执行打印操作时，传入自己对应的标记，将其与`flag`进行比较。相同则打印，否则进行等待
- 为了控制打印顺序，一个线程打印完后，将`flag`设置为下一个打印线程对应的标记
- 每个线程循环打印`loopNum`次

```java
public class test8 {
    public static void main(String[] args) {
        WaitNotify wn = new WaitNotify(1, 5);
        new Thread(()->{
            wn.print("a",1,2);
        }).start();
        
        new Thread(()->{
            wn.print("b",2,3);
        }).start();
        
        new Thread(()->{
            wn.print("c",3,1);
        }).start();
    }

}

class WaitNotify {
    private int flag;
    private int loopNum;

    public WaitNotify(int flag, int loopNum) {
        this.flag = flag;
        this.loopNum = loopNum;
    }

    //打印
    public void print(String str, int waitFlag, int nextFlag) {
        for (int i = 0; i < loopNum; i++) {
            synchronized (this) {
                while (waitFlag != flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag; //指定下一个打印的线程
                this.notifyAll(); //唤醒等待的线程
            }
        }
    }
}
```

***

使用`ReentrantLock`的 `await/singal`方法实现

思路：发挥`ReentrantLock` 有多个等待Condition等待队列（休息室）的特性

- 创建三个 Condition对象，作为三个线程对应的休息室
- 当在线程中调用打印方法时，传入要打印的字符，自己的休息室，打印下一个字符的线程的休息室
  - 每个线程执行打印方法时，先进入自己的休息室，等待被唤醒
  - 唤醒后打印字符，并唤醒下一个休息室的线程执行打印操作
  - 在主方法中首先唤醒打印 "a"的线程，剩下的打印就如多米诺骨牌
- 在打印方法中循环 `loopNum`次



```java
public class test9 {
    public static void main(String[] args) {
        AwaitSingal awaitSingal = new AwaitSingal(5);
        Condition a = awaitSingal.newCondition();
        Condition b = awaitSingal.newCondition();
        Condition c = awaitSingal.newCondition();
		
        //三个线程
        new Thread(()->{
            awaitSingal.print("a",a,b);
        }).start();
        new Thread(()->{
            awaitSingal.print("b",b,c);
        }).start();
        new Thread(()->{
            awaitSingal.print("c",c,a);
        }).start();

        //首先唤醒打印a的线程，开始依次打印
        awaitSingal.start(a);
    }
}
class AwaitSingal extends ReentrantLock {
    private int loopNum;

    public AwaitSingal(int loopNum) {
        this.loopNum = loopNum;
    }
    
    public void start(Condition first) {
        lock();
        try {
            System.out.println("开始....");
            first.signal();
        }finally {
            unlock();
        }
    }
    
    public void print(String str, Condition current, Condition next) {
        for (int i = 0; i < loopNum; i++) {
            lock();
            try {
                current.await();//首先进行休息室，等待被唤醒
                System.out.print(str); //唤醒后执行打印操作
                next.signal();//唤醒下一个休息室中的线程
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }
}
```

***

使用`LockSupport`类的`park/unpark`方法实现

思路：

- `park/unpark`方法都是针对一个线程操作，没有锁的概念
- 每个线程执行打印操作时，先执行`park`方法阻塞住，等待其他线程唤醒；当被唤醒后，执行打印操作；最后唤醒打印下一个字母的线程
- 打印操作循环`loopNum`次

```java
public class test9 {
    static Thread t1;
    static Thread t2;
    static Thread t3;
    public static void main(String[] args) {
        SyncPark syncPark = new SyncPark(5);

        t1 = new Thread(()->{
            syncPark.print("a",t2);
        });
        t2 = new Thread(()->{
            syncPark.print("b",t3);
        });
        t3 = new Thread(()->{
            syncPark.print("c",t1);
        });

        t1.start();
        t2.start();
        t3.start();
        
        //首先唤醒打印a的线程，开始依次打印
        LockSupport.unpark(t1);
    }
}
class SyncPark {
    private int loopNum;

    public SyncPark(int loopNum) {
        this.loopNum = loopNum;
    }

    public void print(String str, Thread next) {
        for (int i = 0; i < loopNum; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
}
```

## 同步模式之Balking

Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。

例如：在两阶段终止模式中，监控线程只需要一个就行。若在主线程中多次调用start方法会创建多个监控线程，此时可以使用Balking模式来控制只启动一个。

思路：设置一个boolean类型的标记，默认为false，表示是否已经启动过监控线程。当调用start方法启动监控线程时，只有当该标记为false时才能创建新实例，若标记已经为true，则直接返回。

此时只使用`volatile`关键字是不够的，它只能保证该标记的修改在多个线程间可见，但在修改之前其他线程读到的值仍为false。比如：线程1判断它为false，并尝试将其设置为true，但它该线程修改之前，线程2也判断它false，也要将其设置为true，进行下面的操作，此时还会出现并发问题。

所以必须使用`synchronized`加锁解决并发安全问题。

```java
class  MonitorService {
    //监控线程
    private Thread monitor;
    //判断是否执行过 start 方法
    private volatile boolean started = false;

    //启动监控线程
    public void start() {
        synchronized (this) {
            if (started) {
                return;
            }
            started = true;
        }
        monitor = new Thread(() -> {...},"monitor");
        monitor.start();
    }

    //停止监控线程
    public void stop() {
		...
    }
}
```

***

它还经常用来实现线程安全的单例：

```java
    public final class Singleton {
        private Singleton() {
        }
        private static Singleton INSTANCE = null;
        public static synchronized Singleton getInstance() {
            if (INSTANCE != null) {
                return INSTANCE;
            }

            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
```



## 终止模式之两阶段终止模式

### 1、定义

两阶段终止模式 Two Phase Termination

目标：在一个线程 T1 中如何优雅终止线程 T2。这里的优雅指的是给 T2 一个料理后事的机会（设置一个后置处理器） 

**错误思路**

* 使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁
* 使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止

两阶段终止模式图示：

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250224223032040-2025-2-2422:30:34.png" style="zoom:80%;" />

### 2、利用 isInterrupted实现

interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行

```java
public class test {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination termination = new TwoPhaseTermination();
        termination.start();
        Thread.sleep(1000);
        termination.stop();
    }
}

@Slf4j(topic = "c.test2")
class  TwoPhaseTermination {
    //监控线程
    private Thread monitor;

    //启动监控线程
    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                Thread current = Thread.currentThread();
                //是否被打断
                if (current.isInterrupted()) {
                    log.debug("料理后事，后置处理");
                    break;
                }
                try {
                    //处理业务逻辑，此处阻塞不会清除打断标记
                    log.debug("执行监控记录");
                    Thread.sleep(500); //模拟阻塞
                } catch (InterruptedException e) {
                    //因为阻塞状态下中断后会清除打断标记，此处需要手动置为true，下一轮循环中退出
                    monitor.interrupt();
                    e.printStackTrace();
                }
            }
        },"monitor");
        monitor.start();
    }
    
    //停止监控线程
    public void stop() {
        monitor.interrupt();
    }
}
```

### 3、使用停止标记

使用`volatile`关键字修饰的停止标记，控制线程的结束

停止标记用 volatile 是为了保证该变量在多个线程之间的可见性

```java
public class test {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination termination = new TwoPhaseTermination();
        termination.start();
        Thread.sleep(1000);
        termination.stop();
    }
}

@Slf4j(topic = "c.test2")
class  TwoPhaseTermination {
    //监控线程
    private Thread monitor;
    //停止标记：线程是否能继续运行
    private volatile boolean stop = false;

    //启动监控线程
    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                //是否被打断
                if (stop) {
                    log.debug("料理后事，后置处理");
                    break;
                }
                try {
                    //处理业务逻辑，此处阻塞不会清除打断标记
                    log.debug("执行监控记录");
                    Thread.sleep(500); //模拟阻塞
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"monitor");
        monitor.start();
    }
    
    //停止监控线程
    public void stop() {
        //设置停止标记为true，停止线程
        stop = true;
        monitor.interrupt(); //若还在阻塞，则打断阻塞，进行停止标记的判断
    }
}
```



## 异步模式之生产者/消费者

### 1、定义

与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应。消费队列可以用来平衡生产和消费的线程资源，生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据。

消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据。JDK 中各种阻塞队列，采用的就是这种模式。

> 之所以称为异步，是因为一个消息的产生和消费并不是同步进行的，可能存在延时

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250301180055975-2025-3-118:00:57.png" style="zoom:80%;" />

### 2、实现

```java
final class Message {
    private int id;
    private Object message;

    public Message(int id, Object message) {
        this.id = id;
        this.message = message;
    }

    public int getId() {
        return id;
    }

    public Object getMessage() {
        return message;
    }
}

@Slf4j(topic = "c.MessageQueue")
class MessageQueue {
    //消息集合
    private LinkedList<Message> queue;
    //消息集合的容量
    private int capacity;

    public MessageQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new LinkedList<>();
    }

    public Message take() {
        synchronized (queue) {
            //如果消息队列为空，则等待消息
            while (queue.isEmpty()) {
                log.debug("消息队列为空，等待生产中...");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列中存在消息时，从队列头部取走一条
            Message message = queue.removeFirst();
            log.debug("已消费消息：{}", message);
            queue.notifyAll();//唤醒因队列满而无法存入消息的生产者
            return message;
        }
    }

    public void put(Message message) {
        synchronized (queue) {
            //消息队列已满，等待消费后再加入新消息
            while (queue.size() == capacity) {
                log.debug("消息队列已满，等待消费中...");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列还能加入新消息，将消息加入到队列尾部
            queue.addLast(message);
            log.debug("已生产消息：{}", message);
            queue.notifyAll(); //唤醒因消息队列为空而等待的消费者
        }
    }
}
```



测试：消息队列容量为2，有三个生产者，消费者每个1s从队列中取走一个消息。

```java
public class test6 {
    public static void main(String[] args) {
        MessageQueue queue = new MessageQueue(2);
        //三个生产者
        for (int i = 0; i < 3; i++) {
            int id = i;
            new Thread(() -> {
                queue.put(new Message(id, "消息" + id));
            }, "生产者" + i).start();
        }
        //一个消费者
        new Thread(() -> {
            while(true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                queue.take();
            }
        },"消费者").start();
    }
}
```

结果如下：

```bash
18:21:00.027 [生产者2] c.MessageQueue - 已生产消息：Message@285f6a49
18:21:00.030 [生产者0] c.MessageQueue - 已生产消息：Message@48cd9e47
18:21:00.030 [生产者1] c.MessageQueue - 消息队列已满，等待消费中...
18:21:01.039 [消费者] c.MessageQueue - 已消费消息：Message@285f6a49
18:21:01.039 [生产者1] c.MessageQueue - 已生产消息：Message@16d84426
18:21:02.044 [消费者] c.MessageQueue - 已消费消息：Message@48cd9e47
18:21:03.044 [消费者] c.MessageQueue - 已消费消息：Message@16d84426
18:21:04.056 [消费者] c.MessageQueue - 消息队列为空，等待生产中...
```

