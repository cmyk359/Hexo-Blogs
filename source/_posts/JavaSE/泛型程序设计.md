---
title: 泛型程序设计
categories:
  - JavaSE
abbrlink: 98735cb0
date: 2025-02-10 23:10:32
tags:
---

<meta name = "referrer", content = "no-referrer"/>

## 一、泛型概述

JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则在使用时进行强制类型转换很容易引发`ClassCastException`异常。

**泛型（Generics）**是 Java5引入的特性，允许在定义类、接口或方法时使用**类型参数**，使得代码可以灵活处理多种数据类型，同时保证类型安全。

泛型的核心思想是**参数化类型**，将类型作为参数传递给类或方法。

为什么要使用泛型？

- **类型安全**

  泛型提供了编译时类型安全监测机制，强制检查类型匹配，该机制可以在编译时检测到非法的类型数据结构。

- **消除类型转换**

  直接使用泛型类型，无需手动强制转换

- 代码复用

  编写一次泛型类或方法，可处理多种数据类型。

  ```java
  //泛型方法：支持任何可比较的类型
  public static <T extends Comparable<T>> T max(T a, T b) {
      return a.compareTo(b) >0 ? a : b;
  }
  ```

  

## 二、泛型的基本使用

### 泛型类

泛型类的定义语法：

```java
class 类名称 <泛型标识,泛型标识, …> {
	private 泛型标识 变量名;
    ....
}
```

常用的泛型标识：T、E、K、V

例如：

```java
/**
 * 泛型类的定义
 * @param <T> 创建对象时指定具体的数据类型。
 */
public class Generic<T> {
    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey() {
        return key;
    }

    public void setKey(T key) {
        this.key = key;
    }

    @Override
    public String toString() {
        return "Generic{" +
                "key=" + key +
                '}';
    }
}
```

使用语法：

```java
类名<具体的数据类型> 对象名 = new 类名<具体的数据类型>();
```

Javal.7以后，后面的<>中的具体的数据类型可以省略不写:

```java
类名<具体的数据类型> 对象名 = new 类名<>();
```

例如：

```java
public static void main(String[] args) {
    //泛型类在创建对象的时，指定操作的具体数据类型。
    Generic<String> strGeneric = new Generic<>("abc");
    String strKey = strGeneric.getKey();
    System.out.println(strKey);
    System.out.println("--------------------------");
    Generic<Integer> intGeneric = new Generic<>(123);
    Integer intKey = intGeneric.getKey();
    System.out.println(intKey);
}
```



**注意事项：**

1. 泛型类在创建对象的时候，若没有指定类型，将按照Object类型来操作。
2. 泛型的类型参数只能是类类型，不能是基本数据类型
3. 泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型

Java的泛型是通过**类型擦除**来实现的，在编译期间，所有的泛型类型信息都会被擦除，替换为原始类型（通常是Object）或者它们的边界类型。

基本数据类型（如`int`）不是对象，无法隐式转换为`Object`，所以泛型的类型参数不能是基本数据类型，通过包装类和自动装箱/拆箱，可以间接在泛型中使用基本类型；

在代码中，泛型类型参数化后，**逻辑上**会被视为不同的类型。由于类型擦除，**所有泛型类型在运行时都会被擦除为原始类型**，它们共享同一个Class对象。例如：

```java
//逻辑上List<String>和List<Integer>是不同的类型，但实际上它们在运行时是相同的类型。
//它们共享同一个Class对象，即List.class
List<String> strList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();

System.out.println(strList.getClass()); //class java.util.ArrayList
System.out.println(intList.getClass()); //class java.util.ArrayList
System.out.println(strList.getClass() == intList.getClass()); // true
```



### 泛型接口

泛型接口的定义:

```java
interface 接口名称 <泛型标识，泛型标识，…> {
	泛型标识 方法名();
}
```

泛型接口的使用：

- 实现类不是泛型类，接口要明确数据类型
- 实现类是泛型类，实现类和接口的泛型类型要一致

### 泛型方法

泛型方法的定义：

在返回类型前使用尖括号`<>`定义类型参数，正在的类型由方法调用者决定。

```java
修饰符 <T，E，...> 返回值类型 方法名（ 形参列表 ）{
    方法体...
}
```

注意点：

- 类型参数仅在方法内部有效，与类的泛型参数无关。

  ```java
  public class Utils {
      // 泛型方法：类型参数<T>由方法自身定义
      public static <T> T getFirst(List<T> list) {
          return list.get(0);
      }
  }
  ```

- 结合可变参数处理多个同类型参数

  ```java
  public static <T> void printAll(T... items) {
      for (T item : items) {
          System.out.println(item);
      }
  }
  ```

- 当要确保方法内部可以安全调用特定类型的方法时，可以限制类型参数的范围，使其必须继承某个类或实现某接口

  ```java
  // 限定T必须是Number的子类
  public static <T extends Number> double sum(T a, T b) {
      return a.doubleValue() + b.doubleValue();
  }
  ```

- 可以使用扩展类型列表，处理多个类型的参数

  ```java
  public <T,E,K> void printInput(T t, E e, K k) {
      System.out.println(t +"\t " + t.getClass());
      System.out.println(e +"\t " + e.getClass());
      System.out.println(k +"\t " + k.getClass());
  }
  ```

- **泛型方法 vs 泛型类的成员方法**

  | **维度**     | **泛型方法**                             | **泛型类的成员方法**                   |
  | ------------ | ---------------------------------------- | -------------------------------------- |
  | **定义位置** | 方法签名前独立声明类型参数               | 直接使用类的泛型参数                   |
  | **作用域**   | 仅在方法内有效                           | 类及其所有成员方法中有效               |
  | **静态方法** | 支持（如`public static <T> T method()`） | 不支持（静态方法无法访问类的泛型参数） |
  | **类型推断** | 由方法调用时的参数决定                   | 由类实例化时的类型参数决定             |



## 三、泛型类型的继承规则

### 泛型类的继承规则

在Java中，泛型类的继承规则与普通类有所不同，尤其是在处理类型参数时需遵循特定的约束。

1. 若子类为泛型类，**必须保持与父类泛型参数的兼容性**。子类可以：

   - **直接继承父类的泛型参数**：保持类型参数名称一致。
   - **扩展父类的泛型参数**：为父类类型参数添加边界约束。
   - **引入额外的泛型参数**：在继承父类泛型参数的同时定义新的类型参数。
   
   例如：
   
   ```java
   class Parent<T> {
    private T value;
    public void setValue(T value) { this.value = value; }
    public T getValue() { return value; }
   }
   //场景1：子类直接继承父类泛型参数
   class Child1<T> extends Parent<T> { // Child1的泛型参数T与Parent的T一致
   }
   
   //场景2：子类扩展父类泛型参数的边界
   class Child2<T extends Number> extends Parent<T> { // Parent的T被约束为Number或其子类
   }
   
   //场景3：子类引入新的泛型参数
   class Child3<T, U> extends Parent<T> { //新增泛型参数U，Parent的T保持独立
   }
   ```
   
   

2. 子类不是泛型类

   泛型类型需要在编译时确定，如果子类不提供类型参数，父类会被视为原始类型，导致类型不安全，编译器会发出警告。

   若子类不是泛型类，**必须为父类的泛型参数指定具体类型**。此时父类将失去泛型灵活性，但类型安全得到保证。

   例如：

   ```java
   class Parent<T> {
    private T value;
    public void setValue(T value) { this.value = value; }
    public T getValue() { return value; }
   }
   
   //子类指定父类的具体类型为
   Stringclass ConcreteChild extends Parent<String> { //父类的T被固定为String
   }
   ```

### 泛型接口的继承规则



## 四、类型通配符

Java 泛型中的**类型通配符**（`?`）用于增强泛型的灵活性，允许在参数化类型中表示未知的具体类型。其主要目的是解决**泛型类型的不可变性**问题（如`List<String>`和`List<Object>`无继承关系）。

三种类型通配符：

|    **类型**    | **语法**        | **用途**                                                     |
| :------------: | --------------- | ------------------------------------------------------------ |
| **无界通配符** | `<?>`           | 表示任意类型，但使用时类型信息完全丢失（只能调用与类型无关的方法，如`size()`）。 |
| **上界通配符** | `<? extends T>` | 表示`T`或其子类，主要用于**安全地读取数据**（协变）。        |
| **下界通配符** | `<? super T>`   | 表示`T`或其父类，主要用于**安全地写入数据**（逆变）。        |

具体分析如下：

- 无界通配符 `<?>`

  可以接受任意类型的泛型参数，如`List<?>`能接受`List<String>`或`List<Integer>`；但无法向其中添加数据（除null外），只能进行读取操作，返回值视为Object。
  
  ```java
  public void printList(List<?> list) {
      for (Object elem : list) {  // 元素类型视为Object
          System.out.println(elem);
      }
      // list.add("abc");  // 编译错误：无法确定具体类型
      list.add(null);      // 允许（null无类型）
  }
  ```
  
- 上界通配符`<? extends T>`

  要求该泛型的类型，只能是**`T`，或`T`的子类类型**。

  此时，允许读取类型为`T`或其子类的数据，但**无法添加数据**，因为编译器无法确定具体子类型。

  适用于只消费数据的场景，如遍历、计算。

  ```java
  public static double sum(List<? extends Number> list) {
      double sum = 0.0;
      for (Number num : list) {  // 安全读取为Number类型
          sum += num.doubleValue();
      }
      // list.add(123);  // 编译错误：实际类型可能是Double或Integer
      return sum;
  }
  
  // 调用示例
  List<Integer> intList = Arrays.asList(1, 2, 3);
  sum(intList);  // 允许传入List<Integer>（Integer是Number的子类）
  ```

- 下界通配符 `<? super T>`

  要求该泛型的类型，只能是**`T`，或`T`的父类类型**。

  此时，允许写入类型为`T`或其父类的数据，但读取数据时类型不确定，只能视为`Object`。

  适用于生产数据的场景，如向集合中添加元素。

  ```java
  public static void addNumbers(List<? super Integer> list) {
      for (int i = 1; i <= 3; i++) {
          list.add(i);  // 允许添加Integer及其父类（如Number、Object）
      }
      // Integer num = list.get(0);  // 编译错误：实际类型可能是Object
  }
  
  // 调用示例
  List<Number> numList = new ArrayList<>();
  addNumbers(numList);  // 允许传入List<Number>
  ```

核心区别：

| **维度**         | `<?>`                | `<? extends T>`      | `<? super T>`             |
| ---------------- | -------------------- | -------------------- | ------------------------- |
| **读取数据**     | 视为`Object`         | 视为`T`或其子类      | 只能视为`Object`          |
| **写入数据**     | 仅`null`             | ❌ 不允许             | ✅ 允许添加`T`或其子类对象 |
| **典型应用场景** | 不关心类型的通用操作 | 只读操作（Producer） | 只写操作（Consumer）      |
| **类型安全**     | 低                   | 高（限定了上界）     | 高（限定了下界）          |



**PECS原则（Producer-Extends, Consumer-Super）**

- **Producer（生产者）**：若泛型对象负责**提供数据**，使用`<? extends T>`。
- **Consumer（消费者）**：若泛型对象负责**接收数据**，使用`<? super T>`。

例如：实现一个通用的集合合并方法

```java
public static <T> void merge(
    List<? super T> dest,  // Consumer：接收T类型数据
    List<? extends T> src  // Producer：提供T类型数据
) {
    dest.addAll(src);
}

```



> **`List<?>`和`List<Object>`的区别？**
>
> - `List<?>`是未知类型的集合，只能读取为`Object`且无法写入（除`null`）。
> - `List<Object>`是明确类型的集合，可以添加任意对象。

## 五、类型擦除

泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉。

擦除机制：泛型类型在编译时替换为边界类型或`Object`，确保兼容性。

**核心思想**

- **编译时类型检查**：编译器验证泛型类型的安全性，如禁止`List<String>`添加整数。
- **运行时擦除**：将所有泛型类型参数替换为它们的**上界**（默认为`Object`）或具体指定类型。



### 擦除规则

**类型参数的替换规则**

- 无界泛型（如`<T>`）→ 替换为`Object`。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234157155-2025-2-1123:42:16.png" style="zoom:80%;" />

- 有界泛型（如`<T extends Number>`）→ 替换为上界`Number`。

  <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234307024-2025-2-1123:43:08.png" style="zoom:80%;" />

- 嵌套泛型，（如`List<List<String>>`）→ 外层保留，内层擦除为`List`

  ```java
  // 源码
  List<List<String>> nestedList = new ArrayList<>();
  
  // 擦除过程
  List<List<String>> → List<List> → List  // 逐层剥离类型参数，每层独立擦除。
  ```



**通配符的擦除规则**

- `<?>` → 擦除为`Object`。
- `<? extends Number>` → 擦除为`Number`。
- `<? super Integer>` → 擦除为`Object`。



### 桥接方法

桥接方法是 Java 编译器为了解决**泛型类型擦除**与**多态性**之间的冲突而自动生成的合成方法。

Java 的泛型在编译后会擦除类型信息，但子类重写父类泛型方法时，可能出现**方法签名不一致**的问题。桥接方法的作用是**保持多态性**，确保在类型擦除后，子类仍能正确重写父类的方法。

编译器会自动生成一个桥接方法，**将父类的方法调用“桥接”到子类实际的方法实现**。

<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211235351391-2025-2-1123:53:52.png" style="zoom:80%;" />

## 六、约束和限制

1、不能用基本类型实例化参数类型

2、运行时类型查询只适用于原始类型

3、不能创建参数化类型的数组

4、待补充....

## 七、泛型与反射

反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。但在某些特定场景下（例如泛型被具体化，如通过继承或字段声明），可以通过反射结合 `Type` 接口获取泛型信息。

**`Type` 接口**是Java 反射 API 中所有泛型类型信息的父接口，`ParameterizedType` 是 其子接口，用于表示**参数化类型**，其中包括三个方法

| **方法**                          | **返回值** | **用途**                                                     |
| --------------------------------- | ---------- | ------------------------------------------------------------ |
| `Type[] getActualTypeArguments()` | `Type[]`   | 获取参数化类型的实际泛型参数（如 `List<String>` 中的 `String`）。 |
| `Type getRawType()`               | `Type`     | 获取参数化类型的原始类型（如 `List<String>` 的原始类型是 `List.class`）。 |
| `Type getOwnerType()`             | `Type`     | 获取外层所有者类型（仅当参数化类型是成员类型时有效，否则返回 `null`）。 |



获取泛型类型：

- `Class.getGenericSuperclass()`：获取**父类**的泛型类型。
- `Field.getGenericType()`：获取**字段**的泛型类型。
- `Method.getGenericParameterTypes()`：获取方法参数的泛型类型。

- `Method.getGenericReturnType()`：获取**方法返回值**的泛型类型。

> 如果泛型未在类、字段或方法中具体化（如 `List<T>` 中的 `T` 未指定具体类型），则无法通过反射获取实际类型。

示例

**场景1：获取类的泛型父类信息**

```java
public class StringList extends ArrayList<String> { }  // 继承泛型父类

// 反射获取父类的泛型参数
Type genericSuperclass = StringList.class.getGenericSuperclass();

// 必须是ParameterizedType类型才能做接下来的操作，所以需要先判断
if (genericSuperclass instanceof ParameterizedType) {
    // 首先要强制转型成ParameterizedType类型，才能调用方法
    ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;
    //获取实际的参数化类型，即具体是什么泛型。可能有多个类型参数，返回一个数组
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
    Type firstTypeArgument = actualTypeArguments[0];  // 实际类型参数：String.class
    System.out.println(firstTypeArgument);  // 输出：class java.lang.String
}
```

**场景2：获取字段的泛型类型**

```java
public class GenericExample {
    private List<Map<String, Integer>> complexData;
}

// 反射获取字段的泛型类型
Field field = GenericExample.class.getDeclaredField("complexData");
Type genericType = field.getGenericType();

if (genericType instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) genericType;
    Type rawType = parameterizedType.getRawType();  // 原始类型：List.class

    // 获取嵌套泛型参数：Map<String, Integer>
    Type firstArgType = parameterizedType.getActualTypeArguments()[0];
    if (firstArgType instanceof ParameterizedType) {
        ParameterizedType nestedType = (ParameterizedType) firstArgType;
        Type nestedRawType = nestedType.getRawType();  // Map.class
        Type[] nestedArgs = nestedType.getActualTypeArguments();  // String.class, Integer.class
    }
}
```

**场景3：获取方法参数的泛型类型**

```java
public class Service {
    public void process(List<Map<String, Object>> data) { }
}

// 反射获取方法的泛型参数
Method method = Service.class.getMethod("process", List.class);
Type[] genericParamTypes = method.getGenericParameterTypes();
Type paramType = genericParamTypes[0];  // List<Map<String, Object>>

if (paramType instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) paramType;
    Type[] actualArgs = parameterizedType.getActualTypeArguments();  // Map<String, Object>
}
```

**场景4：获取方法返回值的泛型类型**

```java
public class DataFactory {
    public List<Number> createNumbers() { return new ArrayList<>(); }
}

// 反射获取返回值的泛型类型
Method method = DataFactory.class.getMethod("createNumbers");
Type returnType = method.getGenericReturnType();  // List<Number>

if (returnType instanceof ParameterizedType) {
    ParameterizedType parameterizedType = (ParameterizedType) returnType;
    Type[] actualArgs = parameterizedType.getActualTypeArguments();  // Number.class
}

```

