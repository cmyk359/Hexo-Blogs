---
title: 设计模式
categories:
  - 计算机基础
abbrlink: 364ea8cc
date: 2025-05-20 11:07:41
tags:
---

{% note info%}

参考书籍：《重学设计模式》

推荐学习网站：https://refactoringguru.cn/design-patterns

{% endnote%}



# 一、设计模式介绍

什么是设计模式？

设计模式是系统服务设计中针对常见场景的一种解决方案，可以解决功能逻辑开发中遇到的**共性问题**。

设计模式是一种开发设计指导思想，每一种设计模式都是解决某一类问题的**概念模型**，所以在实际的使用过程中，不要拘泥于某种已经存在的固定代码格式，而要根据实际的业务场景做出改变。

***

设计模式有哪些种类？

可以把设计模式按照其实现形式归为三类：

- **创建型模式**：提供创建对象的机制，提升已有代码的灵活性和可复用性。
- **结构型模式**：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。
- **行为模式**：负责对象间的高效沟通和职责传递委派。

***

如何学习设计模式？

设计模式本身是一种指导思想，它没有一种完全固定的实现方式，也不是已经落地的可参考的技术方案。就像建造一座大厦，原料虽然都是砖、石头、水泥、砂浆，都在图纸上设计出了卧室、厨房、卫浴、书房，但每一栋楼的造型都不同，如果按照不同的年代划分，风格将更加迥异。

很多人没有学会或领会设计模式，正是因为看理论书籍的学习过程是在别人总结的经验上倒推实现方案得来的，没有做到融会贯通。就像即使知道汽车是怎么开的，但如果没驾驶过几千公里，司机能记住的也只是理论，上路后依然会手忙脚乱！
要学会设计模式，就需要从具体的实战案例入手，**针对同一个需求，用不同的实现方需式来实现**。体会设计模式如何把一个类加 if else的实现方式优化为可扩展、易维护的服务模型。再通过多次练习和实操，把设计模式的思想学透、学懂。当然，这里还需要一定的刻苦练习，最终才能在设计模式的基础上构建出更加合理的代码。

# 二、六大设计原则

## 2.1、单一职责原则

### 定义

单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，它规定一个类应该只有一个发生变化的原因。简单来说就是，一个类应该只负责一项职责（功能），而不是承担多个不相关的职责。

一个类应该专注于做好一件事，避免因多个职责的耦合导致代码难以维护。

### 模拟场景

以一个视频网站用户分类的例子为例。

当在各类视频网站看电影、电视剧时，网站针对不同的用户类型，会在用户观看时给出不同的服务反馈，如以下三种。

- 访客用户，一般只可以观看480P视频，并时刻提醒用户注册会员能观看高清视频。这表示视频业务发展需要拉客，以获取更多的新注册用户。
- 普通会员，可以观看 720P 超清视频，但不能屏蔽视频中出现的广告。这表示视频业务发展需要盈利。
- VIP会员（属于付费用户），既可以观看1080P 蓝光视频，又可以关闭或跳过广告。

### 违背原则方案

根据需求场景直接编码，在一个类中实现一个最简单的基本功能，即根据不同的用户类型，判断用户可以观看视频的类型。

```java
class VideoUserService {
    public void serveGrade(String userType) {
        if ("VIP会员".equals(userType)) {
            System.out.println("VIP会员，视频1080p蓝光");
        } else if ("普通会员".equals(userType)) {
            System.out.println("普通会员，视频720p超清");
        } else if("访客用户".equals(userType)) {
            System.out.println("访客用户，视频480p高清");
        }
    }
}

//测试
@Test
public void test_serveGrade() {
    VideoUserService userService = new VideoUserService();
        userService.serveGrade("VIP会员");
        userService.serveGrade("普通会员");
        userService.serveGrade("访客用户");
}
```

这一个类里包含着多个不同的行为，也就是多种用户职责。如果在这样的类上继续扩展功能或添加逻辑，就会显得非常臃肿。

### 单一职责原则改善代码

为了满足不断迭代的需求，就不能使用一个类把所有职责行为混为一谈，而是需要提供一个上层的接口类，对不同的差异化用户给出单独的实现类，拆分各自的职责边界。

定义出上层接口`IVideoUserService`，统一定义需要实现的功能，包括：视频清晰级别接口definition、广告播放方式接口 advertisement。三种不同类型的用户就可以分别实现自己的服务类，做到职责统一。

```java
public interface IVideoUserService{
    //视频清晰级别：480P、720P、1080P
    void definition();

    //广告播放模式：有广告、无广告
    void advertisement();
}
```

- 实现类，访客用户。这个类实现的是访客用户在视频网站中的形态，比如这类用户只能观看480P高清视频，同时需要观看广告。

  ```java
  public class GuestVideoUserService implements IVideoUserService {
      @Override
      public void definition() {
          System.out.println("访客用户，视频480p高清");
      }
  
      @Override
      public void advertisement() {
          System.out.println("访客用户，视频有广告");
      }
  }
  ```

- 实现类，普通会员。这个类实现的是普通会员在视频网站中的形态，也就是注册用户可以观看 720P 超清视频，另外也需要观看广告。

  ```java
  public class OrdinaryVideoUserService implements IVideoUserService {
      @Override
      public void definition() {
          System.out.println("普通会员，视频720p超清");
      }
  
      @Override
      public void advertisement() {
          System.out.println("普通用户，视频有广告");
      }
  }
  ```

- 实现类，VIP会员。这个类实现的是VIP会员在视频网站中的形态。因为这类用户已经是付费用户，所以可以观看更高清的视频，同时不需要观看广告。

  ```java
  public class VIPVideoUserService implements IVideoUserService {
      @Override
      public void definition() {
          System.out.println("VIP会员，视频1080p蓝光");
      }
  
      @Override
      public void advertisement() {
          System.out.println("VIP会员，视频无广告");
      }
  }
  ```



通过利用单一职责原则的代码优化后，现在每个类都只负责自己的用户行为。后续无论扩展新的功能还是需要在某个时刻修改某个用户行为类，都可以非常方便地开发和维护。

在项目开发的过程中，尽可能保证接口的定义、类的实现以及方法开发保持单一职责，对项目后期的迭代和维护会有很大的帮助。

## 2.2、开闭原则

### 定义

在面向对象编程领域中，开闭原则规定软件中的<u>对象、类、模块和函数</u>**对扩展应该是开放的，但对于修改是封闭的**。这意味着应该用抽象定义结构，用具体实现扩展细节，以此确保软件系统开发和维护过程的可靠性。

开闭原则的核心思想也可以理解为**面向抽象编程**。对于外部的调用方来说，只要能体现出面向抽象编程，定义出接口并实现其方法，即不修改原有方法体，只通过继承方式进行扩展，都可以体现出开闭原则。

### 模拟场景

这里计算三种形状的面积，如长方形、三角形、圆形，它们在类中已经按照固定的公式实现，其中圆形面积公式中π=3.14。但后续由于π值取的精度对于某些场景是不足的，需要扩展。接下来就通过模拟这个场景体现开闭原则。

- 定义接口，其中分别定义了三种求面积的接口。

  ```java
  public interface ICalculationArea{
      /**
       *  计算面积，长方形
       * @param x 长
       * @param y 宽
       * @return 面积
       */
      double rectangle(double x, double y);
  
      /**
       * 计算面积，三角形
       * @param × 边长 ×
       * @param y 边长 y
       * @param z 边长 z
       * @return 面积
       *  海伦公式：s=√[p（p-a）（p-b）（p-c）.其中 p=（a+b+c）/2
       */
      double triangle(double x, double y, double z);
  
      /**
       * 计算面积，圆形
       * @param r 半径
       * @return 面积
       * 圆面积公式：S=nr2
       */
      double circular(double r);
  }
  ```

- 实现类。在实现类中，分别实现三种类型的面积计算。其中，圆形面积的π 值取的是 3.14D，这也是要扩展精度的方法和体现开闭原则的地方。

  ```java
  public class CalculationArea implements  ICalculationArea {
      private final static double π = 3.14D;
      @Override
      public double rectangle(double x, double y) {
          return x * y;
      }
  
      @Override
      public double triangle(double x, double y, double z) {
          double p= (x+y+z) /2;
          return Math. sqrt (p* (p -x) *(p-y)* (p -z));
      }
  
      @Override
      public double circular(double r) {
          return π * r * r;
      }
  }
  ```

### 违背原则方案

如果不考虑开闭原则，也不思考这种方法在整个工程服务中的使用情况，那么直接修改π值就可以了；但这样做就会破坏整个工程服务的稳定性，也会造成一些风险。

例如，用原来精度的π值计算出的圆形面积本可以满足需求，但是因为精度加长破坏了原有精度下的稳定性，就像齿轮间的啮合程度、方向盘的间隙等。

```java
//直接修改π的值
private final static double π = 3.141592653D;
public double circular(double r) {
    return π * r * r;
}
```

### 开闭原则改善代码

按照开闭原则方式实现起来并不复杂，它的主要目的是不能因为个例需求的变化而改变预定的实现类（**对修改关闭**），除非预定的实现类有错误。

实现过程是继承父类扩展需要的方法，同时可以保留原有的方法，新增自己需要的方法。

```java
public class CalculationAreaExt extends CalculationArea {
    private final static double π = 3.141592653D;

    @Override
    public double circular(double r) {
        return π * r * r;
    }
}
```

扩展后的方法已经把求圆形面积的精度增长，需要使用此方法的用户可以直接调用。而其他的方法，如长方形面积、三角形面积，则可以继续使用。

## 2.3、里氏替换原则

### 定义

里氏替换原则（LSP） 指出：继承必须确保超类所拥有的性质在子类中仍然成立。

如果 S 是 T 的子类型，那么所有 T 类型的对象都可以在不破坏程序的情况下被 S 类型的对象替换。

简单来说，**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：当子类继承父类时，除添加新的方法且完成新增功能外，尽量不要重写父类的方法。这句话包含了四点含义：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。
- 当子类的方法实现父类的方法（重写、重载或实现抽象方法）时，方法的后置条件（即方法的输出或返回值）要比父类的方法更严格或与父类的方法相等。



{% note info%}

里氏替换原则是实现多态性的基础。多态性允许我们以父类的形式使用子类对象，但这一前提是子类必须完全遵循父类的行为规范。只有这样，程序才能在父类和子类之间无缝切换，而不会产生问题。

{% endnote%}

***

里氏替换原则的作用：

- 里氏替换原则是实现开闭原则的重要方式之一。
- 解决了继承中重写父类造成的可复用性变差的问题。
- 是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
- 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

### 模拟场景

一个常见的反例是“正方形-矩形”问题。如果我们有一个Rectangle类和一个Square类，并且考虑用Square类（正方形）继承Rectangle类。

### 违背原则的方案

在继承之后，正方形需要满足矩形的所有行为和特性。然而，正方形有一个特殊性质：它的宽和高必须相等。为了让Square类保持这个性质，必须重写setWidth和setHeight方法，使得在设置任意一边的长度时，另一边的长度也自动调整为相同的值。

这就导致了一个问题：如果程序中本来是使用Rectangle对象的地方，换成Square对象后，程序的行为可能会发生变化。

因此，Square 继承 Rectangle 违反了里氏替换原则。

```java
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;  // 正方形必须保持长宽相等
    }

    @Override
    public void setHeight(int height) {
        this.height = height;
        this.width = height;  // 正方形必须保持长宽相等
    }
}

```



测试：`testRectangleArea()` 方法假设 `setWidth()` 和 `setHeight()` 是独立的，但 `Square` 强制修改两者，导致结果不符合预期。

```java
public class Main {
    // 这个方法期望矩形的面积是 width * height
    public static void testRectangleArea(Rectangle rectangle) {
        rectangle.setWidth(5);
        rectangle.setHeight(4);
        System.out.println("Expected Area: 20, Actual Area: " + rectangle.getArea());
    }

    public static void main(String[] args) {
        Rectangle rect = new Rectangle();
        testRectangleArea(rect);  // 输出: Expected Area: 20, Actual Area: 20 ✅

        Rectangle square = new Square();
        testRectangleArea(square);  // 输出: Expected Area: 20, Actual Area: 16 ❌
    }
}

```



### 里氏替换原则改善代码

为了解决正方形和矩形之间不合理的继承关系，我们可以采用**组合或接口**，而不是继承（inheritance）的设计方式。

思路：创建一个公共的接口或抽象类Shape，定义所有形状共有的行为，比如计算面积的方法getArea()；让正方形和矩形都实现这个接口，各自独立实现计算逻辑。

```java
interface Shape {
    int getArea();
}

class Rectangle implements Shape {
    private int width;
    private int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    @Override
    public int getArea() {
        return width * height;
    }
}

class Square implements Shape {
    private int side;

    public void setSide(int side) {
        this.side = side;
    }

    @Override
    public int getArea() {
        return side * side;
    }
}

```



## 2.4、迪米特(最少知道)法则原则

### 定义

迪米特法则又称为最少知道原则，是指一个对象类对于其他对象类来说，知道得越少越好。也就是说，两个类之间不要有过多的耦合关系，保持最少关联性。

迪米特法则有一句经典语录：只和朋友通信，不和陌生人说话。也就是说，有内在关联的类要内聚，没有直接关系的类要低耦合。

### 模拟场景

通过模拟学生、老师、校长之间关系的例子来说明迪米特法则。老师需要负责具体某一个学生的学习情况，而校长会关心老师所在班级的总体成绩，不会过问具体某一个学生的学习情况。

下面模拟这样的例子，如果校长想知道一个班级的总分和平均分，是应该找老师要，还是跟每一个学生要再进行统计呢？显然是应该找具体的班主任老师。我们在实际开发时，容易忽略这样的真实情况，开发出逻辑错误的程序。

### 违背原则方案

首先定义—个学生信息类,这个类比较简单,包括学生姓名、考试排名、总分

```java
public class Student{
	private String name; //学生姓名
    private int rank; //考试排名（总排名）   
    private double grade;//总分
	
    //...get/set
}
```

之后再定义出老师类，在老师类里初始化学生的信息，以及提供基本的信息获取接口。

```java
public class Teacher {
    private String name;  //教师姓名
    private String clazz;  //班级
    private static List<Student> studentList; //学生列表

    static {
        studentList = new ArrayList<>();
        studentList.add(new Student("花花", 10, 589));
        studentList.add(new Student("豆豆", 54, 356));
        studentList.add(new Student("秋雅", 23, 439));
        studentList.add(new Student("皮皮", 2, 665));
        studentList.add(new Student("蛋蛋", 19, 509));

    }
    
    public Teacher(String name, String clazz) {
        this.name = name;
        this.clazz = clazz;
    }
    public static List<Student> getStudentList(){
        return studentList;
    }
    
	//...get/set
}
```

接下来定义校长类，校长管理全局，并在校长类中获取学生人数、总分、平均分等。

```java
public class Principal {

    private Teacher teacher = new Teacher("丽华", "3年1班");

    // 查询班级信息，总分数、学生人数、平均值
    public Map<String, Object> queryClazzInfo(String clazzId) {
        // 获取班级信息；学生总人数、总分、平均分
        int stuCount = clazzStudentCount();
        double totalScore = clazzTotalScore();
        double averageScore = clazzAverageScore();

        // 组装对象，实际业务开发会有对应的类
        Map<String, Object> mapObj = new HashMap<>();
        mapObj.put("班级", teacher.getClazz());
        mapObj.put("老师", teacher.getName());
        mapObj.put("学生人数", stuCount);
        mapObj.put("班级总分数", totalScore);
        mapObj.put("班级平均分", averageScore);
        return mapObj;
    }

    // 总分
    public double clazzTotalScore() {
        double totalScore = 0;
        for (Student stu : teacher.getStudentList()) {
            totalScore += stu.getGrade();
        }
        return totalScore;
    }

    // 平均分
    public double clazzAverageScore(){
        double totalScore = 0;
        for (Student stu : teacher.getStudentList()) {
            totalScore += stu.getGrade();
        }
        return totalScore / teacher.getStudentList().size();
    }

    // 班级人数
    public int clazzStudentCount(){
        return teacher.getStudentList().size();
    }

}
```



以上就是通过校长管理所有学生，老师只提供了非常简单的信息。虽然可以查询到结果，但是违背了迪米特法则，因为校长需要了解每个学生的情况。如果所有班级都让校长类统计，代码就会变得非常臃肿，也不易于维护利扩展。

### 迪米特法则改善代码

从以上的实现方式我们发现，不该让校长直接管理学生，校长应该管理老师，由老师提供相应的学生信息查询服务。那么，接下来我们就把校长要的信息交给老师类去处理，这样每一位老师都会提供相应的功能，校长类只需要调用使用即可，而不需要了解每一位学生的分数。

```java
public class Teacher {

    private String name;                // 老师名称
    private String clazz;               // 班级
    private static List<Student> studentList;  // 学生

    static {
        studentList = new ArrayList<>();
        studentList.add(new Student("花花", 10, 589));
        studentList.add(new Student("豆豆", 54, 356));
        studentList.add(new Student("秋雅", 23, 439));
        studentList.add(new Student("皮皮", 2, 665));
        studentList.add(new Student("蛋蛋", 19, 502));
    }
    
    public Teacher(String name, String clazz) {
        this.name = name;
        this.clazz = clazz;
    }
    
    // 总分
    public double clazzTotalScore() {
        double totalScore = 0;
        for (Student stu : studentList) {
            totalScore += stu.getGrade();
        }
        return totalScore;
    }

    // 平均分
    public double clazzAverageScore(){
        double totalScore = 0;
        for (Student stu : studentList) {
            totalScore += stu.getGrade();
        }
        return totalScore / studentList.size();
    }

    // 班级人数
    public int clazzStudentCount(){
        return studentList.size();
    }

    public String getName() {
        return name;
    }

    public String getClazz() {
        return clazz;
    }
}
```



```java
public class Principal {

    private Teacher teacher = new Teacher("丽华", "3年1班");

    // 查询班级信息，总分数、学生人数、平均值
    public Map<String, Object> queryClazzInfo(String clazzId) {
        // 获取班级信息；学生总人数、总分、平均分
        int stuCount = teacher.clazzStudentCount();
        double totalScore = teacher.clazzTotalScore();
        double averageScore = teacher.clazzAverageScore();

        // 组装对象，实际业务开发会有对应的类
        Map<String, Object> mapObj = new HashMap<>();
        mapObj.put("班级", teacher.getClazz());
        mapObj.put("老师", teacher.getName());
        mapObj.put("学生人数", stuCount);
        mapObj.put("班级总分数", totalScore);
        mapObj.put("班级平均分", averageScore);
        return mapObj;
    }

}

```

## 2.5、接口隔离原则

### 

《代码整洁之道》的作者Robert C.Martin于2002年给“接口隔离原则”的定义是：**客户端不应该被迫依赖于它不使用的方法**。该原则还有另外一个定义：**一个类对另一个类的依赖应该建立在最小的接口上**。

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

在具体应用接口隔离原则时，应该根据以下几个规则衡量。

- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，要深入了解业务逻辑。
- 提高内聚，减少对外交互。让接口用最少的方法完成最多的事情。

接口隔离是为了高内聚、低耦合。在实际的业务开发中，通常会先定义好需要开发的接口，并由各个服务类实现。但如果没有经过考虑和设计，就很可能造成一个接口中包括众多的接口方法，而这些接口并不一定在每一个类中都需要实现。这样的接口很难维护，也不易于扩展，每一次修改验证都有潜在的风险。

## 2.6、依赖倒置原则

### 定义

依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

### 场景模拟

在互联网的营销活动中，经常为了拉新和促活，会做一些抽奖活动。这些抽奖活动的规则会随着业务的不断发展而调整，如随机抽奖、权重抽奖等。其中，权重是指用户在当前系统中的一个综合排名，比如活跃度、贡献度等。
下面模拟出抽奖的一个系统服务，如果是初次搭建这样的系统会怎么实现？这个系统是否有良好的扩展性和可维护性，同时在变动和新增业务时测试的复杂度是否高？这些都是在系统服务设计时需要考虑的问题。

### 违背原则方案

先用最直接的方式，即按照不同的抽奖逻辑定义出不同的接口，让外部的服务调用。

- 用户类：包括了用户姓名和对应的权重，方便满足不同的抽奖方式。

  ```java
  public class BetUser {
  
      private String userName;  // 用户姓名
      private int userWeight;   // 用户权重
  
  	//constructor, getter, setter ....
  }
  
  ```

- 在一个类中用两个接口实现两种不同的抽奖逻辑

  ```java
  public class DrawControl {
  
      // 随机抽取指定数量的用户，作为中奖用户
      public List<BetUser> doDrawRandom(List<BetUser> list, int count) {
          // 集合数量很小直接返回
          if (list.size() <= count) return list;
          // 乱序集合
          Collections.shuffle(list);
          // 取出指定数量的中奖用户
          List<BetUser> prizeList = new ArrayList<>(count);
          for (int i = 0; i < count; i++) {
              prizeList.add(list.get(i));
          }
          return prizeList;
      }
  
      // 权重排名获取指定数量的用户，作为中奖用户
      public List<BetUser> doDrawWeight(List<BetUser> list, int count) {
          // 按照权重排序
          list.sort((o1, o2) -> {
              int e = o2.getUserWeight() - o1.getUserWeight();
              if (0 == e) return 0;
              return e > 0 ? 1 : -1;
          });
          // 取出指定数量的中奖用户
          List<BetUser> prizeList = new ArrayList<>(count);
          for (int i = 0; i < count; i++) {
              prizeList.add(list.get(i));
          }
          return prizeList;
      }
  
  }
  
  ```

首先，这样的实现方式扩展起来很麻烦，每次扩展都需要新增接口，同时对于调用方来说需要新增调用接口的代码。其次，对于这个服务类来说，随着接口数量的增加，代码行数会不断地暴增，最后难以维护。

### 依赖倒置原则改善代码

既然上述方式不具备良好的扩展性，那么用依赖倒置、面向抽象编程的方式实现。

- 首先定义抽奖功能的接口，任何一个实现方都可以实现自己的抽奖逻辑。

  接口中包括了需要传输的 抽奖用户集合，以及中奖用户数量。

  ```java
  public interface IDraw {
  
      // 获取中奖用户接口
      List<BetUser> prize(List<BetUser> list, int count);
  
  }
  
  ```

- 随机抽奖实现

  这部分随机抽奖逻辑与上面的抽奖方式逻辑是一样的，只不过放到接口实现中了

  ```java
  public class DrawRandom implements IDraw {
  
      @Override
      public List<BetUser> prize(List<BetUser> list, int count) {
          // 集合数量很小直接返回
          if (list.size() <= count) return list;
          // 乱序集合
          Collections.shuffle(list);
          // 取出指定数量的中奖用户
          List<BetUser> prizeList = new ArrayList<>(count);
          for (int i = 0; i < count; i++) {
              prizeList.add(list.get(i));
          }
          return prizeList;
      }
  
  }
  ```

- 权重抽奖实现

  权重抽奖也是一样，把这些都放到自己的接口实现中。

  ```java
  public class DrawWeightRank implements IDraw {
  
      @Override
      public List<BetUser> prize(List<BetUser> list, int count) {
          // 按照权重排序
          list.sort((o1, o2) -> {
              int e = o2.getUserWeight() - o1.getUserWeight();
              if (0 == e) return 0;
              return e > 0 ? 1 : -1;
          });
          // 取出指定数量的中奖用户
          List<BetUser> prizeList = new ArrayList<>(count);
          for (int i = 0; i < count; i++) {
              prizeList.add(list.get(i));
          }
          return prizeList;
      }
  
  }
  
  ```

- 创建抽奖服务

  在这个类中体现了依赖倒置的重要性，可以把任何一种抽奖逻辑传递给这个类。这样实现的好处是可以不断地扩展，但是不需要在外部新增调用接口，降低了一套代码的维护成本，并提高了可扩展性及可维护性。

  ```java
  public class DrawService {
  
      private IDraw draw;
  
      public List<BetUser> doDraw(IDraw draw, List<BetUser> betUserList, int count) {
          return draw.prize(betUserList, count);
      }
  }
  ```

  



# 三、创建型模式

# 四、结构型模式

# 五、行为模式